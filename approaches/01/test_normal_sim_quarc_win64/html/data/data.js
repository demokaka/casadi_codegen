var DataHeading = 'Code'; var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"test_normal_sim","ref":false,"files":[{"name":"test_normal_sim.c","type":"source","group":"model","path":"C:\\Users\\khanh\\dev\\python\\projects\\casadi_codegen\\approaches\\01\\test_normal_sim_quarc_win64","tag":"","groupDisplay":"Model files","code":"/*\r\n * test_normal_sim.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"test_normal_sim\".\r\n *\r\n * Model version              : 19.0\r\n * Simulink Coder version : 25.1 (R2025a) 21-Nov-2024\r\n * C source code generated on : Fri Sep 12 15:50:10 2025\r\n *\r\n * Target selection: quarc_win64.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"test_normal_sim.h\"\r\n#include <string.h>\r\n#include \"test_normal_sim_private.h\"\r\n#include \"test_normal_sim_dt.h\"\r\n\r\n/* Block signals (default storage) */\r\nB_test_normal_sim_T test_normal_sim_B;\r\n\r\n/* Block states (default storage) */\r\nDW_test_normal_sim_T test_normal_sim_DW;\r\n\r\n/* Real-time model */\r\nstatic RT_MODEL_test_normal_sim_T test_normal_sim_M_;\r\nRT_MODEL_test_normal_sim_T *const test_normal_sim_M = &test_normal_sim_M_;\r\n\r\n/* Model output function */\r\nvoid test_normal_sim_output(void)\r\n{\r\n  /* SignalConversion generated from: '<Root>/S-Function' */\r\n  test_normal_sim_B.TmpSignalConversionAtSFunctionI[0] = 0.0;\r\n  test_normal_sim_B.TmpSignalConversionAtSFunctionI[1] = 0.0;\r\n\r\n  /* SignalConversion generated from: '<Root>/S-Function' */\r\n  memset(&test_normal_sim_B.TmpSignalConversionAtSFunctio_j[0], 0, 12U * sizeof\r\n         (real_T));\r\n\r\n  /* S-Function (solver_01_wrapper): '<Root>/S-Function' */\r\n\r\n  /* Level2 S-Function Block: '<Root>/S-Function' (solver_01_wrapper) */\r\n  {\r\n    SimStruct *rts = test_normal_sim_M->childSfunctions[0];\r\n    sfcnOutputs(rts,0);\r\n  }\r\n}\r\n\r\n/* Model update function */\r\nvoid test_normal_sim_update(void)\r\n{\r\n  /* Update absolute time for base rate */\r\n  /* The \"clockTick0\" counts the number of times the code of this task has\r\n   * been executed. The absolute time is the multiplication of \"clockTick0\"\r\n   * and \"Timing.stepSize0\". Size of \"clockTick0\" ensures timer will not\r\n   * overflow during the application lifespan selected.\r\n   * Timer of this task consists of two 32 bit unsigned integers.\r\n   * The two integers represent the low bits Timing.clockTick0 and the high bits\r\n   * Timing.clockTickH0. When the low bit overflows to 0, the high bits increment.\r\n   */\r\n  if (!(++test_normal_sim_M->Timing.clockTick0)) {\r\n    ++test_normal_sim_M->Timing.clockTickH0;\r\n  }\r\n\r\n  test_normal_sim_M->Timing.t[0] = test_normal_sim_M->Timing.clockTick0 *\r\n    test_normal_sim_M->Timing.stepSize0 + test_normal_sim_M->Timing.clockTickH0 *\r\n    test_normal_sim_M->Timing.stepSize0 * 4294967296.0;\r\n}\r\n\r\n/* Model initialize function */\r\nvoid test_normal_sim_initialize(void)\r\n{\r\n  /* Start for S-Function (hil_initialize_block): '<Root>/HIL Initialize' */\r\n\r\n  /* S-Function Block: test_normal_sim/HIL Initialize (hil_initialize_block) */\r\n  {\r\n    t_int result;\r\n    t_boolean is_switching;\r\n    result = hil_open(\"qube_servo3_usb\", \"0@tcpip://localhost:18922\",\r\n                      &test_normal_sim_DW.HILInitialize_Card);\r\n    if (result < 0) {\r\n      msg_get_error_messageA(NULL, result, _rt_error_message, sizeof\r\n        (_rt_error_message));\r\n      rtmSetErrorStatus(test_normal_sim_M, _rt_error_message);\r\n      return;\r\n    }\r\n\r\n    is_switching = false;\r\n    result = hil_set_card_specific_options(test_normal_sim_DW.HILInitialize_Card,\r\n      \"deadband_compensation=0.3;pwm_en=0;enc0_velocity=3.0;enc1_velocity=3.0;min_diode_compensation=0.3;max_diode_compensation=1.5\",\r\n      125);\r\n    if (result < 0) {\r\n      msg_get_error_messageA(NULL, result, _rt_error_message, sizeof\r\n        (_rt_error_message));\r\n      rtmSetErrorStatus(test_normal_sim_M, _rt_error_message);\r\n      return;\r\n    }\r\n\r\n    result = hil_watchdog_clear(test_normal_sim_DW.HILInitialize_Card);\r\n    if (result < 0 && result != -QERR_HIL_WATCHDOG_CLEAR) {\r\n      msg_get_error_messageA(NULL, result, _rt_error_message, sizeof\r\n        (_rt_error_message));\r\n      rtmSetErrorStatus(test_normal_sim_M, _rt_error_message);\r\n      return;\r\n    }\r\n\r\n    if ((test_normal_sim_P.HILInitialize_AIPStart && !is_switching) ||\r\n        (test_normal_sim_P.HILInitialize_AIPEnter && is_switching)) {\r\n      result = hil_set_analog_input_ranges(test_normal_sim_DW.HILInitialize_Card,\r\n        &test_normal_sim_P.HILInitialize_AIChannels, 1U,\r\n        &test_normal_sim_P.HILInitialize_AILow,\r\n        &test_normal_sim_P.HILInitialize_AIHigh);\r\n      if (result < 0) {\r\n        msg_get_error_messageA(NULL, result, _rt_error_message, sizeof\r\n          (_rt_error_message));\r\n        rtmSetErrorStatus(test_normal_sim_M, _rt_error_message);\r\n        return;\r\n      }\r\n    }\r\n\r\n    if ((test_normal_sim_P.HILInitialize_AOPStart && !is_switching) ||\r\n        (test_normal_sim_P.HILInitialize_AOPEnter && is_switching)) {\r\n      result = hil_set_analog_output_ranges\r\n        (test_normal_sim_DW.HILInitialize_Card,\r\n         &test_normal_sim_P.HILInitialize_AOChannels, 1U,\r\n         &test_normal_sim_P.HILInitialize_AOLow,\r\n         &test_normal_sim_P.HILInitialize_AOHigh);\r\n      if (result < 0) {\r\n        msg_get_error_messageA(NULL, result, _rt_error_message, sizeof\r\n          (_rt_error_message));\r\n        rtmSetErrorStatus(test_normal_sim_M, _rt_error_message);\r\n        return;\r\n      }\r\n    }\r\n\r\n    if ((test_normal_sim_P.HILInitialize_AOStart && !is_switching) ||\r\n        (test_normal_sim_P.HILInitialize_AOEnter && is_switching)) {\r\n      result = hil_write_analog(test_normal_sim_DW.HILInitialize_Card,\r\n        &test_normal_sim_P.HILInitialize_AOChannels, 1U,\r\n        &test_normal_sim_P.HILInitialize_AOInitial);\r\n      if (result < 0) {\r\n        msg_get_error_messageA(NULL, result, _rt_error_message, sizeof\r\n          (_rt_error_message));\r\n        rtmSetErrorStatus(test_normal_sim_M, _rt_error_message);\r\n        return;\r\n      }\r\n    }\r\n\r\n    if (test_normal_sim_P.HILInitialize_AOReset) {\r\n      result = hil_watchdog_set_analog_expiration_state\r\n        (test_normal_sim_DW.HILInitialize_Card,\r\n         &test_normal_sim_P.HILInitialize_AOChannels, 1U,\r\n         &test_normal_sim_P.HILInitialize_AOWatchdog);\r\n      if (result < 0) {\r\n        msg_get_error_messageA(NULL, result, _rt_error_message, sizeof\r\n          (_rt_error_message));\r\n        rtmSetErrorStatus(test_normal_sim_M, _rt_error_message);\r\n        return;\r\n      }\r\n    }\r\n\r\n    result = hil_set_digital_directions(test_normal_sim_DW.HILInitialize_Card,\r\n      NULL, 0U, &test_normal_sim_P.HILInitialize_DOChannels, 1U);\r\n    if (result < 0) {\r\n      msg_get_error_messageA(NULL, result, _rt_error_message, sizeof\r\n        (_rt_error_message));\r\n      rtmSetErrorStatus(test_normal_sim_M, _rt_error_message);\r\n      return;\r\n    }\r\n\r\n    if ((test_normal_sim_P.HILInitialize_DOStart && !is_switching) ||\r\n        (test_normal_sim_P.HILInitialize_DOEnter && is_switching)) {\r\n      result = hil_write_digital(test_normal_sim_DW.HILInitialize_Card,\r\n        &test_normal_sim_P.HILInitialize_DOChannels, 1U, (t_boolean *)\r\n        &test_normal_sim_P.HILInitialize_DOInitial);\r\n      if (result < 0) {\r\n        msg_get_error_messageA(NULL, result, _rt_error_message, sizeof\r\n          (_rt_error_message));\r\n        rtmSetErrorStatus(test_normal_sim_M, _rt_error_message);\r\n        return;\r\n      }\r\n    }\r\n\r\n    if (test_normal_sim_P.HILInitialize_DOReset) {\r\n      result = hil_watchdog_set_digital_expiration_state\r\n        (test_normal_sim_DW.HILInitialize_Card,\r\n         &test_normal_sim_P.HILInitialize_DOChannels, 1U, (const t_digital_state\r\n          *) &test_normal_sim_P.HILInitialize_DOWatchdog);\r\n      if (result < 0) {\r\n        msg_get_error_messageA(NULL, result, _rt_error_message, sizeof\r\n          (_rt_error_message));\r\n        rtmSetErrorStatus(test_normal_sim_M, _rt_error_message);\r\n        return;\r\n      }\r\n    }\r\n\r\n    if ((test_normal_sim_P.HILInitialize_EIPStart && !is_switching) ||\r\n        (test_normal_sim_P.HILInitialize_EIPEnter && is_switching)) {\r\n      test_normal_sim_DW.HILInitialize_QuadratureModes[0] =\r\n        test_normal_sim_P.HILInitialize_EIQuadrature;\r\n      test_normal_sim_DW.HILInitialize_QuadratureModes[1] =\r\n        test_normal_sim_P.HILInitialize_EIQuadrature;\r\n      result = hil_set_encoder_quadrature_mode\r\n        (test_normal_sim_DW.HILInitialize_Card,\r\n         test_normal_sim_P.HILInitialize_EIChannels, 2U,\r\n         (t_encoder_quadrature_mode *)\r\n         &test_normal_sim_DW.HILInitialize_QuadratureModes[0]);\r\n      if (result < 0) {\r\n        msg_get_error_messageA(NULL, result, _rt_error_message, sizeof\r\n          (_rt_error_message));\r\n        rtmSetErrorStatus(test_normal_sim_M, _rt_error_message);\r\n        return;\r\n      }\r\n    }\r\n\r\n    if ((test_normal_sim_P.HILInitialize_EIStart && !is_switching) ||\r\n        (test_normal_sim_P.HILInitialize_EIEnter && is_switching)) {\r\n      test_normal_sim_DW.HILInitialize_InitialEICounts[0] =\r\n        test_normal_sim_P.HILInitialize_EIInitial;\r\n      test_normal_sim_DW.HILInitialize_InitialEICounts[1] =\r\n        test_normal_sim_P.HILInitialize_EIInitial;\r\n      result = hil_set_encoder_counts(test_normal_sim_DW.HILInitialize_Card,\r\n        test_normal_sim_P.HILInitialize_EIChannels, 2U,\r\n        &test_normal_sim_DW.HILInitialize_InitialEICounts[0]);\r\n      if (result < 0) {\r\n        msg_get_error_messageA(NULL, result, _rt_error_message, sizeof\r\n          (_rt_error_message));\r\n        rtmSetErrorStatus(test_normal_sim_M, _rt_error_message);\r\n        return;\r\n      }\r\n    }\r\n\r\n    if ((test_normal_sim_P.HILInitialize_OOStart && !is_switching) ||\r\n        (test_normal_sim_P.HILInitialize_OOEnter && is_switching)) {\r\n      result = hil_write_other(test_normal_sim_DW.HILInitialize_Card,\r\n        test_normal_sim_P.HILInitialize_OOChannels, 3U,\r\n        test_normal_sim_P.HILInitialize_OOInitial);\r\n      if (result < 0) {\r\n        msg_get_error_messageA(NULL, result, _rt_error_message, sizeof\r\n          (_rt_error_message));\r\n        rtmSetErrorStatus(test_normal_sim_M, _rt_error_message);\r\n        return;\r\n      }\r\n    }\r\n\r\n    if (test_normal_sim_P.HILInitialize_OOReset) {\r\n      result = hil_watchdog_set_other_expiration_state\r\n        (test_normal_sim_DW.HILInitialize_Card,\r\n         test_normal_sim_P.HILInitialize_OOChannels, 3U,\r\n         test_normal_sim_P.HILInitialize_OOWatchdog);\r\n      if (result < 0) {\r\n        msg_get_error_messageA(NULL, result, _rt_error_message, sizeof\r\n          (_rt_error_message));\r\n        rtmSetErrorStatus(test_normal_sim_M, _rt_error_message);\r\n        return;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/* Model terminate function */\r\nvoid test_normal_sim_terminate(void)\r\n{\r\n  /* Terminate for S-Function (hil_initialize_block): '<Root>/HIL Initialize' */\r\n\r\n  /* S-Function Block: test_normal_sim/HIL Initialize (hil_initialize_block) */\r\n  {\r\n    t_boolean is_switching;\r\n    t_int result;\r\n    t_uint32 num_final_analog_outputs = 0;\r\n    t_uint32 num_final_digital_outputs = 0;\r\n    t_uint32 num_final_other_outputs = 0;\r\n    hil_task_stop_all(test_normal_sim_DW.HILInitialize_Card);\r\n    hil_monitor_stop_all(test_normal_sim_DW.HILInitialize_Card);\r\n    is_switching = false;\r\n    if ((test_normal_sim_P.HILInitialize_AOTerminate && !is_switching) ||\r\n        (test_normal_sim_P.HILInitialize_AOExit && is_switching)) {\r\n      num_final_analog_outputs = 1U;\r\n    } else {\r\n      num_final_analog_outputs = 0;\r\n    }\r\n\r\n    if ((test_normal_sim_P.HILInitialize_DOTerminate && !is_switching) ||\r\n        (test_normal_sim_P.HILInitialize_DOExit && is_switching)) {\r\n      num_final_digital_outputs = 1U;\r\n    } else {\r\n      num_final_digital_outputs = 0;\r\n    }\r\n\r\n    if ((test_normal_sim_P.HILInitialize_OOTerminate && !is_switching) ||\r\n        (test_normal_sim_P.HILInitialize_OOExit && is_switching)) {\r\n      num_final_other_outputs = 3U;\r\n    } else {\r\n      num_final_other_outputs = 0;\r\n    }\r\n\r\n    if (0\r\n        || num_final_analog_outputs > 0\r\n        || num_final_digital_outputs > 0\r\n        || num_final_other_outputs > 0\r\n        ) {\r\n      /* Attempt to write the final outputs atomically (due to firmware issue in old Q2-USB). Otherwise write channels individually */\r\n      result = hil_write(test_normal_sim_DW.HILInitialize_Card\r\n                         , &test_normal_sim_P.HILInitialize_AOChannels,\r\n                         num_final_analog_outputs\r\n                         , NULL, 0\r\n                         , &test_normal_sim_P.HILInitialize_DOChannels,\r\n                         num_final_digital_outputs\r\n                         , test_normal_sim_P.HILInitialize_OOChannels,\r\n                         num_final_other_outputs\r\n                         , &test_normal_sim_P.HILInitialize_AOFinal\r\n                         , NULL\r\n                         , (t_boolean *)\r\n                         &test_normal_sim_P.HILInitialize_DOFinal\r\n                         , test_normal_sim_P.HILInitialize_OOFinal\r\n                         );\r\n      if (result == -QERR_HIL_WRITE_NOT_SUPPORTED) {\r\n        t_error local_result;\r\n        result = 0;\r\n\r\n        /* The hil_write operation is not supported by this card. Write final outputs for each channel type */\r\n        if (num_final_analog_outputs > 0) {\r\n          local_result = hil_write_analog(test_normal_sim_DW.HILInitialize_Card,\r\n            &test_normal_sim_P.HILInitialize_AOChannels,\r\n            num_final_analog_outputs, &test_normal_sim_P.HILInitialize_AOFinal);\r\n          if (local_result < 0) {\r\n            result = local_result;\r\n          }\r\n        }\r\n\r\n        if (num_final_digital_outputs > 0) {\r\n          local_result = hil_write_digital(test_normal_sim_DW.HILInitialize_Card,\r\n            &test_normal_sim_P.HILInitialize_DOChannels,\r\n            num_final_digital_outputs, (t_boolean *)\r\n            &test_normal_sim_P.HILInitialize_DOFinal);\r\n          if (local_result < 0) {\r\n            result = local_result;\r\n          }\r\n        }\r\n\r\n        if (num_final_other_outputs > 0) {\r\n          local_result = hil_write_other(test_normal_sim_DW.HILInitialize_Card,\r\n            test_normal_sim_P.HILInitialize_OOChannels, num_final_other_outputs,\r\n            test_normal_sim_P.HILInitialize_OOFinal);\r\n          if (local_result < 0) {\r\n            result = local_result;\r\n          }\r\n        }\r\n\r\n        if (result < 0) {\r\n          msg_get_error_messageA(NULL, result, _rt_error_message, sizeof\r\n            (_rt_error_message));\r\n          rtmSetErrorStatus(test_normal_sim_M, _rt_error_message);\r\n        }\r\n      }\r\n    }\r\n\r\n    hil_task_delete_all(test_normal_sim_DW.HILInitialize_Card);\r\n    hil_monitor_delete_all(test_normal_sim_DW.HILInitialize_Card);\r\n    hil_close(test_normal_sim_DW.HILInitialize_Card);\r\n    test_normal_sim_DW.HILInitialize_Card = NULL;\r\n  }\r\n\r\n  /* Terminate for S-Function (solver_01_wrapper): '<Root>/S-Function' */\r\n  /* Level2 S-Function Block: '<Root>/S-Function' (solver_01_wrapper) */\r\n  {\r\n    SimStruct *rts = test_normal_sim_M->childSfunctions[0];\r\n    sfcnTerminate(rts);\r\n  }\r\n}\r\n\r\n/*========================================================================*\r\n * Start of Classic call interface                                        *\r\n *========================================================================*/\r\nvoid MdlOutputs(int_T tid)\r\n{\r\n  test_normal_sim_output();\r\n  UNUSED_PARAMETER(tid);\r\n}\r\n\r\nvoid MdlUpdate(int_T tid)\r\n{\r\n  test_normal_sim_update();\r\n  UNUSED_PARAMETER(tid);\r\n}\r\n\r\nvoid MdlInitializeSizes(void)\r\n{\r\n}\r\n\r\nvoid MdlInitializeSampleTimes(void)\r\n{\r\n}\r\n\r\nvoid MdlInitialize(void)\r\n{\r\n}\r\n\r\nvoid MdlStart(void)\r\n{\r\n  test_normal_sim_initialize();\r\n}\r\n\r\nvoid MdlTerminate(void)\r\n{\r\n  test_normal_sim_terminate();\r\n}\r\n\r\n/* Registration function */\r\nRT_MODEL_test_normal_sim_T *test_normal_sim(void)\r\n{\r\n  /* Registration code */\r\n\r\n  /* initialize real-time model */\r\n  (void) memset((void *)test_normal_sim_M, 0,\r\n                sizeof(RT_MODEL_test_normal_sim_T));\r\n  rtsiSetSolverName(&test_normal_sim_M->solverInfo,\"FixedStepDiscrete\");\r\n  test_normal_sim_M->solverInfoPtr = (&test_normal_sim_M->solverInfo);\r\n\r\n  /* Initialize timing info */\r\n  {\r\n    int_T *mdlTsMap = test_normal_sim_M->Timing.sampleTimeTaskIDArray;\r\n    mdlTsMap[0] = 0;\r\n    test_normal_sim_M->Timing.sampleTimeTaskIDPtr = (&mdlTsMap[0]);\r\n    test_normal_sim_M->Timing.sampleTimes =\r\n      (&test_normal_sim_M->Timing.sampleTimesArray[0]);\r\n    test_normal_sim_M->Timing.offsetTimes =\r\n      (&test_normal_sim_M->Timing.offsetTimesArray[0]);\r\n\r\n    /* task periods */\r\n    test_normal_sim_M->Timing.sampleTimes[0] = (0.002);\r\n\r\n    /* task offsets */\r\n    test_normal_sim_M->Timing.offsetTimes[0] = (0.0);\r\n  }\r\n\r\n  rtmSetTPtr(test_normal_sim_M, &test_normal_sim_M->Timing.tArray[0]);\r\n\r\n  {\r\n    int_T *mdlSampleHits = test_normal_sim_M->Timing.sampleHitArray;\r\n    mdlSampleHits[0] = 1;\r\n    test_normal_sim_M->Timing.sampleHits = (&mdlSampleHits[0]);\r\n  }\r\n\r\n  rtmSetTFinal(test_normal_sim_M, -1);\r\n  test_normal_sim_M->Timing.stepSize0 = 0.002;\r\n\r\n  /* External mode info */\r\n  test_normal_sim_M->Sizes.checksums[0] = (2659884964U);\r\n  test_normal_sim_M->Sizes.checksums[1] = (2266293486U);\r\n  test_normal_sim_M->Sizes.checksums[2] = (2880939103U);\r\n  test_normal_sim_M->Sizes.checksums[3] = (509233838U);\r\n\r\n  {\r\n    static const sysRanDType rtAlwaysEnabled = SUBSYS_RAN_BC_ENABLE;\r\n    static RTWExtModeInfo rt_ExtModeInfo;\r\n    static const sysRanDType *systemRan[1];\r\n    test_normal_sim_M->extModeInfo = (&rt_ExtModeInfo);\r\n    rteiSetSubSystemActiveVectorAddresses(&rt_ExtModeInfo, systemRan);\r\n    systemRan[0] = &rtAlwaysEnabled;\r\n    rteiSetModelMappingInfoPtr(test_normal_sim_M->extModeInfo,\r\n      &test_normal_sim_M->SpecialInfo.mappingInfo);\r\n    rteiSetChecksumsPtr(test_normal_sim_M->extModeInfo,\r\n                        test_normal_sim_M->Sizes.checksums);\r\n    rteiSetTPtr(test_normal_sim_M->extModeInfo, rtmGetTPtr(test_normal_sim_M));\r\n  }\r\n\r\n  test_normal_sim_M->solverInfoPtr = (&test_normal_sim_M->solverInfo);\r\n  test_normal_sim_M->Timing.stepSize = (0.002);\r\n  rtsiSetFixedStepSize(&test_normal_sim_M->solverInfo, 0.002);\r\n  rtsiSetSolverMode(&test_normal_sim_M->solverInfo, SOLVER_MODE_SINGLETASKING);\r\n\r\n  /* block I/O */\r\n  test_normal_sim_M->blockIO = ((void *) &test_normal_sim_B);\r\n  (void) memset(((void *) &test_normal_sim_B), 0,\r\n                sizeof(B_test_normal_sim_T));\r\n\r\n  /* parameters */\r\n  test_normal_sim_M->defaultParam = ((real_T *)&test_normal_sim_P);\r\n\r\n  /* states (dwork) */\r\n  test_normal_sim_M->dwork = ((void *) &test_normal_sim_DW);\r\n  (void) memset((void *)&test_normal_sim_DW, 0,\r\n                sizeof(DW_test_normal_sim_T));\r\n\r\n  /* data type transition information */\r\n  {\r\n    static DataTypeTransInfo dtInfo;\r\n    (void) memset((char_T *) &dtInfo, 0,\r\n                  sizeof(dtInfo));\r\n    test_normal_sim_M->SpecialInfo.mappingInfo = (&dtInfo);\r\n    dtInfo.numDataTypes = 20;\r\n    dtInfo.dataTypeSizes = &rtDataTypeSizes[0];\r\n    dtInfo.dataTypeNames = &rtDataTypeNames[0];\r\n\r\n    /* Block I/O transition table */\r\n    dtInfo.BTransTable = &rtBTransTable;\r\n\r\n    /* Parameters transition table */\r\n    dtInfo.PTransTable = &rtPTransTable;\r\n  }\r\n\r\n  /* child S-Function registration */\r\n  {\r\n    RTWSfcnInfo *sfcnInfo = &test_normal_sim_M->NonInlinedSFcns.sfcnInfo;\r\n    test_normal_sim_M->sfcnInfo = (sfcnInfo);\r\n    rtssSetErrorStatusPtr(sfcnInfo, (&rtmGetErrorStatus(test_normal_sim_M)));\r\n    test_normal_sim_M->Sizes.numSampTimes = (1);\r\n    rtssSetNumRootSampTimesPtr(sfcnInfo, &test_normal_sim_M->Sizes.numSampTimes);\r\n    test_normal_sim_M->NonInlinedSFcns.taskTimePtrs[0] = (&rtmGetTPtr\r\n      (test_normal_sim_M)[0]);\r\n    rtssSetTPtrPtr(sfcnInfo,test_normal_sim_M->NonInlinedSFcns.taskTimePtrs);\r\n    rtssSetTStartPtr(sfcnInfo, &rtmGetTStart(test_normal_sim_M));\r\n    rtssSetTFinalPtr(sfcnInfo, &rtmGetTFinal(test_normal_sim_M));\r\n    rtssSetTimeOfLastOutputPtr(sfcnInfo, &rtmGetTimeOfLastOutput\r\n      (test_normal_sim_M));\r\n    rtssSetStepSizePtr(sfcnInfo, &test_normal_sim_M->Timing.stepSize);\r\n    rtssSetStopRequestedPtr(sfcnInfo, &rtmGetStopRequested(test_normal_sim_M));\r\n    rtssSetDerivCacheNeedsResetPtr(sfcnInfo,\r\n      &test_normal_sim_M->derivCacheNeedsReset);\r\n    rtssSetZCCacheNeedsResetPtr(sfcnInfo, &test_normal_sim_M->zCCacheNeedsReset);\r\n    rtssSetContTimeOutputInconsistentWithStateAtMajorStepPtr(sfcnInfo,\r\n      &test_normal_sim_M->CTOutputIncnstWithState);\r\n    rtssSetSampleHitsPtr(sfcnInfo, &test_normal_sim_M->Timing.sampleHits);\r\n    rtssSetPerTaskSampleHitsPtr(sfcnInfo,\r\n      &test_normal_sim_M->Timing.perTaskSampleHits);\r\n    rtssSetSimModePtr(sfcnInfo, &test_normal_sim_M->simMode);\r\n    rtssSetSolverInfoPtr(sfcnInfo, &test_normal_sim_M->solverInfoPtr);\r\n  }\r\n\r\n  test_normal_sim_M->Sizes.numSFcns = (1);\r\n\r\n  /* register each child */\r\n  {\r\n    (void) memset((void *)&test_normal_sim_M->NonInlinedSFcns.childSFunctions[0],\r\n                  0,\r\n                  1*sizeof(SimStruct));\r\n    test_normal_sim_M->childSfunctions =\r\n      (&test_normal_sim_M->NonInlinedSFcns.childSFunctionPtrs[0]);\r\n    test_normal_sim_M->childSfunctions[0] =\r\n      (&test_normal_sim_M->NonInlinedSFcns.childSFunctions[0]);\r\n\r\n    /* Level2 S-Function Block: test_normal_sim/<Root>/S-Function (solver_01_wrapper) */\r\n    {\r\n      SimStruct *rts = test_normal_sim_M->childSfunctions[0];\r\n\r\n      /* timing info */\r\n      time_T *sfcnPeriod = test_normal_sim_M->NonInlinedSFcns.Sfcn0.sfcnPeriod;\r\n      time_T *sfcnOffset = test_normal_sim_M->NonInlinedSFcns.Sfcn0.sfcnOffset;\r\n      int_T *sfcnTsMap = test_normal_sim_M->NonInlinedSFcns.Sfcn0.sfcnTsMap;\r\n      (void) memset((void*)sfcnPeriod, 0,\r\n                    sizeof(time_T)*1);\r\n      (void) memset((void*)sfcnOffset, 0,\r\n                    sizeof(time_T)*1);\r\n      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);\r\n      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);\r\n      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);\r\n\r\n      {\r\n        ssSetBlkInfo2Ptr(rts, &test_normal_sim_M->NonInlinedSFcns.blkInfo2[0]);\r\n      }\r\n\r\n      _ssSetBlkInfo2PortInfo2Ptr(rts,\r\n        &test_normal_sim_M->NonInlinedSFcns.inputOutputPortInfo2[0]);\r\n\r\n      /* Set up the mdlInfo pointer */\r\n      ssSetRTWSfcnInfo(rts, test_normal_sim_M->sfcnInfo);\r\n\r\n      /* Allocate memory of model methods 2 */\r\n      {\r\n        ssSetModelMethods2(rts, &test_normal_sim_M->NonInlinedSFcns.methods2[0]);\r\n      }\r\n\r\n      /* Allocate memory of model methods 3 */\r\n      {\r\n        ssSetModelMethods3(rts, &test_normal_sim_M->NonInlinedSFcns.methods3[0]);\r\n      }\r\n\r\n      /* Allocate memory of model methods 4 */\r\n      {\r\n        ssSetModelMethods4(rts, &test_normal_sim_M->NonInlinedSFcns.methods4[0]);\r\n      }\r\n\r\n      /* Allocate memory for states auxilliary information */\r\n      {\r\n        ssSetStatesInfo2(rts, &test_normal_sim_M->NonInlinedSFcns.statesInfo2[0]);\r\n        ssSetPeriodicStatesInfo(rts,\r\n          &test_normal_sim_M->NonInlinedSFcns.periodicStatesInfo[0]);\r\n      }\r\n\r\n      /* inputs */\r\n      {\r\n        _ssSetNumInputPorts(rts, 2);\r\n        ssSetPortInfoForInputs(rts,\r\n          &test_normal_sim_M->NonInlinedSFcns.Sfcn0.inputPortInfo[0]);\r\n        ssSetPortInfoForInputs(rts,\r\n          &test_normal_sim_M->NonInlinedSFcns.Sfcn0.inputPortInfo[0]);\r\n        _ssSetPortInfo2ForInputUnits(rts,\r\n          &test_normal_sim_M->NonInlinedSFcns.Sfcn0.inputPortUnits[0]);\r\n        ssSetInputPortUnit(rts, 0, 0);\r\n        ssSetInputPortUnit(rts, 1, 0);\r\n        _ssSetPortInfo2ForInputCoSimAttribute(rts,\r\n          &test_normal_sim_M->NonInlinedSFcns.Sfcn0.inputPortCoSimAttribute[0]);\r\n        ssSetInputPortIsContinuousQuantity(rts, 0, 0);\r\n        ssSetInputPortIsContinuousQuantity(rts, 1, 0);\r\n\r\n        /* port 0 */\r\n        {\r\n          int_T *dimensions = (int_T *)\r\n            &test_normal_sim_M->NonInlinedSFcns.Sfcn0.iDims0;\r\n          ssSetInputPortRequiredContiguous(rts, 0, 1);\r\n          ssSetInputPortSignal(rts, 0,\r\n                               test_normal_sim_B.TmpSignalConversionAtSFunctionI);\r\n          dimensions[0] = 2;\r\n          dimensions[1] = 1;\r\n          _ssSetInputPortDimensionsPtrAsInt(rts, 0, dimensions);\r\n          _ssSetInputPortNumDimensions(rts, 0, 2);\r\n          ssSetInputPortWidthAsInt(rts, 0, 2);\r\n        }\r\n\r\n        /* port 1 */\r\n        {\r\n          int_T *dimensions = (int_T *)\r\n            &test_normal_sim_M->NonInlinedSFcns.Sfcn0.iDims1;\r\n          ssSetInputPortRequiredContiguous(rts, 1, 1);\r\n          ssSetInputPortSignal(rts, 1,\r\n                               test_normal_sim_B.TmpSignalConversionAtSFunctio_j);\r\n          dimensions[0] = 2;\r\n          dimensions[1] = 6;\r\n          _ssSetInputPortDimensionsPtrAsInt(rts, 1, dimensions);\r\n          _ssSetInputPortNumDimensions(rts, 1, 2);\r\n          ssSetInputPortWidthAsInt(rts, 1, 12);\r\n        }\r\n      }\r\n\r\n      /* outputs */\r\n      {\r\n        ssSetPortInfoForOutputs(rts,\r\n          &test_normal_sim_M->NonInlinedSFcns.Sfcn0.outputPortInfo[0]);\r\n        ssSetPortInfoForOutputs(rts,\r\n          &test_normal_sim_M->NonInlinedSFcns.Sfcn0.outputPortInfo[0]);\r\n        _ssSetNumOutputPorts(rts, 1);\r\n        _ssSetPortInfo2ForOutputUnits(rts,\r\n          &test_normal_sim_M->NonInlinedSFcns.Sfcn0.outputPortUnits[0]);\r\n        ssSetOutputPortUnit(rts, 0, 0);\r\n        _ssSetPortInfo2ForOutputCoSimAttribute(rts,\r\n          &test_normal_sim_M->NonInlinedSFcns.Sfcn0.outputPortCoSimAttribute[0]);\r\n        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);\r\n\r\n        /* port 0 */\r\n        {\r\n          int_T *dimensions = (int_T *)\r\n            &test_normal_sim_M->NonInlinedSFcns.Sfcn0.oDims0;\r\n          dimensions[0] = 1;\r\n          dimensions[1] = 1;\r\n          _ssSetOutputPortDimensionsPtrAsInt(rts, 0, dimensions);\r\n          _ssSetOutputPortNumDimensions(rts, 0, 2);\r\n          ssSetOutputPortWidthAsInt(rts, 0, 1);\r\n          ssSetOutputPortSignal(rts, 0, ((real_T *) &test_normal_sim_B.SFunction));\r\n        }\r\n      }\r\n\r\n      /* path info */\r\n      ssSetModelName(rts, \"S-Function\");\r\n      ssSetPath(rts, \"test_normal_sim/S-Function\");\r\n      ssSetRTModel(rts,test_normal_sim_M);\r\n      ssSetParentSS(rts, (NULL));\r\n      ssSetRootSS(rts, rts);\r\n      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);\r\n\r\n      /* work vectors */\r\n      ssSetRWork(rts, (real_T *) &test_normal_sim_DW.SFunction_RWORK[0]);\r\n      ssSetIWork(rts, (int_T *) &test_normal_sim_DW.SFunction_IWORK[0]);\r\n      ssSetPWork(rts, (void **) &test_normal_sim_DW.SFunction_PWORK[0]);\r\n\r\n      {\r\n        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)\r\n          &test_normal_sim_M->NonInlinedSFcns.Sfcn0.dWork;\r\n        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)\r\n          &test_normal_sim_M->NonInlinedSFcns.Sfcn0.dWorkAux;\r\n        ssSetSFcnDWork(rts, dWorkRecord);\r\n        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);\r\n        ssSetNumDWorkAsInt(rts, 3);\r\n\r\n        /* RWORK */\r\n        ssSetDWorkWidthAsInt(rts, 0, 980);\r\n        ssSetDWorkDataType(rts, 0,SS_DOUBLE);\r\n        ssSetDWorkComplexSignal(rts, 0, 0);\r\n        ssSetDWork(rts, 0, &test_normal_sim_DW.SFunction_RWORK[0]);\r\n\r\n        /* IWORK */\r\n        ssSetDWorkWidthAsInt(rts, 1, 18);\r\n        ssSetDWorkDataType(rts, 1,SS_INTEGER);\r\n        ssSetDWorkComplexSignal(rts, 1, 0);\r\n        ssSetDWork(rts, 1, &test_normal_sim_DW.SFunction_IWORK[0]);\r\n\r\n        /* PWORK */\r\n        ssSetDWorkWidthAsInt(rts, 2, 55);\r\n        ssSetDWorkDataType(rts, 2,SS_POINTER);\r\n        ssSetDWorkComplexSignal(rts, 2, 0);\r\n        ssSetDWork(rts, 2, &test_normal_sim_DW.SFunction_PWORK[0]);\r\n      }\r\n\r\n      /* registration */\r\n      solver_01_wrapper(rts);\r\n      sfcnInitializeSizes(rts);\r\n      sfcnInitializeSampleTimes(rts);\r\n\r\n      /* adjust sample time */\r\n      ssSetSampleTime(rts, 0, 0.002);\r\n      ssSetOffsetTime(rts, 0, 0.0);\r\n      sfcnTsMap[0] = 0;\r\n\r\n      /* set compiled values of dynamic vector attributes */\r\n      ssSetNumNonsampledZCsAsInt(rts, 0);\r\n\r\n      /* Update connectivity flags for each port */\r\n      _ssSetInputPortConnected(rts, 0, 1);\r\n      _ssSetInputPortConnected(rts, 1, 1);\r\n      _ssSetOutputPortConnected(rts, 0, 0);\r\n      _ssSetOutputPortBeingMerged(rts, 0, 0);\r\n\r\n      /* Update the BufferDstPort flags for each input port */\r\n      ssSetInputPortBufferDstPort(rts, 0, -1);\r\n      ssSetInputPortBufferDstPort(rts, 1, -1);\r\n    }\r\n  }\r\n\r\n  /* Initialize Sizes */\r\n  test_normal_sim_M->Sizes.numContStates = (0);/* Number of continuous states */\r\n  test_normal_sim_M->Sizes.numY = (0); /* Number of model outputs */\r\n  test_normal_sim_M->Sizes.numU = (0); /* Number of model inputs */\r\n  test_normal_sim_M->Sizes.sysDirFeedThru = (0);/* The model is not direct feedthrough */\r\n  test_normal_sim_M->Sizes.numSampTimes = (1);/* Number of sample times */\r\n  test_normal_sim_M->Sizes.numBlocks = (4);/* Number of blocks */\r\n  test_normal_sim_M->Sizes.numBlockIO = (3);/* Number of block outputs */\r\n  test_normal_sim_M->Sizes.numBlockPrms = (76);/* Sum of parameter \"widths\" */\r\n  return test_normal_sim_M;\r\n}\r\n\r\n/*========================================================================*\r\n * End of Classic call interface                                          *\r\n *========================================================================*/\r\n"},{"name":"test_normal_sim.h","type":"header","group":"model","path":"C:\\Users\\khanh\\dev\\python\\projects\\casadi_codegen\\approaches\\01\\test_normal_sim_quarc_win64","tag":"","groupDisplay":"Model files","code":"/*\r\n * test_normal_sim.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"test_normal_sim\".\r\n *\r\n * Model version              : 19.0\r\n * Simulink Coder version : 25.1 (R2025a) 21-Nov-2024\r\n * C source code generated on : Fri Sep 12 15:50:10 2025\r\n *\r\n * Target selection: quarc_win64.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef test_normal_sim_h_\r\n#define test_normal_sim_h_\r\n#ifndef test_normal_sim_COMMON_INCLUDES_\r\n#define test_normal_sim_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#include \"simstruc.h\"\r\n#include \"fixedpoint.h\"\r\n#include \"rt_nonfinite.h\"\r\n#include \"math.h\"\r\n#include \"dt_info.h\"\r\n#include \"ext_work.h\"\r\n#include \"hil.h\"\r\n#include \"quanser_messages.h\"\r\n#include \"quanser_extern.h\"\r\n#endif                                 /* test_normal_sim_COMMON_INCLUDES_ */\r\n\r\n#include \"test_normal_sim_types.h\"\r\n#include <string.h>\r\n#include <stddef.h>\r\n#include \"rt_defines.h\"\r\n#include \"zero_crossing_types.h\"\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetBlockIO\r\n#define rtmGetBlockIO(rtm)             ((rtm)->blockIO)\r\n#endif\r\n\r\n#ifndef rtmSetBlockIO\r\n#define rtmSetBlockIO(rtm, val)        ((rtm)->blockIO = (val))\r\n#endif\r\n\r\n#ifndef rtmGetChecksums\r\n#define rtmGetChecksums(rtm)           ((rtm)->Sizes.checksums)\r\n#endif\r\n\r\n#ifndef rtmSetChecksums\r\n#define rtmSetChecksums(rtm, val)      ((rtm)->Sizes.checksums = (val))\r\n#endif\r\n\r\n#ifndef rtmGetConstBlockIO\r\n#define rtmGetConstBlockIO(rtm)        ((rtm)->constBlockIO)\r\n#endif\r\n\r\n#ifndef rtmSetConstBlockIO\r\n#define rtmSetConstBlockIO(rtm, val)   ((rtm)->constBlockIO = (val))\r\n#endif\r\n\r\n#ifndef rtmGetContStateDisabled\r\n#define rtmGetContStateDisabled(rtm)   ((rtm)->contStateDisabled)\r\n#endif\r\n\r\n#ifndef rtmSetContStateDisabled\r\n#define rtmSetContStateDisabled(rtm, val) ((rtm)->contStateDisabled = (val))\r\n#endif\r\n\r\n#ifndef rtmGetContStates\r\n#define rtmGetContStates(rtm)          ((rtm)->contStates)\r\n#endif\r\n\r\n#ifndef rtmSetContStates\r\n#define rtmSetContStates(rtm, val)     ((rtm)->contStates = (val))\r\n#endif\r\n\r\n#ifndef rtmGetContTimeOutputInconsistentWithStateAtMajorStepFlag\r\n#define rtmGetContTimeOutputInconsistentWithStateAtMajorStepFlag(rtm) ((rtm)->CTOutputIncnstWithState)\r\n#endif\r\n\r\n#ifndef rtmSetContTimeOutputInconsistentWithStateAtMajorStepFlag\r\n#define rtmSetContTimeOutputInconsistentWithStateAtMajorStepFlag(rtm, val) ((rtm)->CTOutputIncnstWithState = (val))\r\n#endif\r\n\r\n#ifndef rtmGetCtrlRateMdlRefTiming\r\n#define rtmGetCtrlRateMdlRefTiming(rtm) ()\r\n#endif\r\n\r\n#ifndef rtmSetCtrlRateMdlRefTiming\r\n#define rtmSetCtrlRateMdlRefTiming(rtm, val) ()\r\n#endif\r\n\r\n#ifndef rtmGetCtrlRateMdlRefTimingPtr\r\n#define rtmGetCtrlRateMdlRefTimingPtr(rtm) ()\r\n#endif\r\n\r\n#ifndef rtmSetCtrlRateMdlRefTimingPtr\r\n#define rtmSetCtrlRateMdlRefTimingPtr(rtm, val) ()\r\n#endif\r\n\r\n#ifndef rtmGetCtrlRateNumTicksToNextHit\r\n#define rtmGetCtrlRateNumTicksToNextHit(rtm) ()\r\n#endif\r\n\r\n#ifndef rtmSetCtrlRateNumTicksToNextHit\r\n#define rtmSetCtrlRateNumTicksToNextHit(rtm, val) ()\r\n#endif\r\n\r\n#ifndef rtmGetDataMapInfo\r\n#define rtmGetDataMapInfo(rtm)         ()\r\n#endif\r\n\r\n#ifndef rtmSetDataMapInfo\r\n#define rtmSetDataMapInfo(rtm, val)    ()\r\n#endif\r\n\r\n#ifndef rtmGetDefaultParam\r\n#define rtmGetDefaultParam(rtm)        ((rtm)->defaultParam)\r\n#endif\r\n\r\n#ifndef rtmSetDefaultParam\r\n#define rtmSetDefaultParam(rtm, val)   ((rtm)->defaultParam = (val))\r\n#endif\r\n\r\n#ifndef rtmGetDerivCacheNeedsReset\r\n#define rtmGetDerivCacheNeedsReset(rtm) ((rtm)->derivCacheNeedsReset)\r\n#endif\r\n\r\n#ifndef rtmSetDerivCacheNeedsReset\r\n#define rtmSetDerivCacheNeedsReset(rtm, val) ((rtm)->derivCacheNeedsReset = (val))\r\n#endif\r\n\r\n#ifndef rtmGetDirectFeedThrough\r\n#define rtmGetDirectFeedThrough(rtm)   ((rtm)->Sizes.sysDirFeedThru)\r\n#endif\r\n\r\n#ifndef rtmSetDirectFeedThrough\r\n#define rtmSetDirectFeedThrough(rtm, val) ((rtm)->Sizes.sysDirFeedThru = (val))\r\n#endif\r\n\r\n#ifndef rtmGetErrorStatusFlag\r\n#define rtmGetErrorStatusFlag(rtm)     ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatusFlag\r\n#define rtmSetErrorStatusFlag(rtm, val) ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n#ifndef rtmGetFinalTime\r\n#define rtmGetFinalTime(rtm)           ((rtm)->Timing.tFinal)\r\n#endif\r\n\r\n#ifndef rtmSetFinalTime\r\n#define rtmSetFinalTime(rtm, val)      ((rtm)->Timing.tFinal = (val))\r\n#endif\r\n\r\n#ifndef rtmGetFirstInitCondFlag\r\n#define rtmGetFirstInitCondFlag(rtm)   ()\r\n#endif\r\n\r\n#ifndef rtmSetFirstInitCondFlag\r\n#define rtmSetFirstInitCondFlag(rtm, val) ()\r\n#endif\r\n\r\n#ifndef rtmGetIntgData\r\n#define rtmGetIntgData(rtm)            ()\r\n#endif\r\n\r\n#ifndef rtmSetIntgData\r\n#define rtmSetIntgData(rtm, val)       ()\r\n#endif\r\n\r\n#ifndef rtmGetMdlRefGlobalRuntimeEventIndices\r\n#define rtmGetMdlRefGlobalRuntimeEventIndices(rtm) ()\r\n#endif\r\n\r\n#ifndef rtmSetMdlRefGlobalRuntimeEventIndices\r\n#define rtmSetMdlRefGlobalRuntimeEventIndices(rtm, val) ()\r\n#endif\r\n\r\n#ifndef rtmGetMdlRefGlobalTID\r\n#define rtmGetMdlRefGlobalTID(rtm)     ()\r\n#endif\r\n\r\n#ifndef rtmSetMdlRefGlobalTID\r\n#define rtmSetMdlRefGlobalTID(rtm, val) ()\r\n#endif\r\n\r\n#ifndef rtmGetMdlRefGlobalTimerIndices\r\n#define rtmGetMdlRefGlobalTimerIndices(rtm) ()\r\n#endif\r\n\r\n#ifndef rtmSetMdlRefGlobalTimerIndices\r\n#define rtmSetMdlRefGlobalTimerIndices(rtm, val) ()\r\n#endif\r\n\r\n#ifndef rtmGetMdlRefTriggerTID\r\n#define rtmGetMdlRefTriggerTID(rtm)    ()\r\n#endif\r\n\r\n#ifndef rtmSetMdlRefTriggerTID\r\n#define rtmSetMdlRefTriggerTID(rtm, val) ()\r\n#endif\r\n\r\n#ifndef rtmGetModelMappingInfo\r\n#define rtmGetModelMappingInfo(rtm)    ((rtm)->SpecialInfo.mappingInfo)\r\n#endif\r\n\r\n#ifndef rtmSetModelMappingInfo\r\n#define rtmSetModelMappingInfo(rtm, val) ((rtm)->SpecialInfo.mappingInfo = (val))\r\n#endif\r\n\r\n#ifndef rtmGetModelName\r\n#define rtmGetModelName(rtm)           ((rtm)->modelName)\r\n#endif\r\n\r\n#ifndef rtmSetModelName\r\n#define rtmSetModelName(rtm, val)      ((rtm)->modelName = (val))\r\n#endif\r\n\r\n#ifndef rtmGetNonInlinedSFcns\r\n#define rtmGetNonInlinedSFcns(rtm)     ((rtm)->NonInlinedSFcns)\r\n#endif\r\n\r\n#ifndef rtmSetNonInlinedSFcns\r\n#define rtmSetNonInlinedSFcns(rtm, val) ((rtm)->NonInlinedSFcns = (val))\r\n#endif\r\n\r\n#ifndef rtmGetNumBlockIO\r\n#define rtmGetNumBlockIO(rtm)          ((rtm)->Sizes.numBlockIO)\r\n#endif\r\n\r\n#ifndef rtmSetNumBlockIO\r\n#define rtmSetNumBlockIO(rtm, val)     ((rtm)->Sizes.numBlockIO = (val))\r\n#endif\r\n\r\n#ifndef rtmGetNumBlockParams\r\n#define rtmGetNumBlockParams(rtm)      ((rtm)->Sizes.numBlockPrms)\r\n#endif\r\n\r\n#ifndef rtmSetNumBlockParams\r\n#define rtmSetNumBlockParams(rtm, val) ((rtm)->Sizes.numBlockPrms = (val))\r\n#endif\r\n\r\n#ifndef rtmGetNumBlocks\r\n#define rtmGetNumBlocks(rtm)           ((rtm)->Sizes.numBlocks)\r\n#endif\r\n\r\n#ifndef rtmSetNumBlocks\r\n#define rtmSetNumBlocks(rtm, val)      ((rtm)->Sizes.numBlocks = (val))\r\n#endif\r\n\r\n#ifndef rtmGetNumContStates\r\n#define rtmGetNumContStates(rtm)       ((rtm)->Sizes.numContStates)\r\n#endif\r\n\r\n#ifndef rtmSetNumContStates\r\n#define rtmSetNumContStates(rtm, val)  ((rtm)->Sizes.numContStates = (val))\r\n#endif\r\n\r\n#ifndef rtmGetNumDWork\r\n#define rtmGetNumDWork(rtm)            ((rtm)->Sizes.numDwork)\r\n#endif\r\n\r\n#ifndef rtmSetNumDWork\r\n#define rtmSetNumDWork(rtm, val)       ((rtm)->Sizes.numDwork = (val))\r\n#endif\r\n\r\n#ifndef rtmGetNumInputPorts\r\n#define rtmGetNumInputPorts(rtm)       ((rtm)->Sizes.numIports)\r\n#endif\r\n\r\n#ifndef rtmSetNumInputPorts\r\n#define rtmSetNumInputPorts(rtm, val)  ((rtm)->Sizes.numIports = (val))\r\n#endif\r\n\r\n#ifndef rtmGetNumNonSampledZCs\r\n#define rtmGetNumNonSampledZCs(rtm)    ((rtm)->Sizes.numNonSampZCs)\r\n#endif\r\n\r\n#ifndef rtmSetNumNonSampledZCs\r\n#define rtmSetNumNonSampledZCs(rtm, val) ((rtm)->Sizes.numNonSampZCs = (val))\r\n#endif\r\n\r\n#ifndef rtmGetNumOutputPorts\r\n#define rtmGetNumOutputPorts(rtm)      ((rtm)->Sizes.numOports)\r\n#endif\r\n\r\n#ifndef rtmSetNumOutputPorts\r\n#define rtmSetNumOutputPorts(rtm, val) ((rtm)->Sizes.numOports = (val))\r\n#endif\r\n\r\n#ifndef rtmGetNumPeriodicContStates\r\n#define rtmGetNumPeriodicContStates(rtm) ((rtm)->Sizes.numPeriodicContStates)\r\n#endif\r\n\r\n#ifndef rtmSetNumPeriodicContStates\r\n#define rtmSetNumPeriodicContStates(rtm, val) ((rtm)->Sizes.numPeriodicContStates = (val))\r\n#endif\r\n\r\n#ifndef rtmGetNumSFcnParams\r\n#define rtmGetNumSFcnParams(rtm)       ((rtm)->Sizes.numSFcnPrms)\r\n#endif\r\n\r\n#ifndef rtmSetNumSFcnParams\r\n#define rtmSetNumSFcnParams(rtm, val)  ((rtm)->Sizes.numSFcnPrms = (val))\r\n#endif\r\n\r\n#ifndef rtmGetNumSFunctions\r\n#define rtmGetNumSFunctions(rtm)       ((rtm)->Sizes.numSFcns)\r\n#endif\r\n\r\n#ifndef rtmSetNumSFunctions\r\n#define rtmSetNumSFunctions(rtm, val)  ((rtm)->Sizes.numSFcns = (val))\r\n#endif\r\n\r\n#ifndef rtmGetNumSampleTimes\r\n#define rtmGetNumSampleTimes(rtm)      ((rtm)->Sizes.numSampTimes)\r\n#endif\r\n\r\n#ifndef rtmSetNumSampleTimes\r\n#define rtmSetNumSampleTimes(rtm, val) ((rtm)->Sizes.numSampTimes = (val))\r\n#endif\r\n\r\n#ifndef rtmGetNumU\r\n#define rtmGetNumU(rtm)                ((rtm)->Sizes.numU)\r\n#endif\r\n\r\n#ifndef rtmSetNumU\r\n#define rtmSetNumU(rtm, val)           ((rtm)->Sizes.numU = (val))\r\n#endif\r\n\r\n#ifndef rtmGetNumY\r\n#define rtmGetNumY(rtm)                ((rtm)->Sizes.numY)\r\n#endif\r\n\r\n#ifndef rtmSetNumY\r\n#define rtmSetNumY(rtm, val)           ((rtm)->Sizes.numY = (val))\r\n#endif\r\n\r\n#ifndef rtmGetOdeF\r\n#define rtmGetOdeF(rtm)                ()\r\n#endif\r\n\r\n#ifndef rtmSetOdeF\r\n#define rtmSetOdeF(rtm, val)           ()\r\n#endif\r\n\r\n#ifndef rtmGetOdeY\r\n#define rtmGetOdeY(rtm)                ()\r\n#endif\r\n\r\n#ifndef rtmSetOdeY\r\n#define rtmSetOdeY(rtm, val)           ()\r\n#endif\r\n\r\n#ifndef rtmGetOffsetTimeArray\r\n#define rtmGetOffsetTimeArray(rtm)     ((rtm)->Timing.offsetTimesArray)\r\n#endif\r\n\r\n#ifndef rtmSetOffsetTimeArray\r\n#define rtmSetOffsetTimeArray(rtm, val) ((rtm)->Timing.offsetTimesArray = (val))\r\n#endif\r\n\r\n#ifndef rtmGetOffsetTimePtr\r\n#define rtmGetOffsetTimePtr(rtm)       ((rtm)->Timing.offsetTimes)\r\n#endif\r\n\r\n#ifndef rtmSetOffsetTimePtr\r\n#define rtmSetOffsetTimePtr(rtm, val)  ((rtm)->Timing.offsetTimes = (val))\r\n#endif\r\n\r\n#ifndef rtmGetOptions\r\n#define rtmGetOptions(rtm)             ((rtm)->Sizes.options)\r\n#endif\r\n\r\n#ifndef rtmSetOptions\r\n#define rtmSetOptions(rtm, val)        ((rtm)->Sizes.options = (val))\r\n#endif\r\n\r\n#ifndef rtmGetParamIsMalloced\r\n#define rtmGetParamIsMalloced(rtm)     ()\r\n#endif\r\n\r\n#ifndef rtmSetParamIsMalloced\r\n#define rtmSetParamIsMalloced(rtm, val) ()\r\n#endif\r\n\r\n#ifndef rtmGetPath\r\n#define rtmGetPath(rtm)                ((rtm)->path)\r\n#endif\r\n\r\n#ifndef rtmSetPath\r\n#define rtmSetPath(rtm, val)           ((rtm)->path = (val))\r\n#endif\r\n\r\n#ifndef rtmGetPerTaskSampleHits\r\n#define rtmGetPerTaskSampleHits(rtm)   ()\r\n#endif\r\n\r\n#ifndef rtmSetPerTaskSampleHits\r\n#define rtmSetPerTaskSampleHits(rtm, val) ()\r\n#endif\r\n\r\n#ifndef rtmGetPerTaskSampleHitsArray\r\n#define rtmGetPerTaskSampleHitsArray(rtm) ((rtm)->Timing.perTaskSampleHitsArray)\r\n#endif\r\n\r\n#ifndef rtmSetPerTaskSampleHitsArray\r\n#define rtmSetPerTaskSampleHitsArray(rtm, val) ((rtm)->Timing.perTaskSampleHitsArray = (val))\r\n#endif\r\n\r\n#ifndef rtmGetPerTaskSampleHitsPtr\r\n#define rtmGetPerTaskSampleHitsPtr(rtm) ((rtm)->Timing.perTaskSampleHits)\r\n#endif\r\n\r\n#ifndef rtmSetPerTaskSampleHitsPtr\r\n#define rtmSetPerTaskSampleHitsPtr(rtm, val) ((rtm)->Timing.perTaskSampleHits = (val))\r\n#endif\r\n\r\n#ifndef rtmGetPeriodicContStateIndices\r\n#define rtmGetPeriodicContStateIndices(rtm) ((rtm)->periodicContStateIndices)\r\n#endif\r\n\r\n#ifndef rtmSetPeriodicContStateIndices\r\n#define rtmSetPeriodicContStateIndices(rtm, val) ((rtm)->periodicContStateIndices = (val))\r\n#endif\r\n\r\n#ifndef rtmGetPeriodicContStateRanges\r\n#define rtmGetPeriodicContStateRanges(rtm) ((rtm)->periodicContStateRanges)\r\n#endif\r\n\r\n#ifndef rtmSetPeriodicContStateRanges\r\n#define rtmSetPeriodicContStateRanges(rtm, val) ((rtm)->periodicContStateRanges = (val))\r\n#endif\r\n\r\n#ifndef rtmGetPrevZCSigState\r\n#define rtmGetPrevZCSigState(rtm)      ((rtm)->prevZCSigState)\r\n#endif\r\n\r\n#ifndef rtmSetPrevZCSigState\r\n#define rtmSetPrevZCSigState(rtm, val) ((rtm)->prevZCSigState = (val))\r\n#endif\r\n\r\n#ifndef rtmGetProxyFunctions\r\n#define rtmGetProxyFunctions(rtm)      ()\r\n#endif\r\n\r\n#ifndef rtmSetProxyFunctions\r\n#define rtmSetProxyFunctions(rtm, val) ()\r\n#endif\r\n\r\n#ifndef rtmGetRTWExtModeInfo\r\n#define rtmGetRTWExtModeInfo(rtm)      ((rtm)->extModeInfo)\r\n#endif\r\n\r\n#ifndef rtmSetRTWExtModeInfo\r\n#define rtmSetRTWExtModeInfo(rtm, val) ((rtm)->extModeInfo = (val))\r\n#endif\r\n\r\n#ifndef rtmGetRTWGeneratedSFcn\r\n#define rtmGetRTWGeneratedSFcn(rtm)    ((rtm)->Sizes.rtwGenSfcn)\r\n#endif\r\n\r\n#ifndef rtmSetRTWGeneratedSFcn\r\n#define rtmSetRTWGeneratedSFcn(rtm, val) ((rtm)->Sizes.rtwGenSfcn = (val))\r\n#endif\r\n\r\n#ifndef rtmGetRTWLogInfo\r\n#define rtmGetRTWLogInfo(rtm)          ()\r\n#endif\r\n\r\n#ifndef rtmSetRTWLogInfo\r\n#define rtmSetRTWLogInfo(rtm, val)     ()\r\n#endif\r\n\r\n#ifndef rtmGetRTWRTModelMethodsInfo\r\n#define rtmGetRTWRTModelMethodsInfo(rtm) ()\r\n#endif\r\n\r\n#ifndef rtmSetRTWRTModelMethodsInfo\r\n#define rtmSetRTWRTModelMethodsInfo(rtm, val) ()\r\n#endif\r\n\r\n#ifndef rtmGetRTWSfcnInfo\r\n#define rtmGetRTWSfcnInfo(rtm)         ((rtm)->sfcnInfo)\r\n#endif\r\n\r\n#ifndef rtmSetRTWSfcnInfo\r\n#define rtmSetRTWSfcnInfo(rtm, val)    ((rtm)->sfcnInfo = (val))\r\n#endif\r\n\r\n#ifndef rtmGetRTWSolverInfo\r\n#define rtmGetRTWSolverInfo(rtm)       ((rtm)->solverInfo)\r\n#endif\r\n\r\n#ifndef rtmSetRTWSolverInfo\r\n#define rtmSetRTWSolverInfo(rtm, val)  ((rtm)->solverInfo = (val))\r\n#endif\r\n\r\n#ifndef rtmGetRTWSolverInfoPtr\r\n#define rtmGetRTWSolverInfoPtr(rtm)    ((rtm)->solverInfoPtr)\r\n#endif\r\n\r\n#ifndef rtmSetRTWSolverInfoPtr\r\n#define rtmSetRTWSolverInfoPtr(rtm, val) ((rtm)->solverInfoPtr = (val))\r\n#endif\r\n\r\n#ifndef rtmGetReservedForXPC\r\n#define rtmGetReservedForXPC(rtm)      ((rtm)->SpecialInfo.xpcData)\r\n#endif\r\n\r\n#ifndef rtmSetReservedForXPC\r\n#define rtmSetReservedForXPC(rtm, val) ((rtm)->SpecialInfo.xpcData = (val))\r\n#endif\r\n\r\n#ifndef rtmGetRootDWork\r\n#define rtmGetRootDWork(rtm)           ((rtm)->dwork)\r\n#endif\r\n\r\n#ifndef rtmSetRootDWork\r\n#define rtmSetRootDWork(rtm, val)      ((rtm)->dwork = (val))\r\n#endif\r\n\r\n#ifndef rtmGetSFunctions\r\n#define rtmGetSFunctions(rtm)          ((rtm)->childSfunctions)\r\n#endif\r\n\r\n#ifndef rtmSetSFunctions\r\n#define rtmSetSFunctions(rtm, val)     ((rtm)->childSfunctions = (val))\r\n#endif\r\n\r\n#ifndef rtmGetSampleHitArray\r\n#define rtmGetSampleHitArray(rtm)      ((rtm)->Timing.sampleHitArray)\r\n#endif\r\n\r\n#ifndef rtmSetSampleHitArray\r\n#define rtmSetSampleHitArray(rtm, val) ((rtm)->Timing.sampleHitArray = (val))\r\n#endif\r\n\r\n#ifndef rtmGetSampleHitPtr\r\n#define rtmGetSampleHitPtr(rtm)        ((rtm)->Timing.sampleHits)\r\n#endif\r\n\r\n#ifndef rtmSetSampleHitPtr\r\n#define rtmSetSampleHitPtr(rtm, val)   ((rtm)->Timing.sampleHits = (val))\r\n#endif\r\n\r\n#ifndef rtmGetSampleTimeArray\r\n#define rtmGetSampleTimeArray(rtm)     ((rtm)->Timing.sampleTimesArray)\r\n#endif\r\n\r\n#ifndef rtmSetSampleTimeArray\r\n#define rtmSetSampleTimeArray(rtm, val) ((rtm)->Timing.sampleTimesArray = (val))\r\n#endif\r\n\r\n#ifndef rtmGetSampleTimePtr\r\n#define rtmGetSampleTimePtr(rtm)       ((rtm)->Timing.sampleTimes)\r\n#endif\r\n\r\n#ifndef rtmSetSampleTimePtr\r\n#define rtmSetSampleTimePtr(rtm, val)  ((rtm)->Timing.sampleTimes = (val))\r\n#endif\r\n\r\n#ifndef rtmGetSampleTimeTaskIDArray\r\n#define rtmGetSampleTimeTaskIDArray(rtm) ((rtm)->Timing.sampleTimeTaskIDArray)\r\n#endif\r\n\r\n#ifndef rtmSetSampleTimeTaskIDArray\r\n#define rtmSetSampleTimeTaskIDArray(rtm, val) ((rtm)->Timing.sampleTimeTaskIDArray = (val))\r\n#endif\r\n\r\n#ifndef rtmGetSampleTimeTaskIDPtr\r\n#define rtmGetSampleTimeTaskIDPtr(rtm) ((rtm)->Timing.sampleTimeTaskIDPtr)\r\n#endif\r\n\r\n#ifndef rtmSetSampleTimeTaskIDPtr\r\n#define rtmSetSampleTimeTaskIDPtr(rtm, val) ((rtm)->Timing.sampleTimeTaskIDPtr = (val))\r\n#endif\r\n\r\n#ifndef rtmGetSelf\r\n#define rtmGetSelf(rtm)                ()\r\n#endif\r\n\r\n#ifndef rtmSetSelf\r\n#define rtmSetSelf(rtm, val)           ()\r\n#endif\r\n\r\n#ifndef rtmGetSimMode\r\n#define rtmGetSimMode(rtm)             ((rtm)->simMode)\r\n#endif\r\n\r\n#ifndef rtmSetSimMode\r\n#define rtmSetSimMode(rtm, val)        ((rtm)->simMode = (val))\r\n#endif\r\n\r\n#ifndef rtmGetSimTimeStep\r\n#define rtmGetSimTimeStep(rtm)         ((rtm)->Timing.simTimeStep)\r\n#endif\r\n\r\n#ifndef rtmSetSimTimeStep\r\n#define rtmSetSimTimeStep(rtm, val)    ((rtm)->Timing.simTimeStep = (val))\r\n#endif\r\n\r\n#ifndef rtmGetStartTime\r\n#define rtmGetStartTime(rtm)           ((rtm)->Timing.tStart)\r\n#endif\r\n\r\n#ifndef rtmSetStartTime\r\n#define rtmSetStartTime(rtm, val)      ((rtm)->Timing.tStart = (val))\r\n#endif\r\n\r\n#ifndef rtmGetStepSize\r\n#define rtmGetStepSize(rtm)            ((rtm)->Timing.stepSize)\r\n#endif\r\n\r\n#ifndef rtmSetStepSize\r\n#define rtmSetStepSize(rtm, val)       ((rtm)->Timing.stepSize = (val))\r\n#endif\r\n\r\n#ifndef rtmGetStopRequestedFlag\r\n#define rtmGetStopRequestedFlag(rtm)   ((rtm)->Timing.stopRequestedFlag)\r\n#endif\r\n\r\n#ifndef rtmSetStopRequestedFlag\r\n#define rtmSetStopRequestedFlag(rtm, val) ((rtm)->Timing.stopRequestedFlag = (val))\r\n#endif\r\n\r\n#ifndef rtmGetStubFunctions\r\n#define rtmGetStubFunctions(rtm)       ()\r\n#endif\r\n\r\n#ifndef rtmSetStubFunctions\r\n#define rtmSetStubFunctions(rtm, val)  ()\r\n#endif\r\n\r\n#ifndef rtmGetTaskCounters\r\n#define rtmGetTaskCounters(rtm)        ()\r\n#endif\r\n\r\n#ifndef rtmSetTaskCounters\r\n#define rtmSetTaskCounters(rtm, val)   ()\r\n#endif\r\n\r\n#ifndef rtmGetTaskTimeArray\r\n#define rtmGetTaskTimeArray(rtm)       ((rtm)->Timing.tArray)\r\n#endif\r\n\r\n#ifndef rtmSetTaskTimeArray\r\n#define rtmSetTaskTimeArray(rtm, val)  ((rtm)->Timing.tArray = (val))\r\n#endif\r\n\r\n#ifndef rtmGetTimePtr\r\n#define rtmGetTimePtr(rtm)             ((rtm)->Timing.t)\r\n#endif\r\n\r\n#ifndef rtmSetTimePtr\r\n#define rtmSetTimePtr(rtm, val)        ((rtm)->Timing.t = (val))\r\n#endif\r\n\r\n#ifndef rtmGetTimingData\r\n#define rtmGetTimingData(rtm)          ((rtm)->Timing.timingData)\r\n#endif\r\n\r\n#ifndef rtmSetTimingData\r\n#define rtmSetTimingData(rtm, val)     ((rtm)->Timing.timingData = (val))\r\n#endif\r\n\r\n#ifndef rtmGetU\r\n#define rtmGetU(rtm)                   ((rtm)->inputs)\r\n#endif\r\n\r\n#ifndef rtmSetU\r\n#define rtmSetU(rtm, val)              ((rtm)->inputs = (val))\r\n#endif\r\n\r\n#ifndef rtmGetVarNextHitTimesListPtr\r\n#define rtmGetVarNextHitTimesListPtr(rtm) ((rtm)->Timing.varNextHitTimesList)\r\n#endif\r\n\r\n#ifndef rtmSetVarNextHitTimesListPtr\r\n#define rtmSetVarNextHitTimesListPtr(rtm, val) ((rtm)->Timing.varNextHitTimesList = (val))\r\n#endif\r\n\r\n#ifndef rtmGetY\r\n#define rtmGetY(rtm)                   ((rtm)->outputs)\r\n#endif\r\n\r\n#ifndef rtmSetY\r\n#define rtmSetY(rtm, val)              ((rtm)->outputs = (val))\r\n#endif\r\n\r\n#ifndef rtmGetZCCacheNeedsReset\r\n#define rtmGetZCCacheNeedsReset(rtm)   ((rtm)->zCCacheNeedsReset)\r\n#endif\r\n\r\n#ifndef rtmSetZCCacheNeedsReset\r\n#define rtmSetZCCacheNeedsReset(rtm, val) ((rtm)->zCCacheNeedsReset = (val))\r\n#endif\r\n\r\n#ifndef rtmGetZCSignalValues\r\n#define rtmGetZCSignalValues(rtm)      ((rtm)->zcSignalValues)\r\n#endif\r\n\r\n#ifndef rtmSetZCSignalValues\r\n#define rtmSetZCSignalValues(rtm, val) ((rtm)->zcSignalValues = (val))\r\n#endif\r\n\r\n#ifndef rtmGet_TimeOfLastOutput\r\n#define rtmGet_TimeOfLastOutput(rtm)   ((rtm)->Timing.timeOfLastOutput)\r\n#endif\r\n\r\n#ifndef rtmSet_TimeOfLastOutput\r\n#define rtmSet_TimeOfLastOutput(rtm, val) ((rtm)->Timing.timeOfLastOutput = (val))\r\n#endif\r\n\r\n#ifndef rtmGetdX\r\n#define rtmGetdX(rtm)                  ((rtm)->derivs)\r\n#endif\r\n\r\n#ifndef rtmSetdX\r\n#define rtmSetdX(rtm, val)             ((rtm)->derivs = (val))\r\n#endif\r\n\r\n#ifndef rtmGettimingBridge\r\n#define rtmGettimingBridge(rtm)        ()\r\n#endif\r\n\r\n#ifndef rtmSettimingBridge\r\n#define rtmSettimingBridge(rtm, val)   ()\r\n#endif\r\n\r\n#ifndef rtmGetChecksumVal\r\n#define rtmGetChecksumVal(rtm, idx)    ((rtm)->Sizes.checksums[idx])\r\n#endif\r\n\r\n#ifndef rtmSetChecksumVal\r\n#define rtmSetChecksumVal(rtm, idx, val) ((rtm)->Sizes.checksums[idx] = (val))\r\n#endif\r\n\r\n#ifndef rtmGetDWork\r\n#define rtmGetDWork(rtm, idx)          ((rtm)->dwork[idx])\r\n#endif\r\n\r\n#ifndef rtmSetDWork\r\n#define rtmSetDWork(rtm, idx, val)     ((rtm)->dwork[idx] = (val))\r\n#endif\r\n\r\n#ifndef rtmGetOffsetTime\r\n#define rtmGetOffsetTime(rtm, idx)     ((rtm)->Timing.offsetTimes[idx])\r\n#endif\r\n\r\n#ifndef rtmSetOffsetTime\r\n#define rtmSetOffsetTime(rtm, idx, val) ((rtm)->Timing.offsetTimes[idx] = (val))\r\n#endif\r\n\r\n#ifndef rtmGetSFunction\r\n#define rtmGetSFunction(rtm, idx)      ((rtm)->childSfunctions[idx])\r\n#endif\r\n\r\n#ifndef rtmSetSFunction\r\n#define rtmSetSFunction(rtm, idx, val) ((rtm)->childSfunctions[idx] = (val))\r\n#endif\r\n\r\n#ifndef rtmGetSampleTime\r\n#define rtmGetSampleTime(rtm, idx)     ((rtm)->Timing.sampleTimes[idx])\r\n#endif\r\n\r\n#ifndef rtmSetSampleTime\r\n#define rtmSetSampleTime(rtm, idx, val) ((rtm)->Timing.sampleTimes[idx] = (val))\r\n#endif\r\n\r\n#ifndef rtmGetSampleTimeTaskID\r\n#define rtmGetSampleTimeTaskID(rtm, idx) ((rtm)->Timing.sampleTimeTaskIDPtr[idx])\r\n#endif\r\n\r\n#ifndef rtmSetSampleTimeTaskID\r\n#define rtmSetSampleTimeTaskID(rtm, idx, val) ((rtm)->Timing.sampleTimeTaskIDPtr[idx] = (val))\r\n#endif\r\n\r\n#ifndef rtmGetVarNextHitTimeList\r\n#define rtmGetVarNextHitTimeList(rtm, idx) ((rtm)->Timing.varNextHitTimesList[idx])\r\n#endif\r\n\r\n#ifndef rtmSetVarNextHitTimeList\r\n#define rtmSetVarNextHitTimeList(rtm, idx, val) ((rtm)->Timing.varNextHitTimesList[idx] = (val))\r\n#endif\r\n\r\n#ifndef rtmIsContinuousTask\r\n#define rtmIsContinuousTask(rtm, tid)  0\r\n#endif\r\n\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n#ifndef rtmIsSampleHit\r\n#define rtmIsSampleHit(rtm, sti, tid)  ((rtm)->Timing.sampleHits[(rtm)->Timing.sampleTimeTaskIDPtr[sti]])\r\n#endif\r\n\r\n#ifndef rtmGetStopRequested\r\n#define rtmGetStopRequested(rtm)       ((rtm)->Timing.stopRequestedFlag)\r\n#endif\r\n\r\n#ifndef rtmSetStopRequested\r\n#define rtmSetStopRequested(rtm, val)  ((rtm)->Timing.stopRequestedFlag = (val))\r\n#endif\r\n\r\n#ifndef rtmGetStopRequestedPtr\r\n#define rtmGetStopRequestedPtr(rtm)    (&((rtm)->Timing.stopRequestedFlag))\r\n#endif\r\n\r\n#ifndef rtmGetT\r\n#define rtmGetT(rtm)                   (rtmGetTPtr((rtm))[0])\r\n#endif\r\n\r\n#ifndef rtmSetT\r\n#define rtmSetT(rtm, val)                                        /* Do Nothing */\r\n#endif\r\n\r\n#ifndef rtmGetTFinal\r\n#define rtmGetTFinal(rtm)              ((rtm)->Timing.tFinal)\r\n#endif\r\n\r\n#ifndef rtmSetTFinal\r\n#define rtmSetTFinal(rtm, val)         ((rtm)->Timing.tFinal = (val))\r\n#endif\r\n\r\n#ifndef rtmGetTPtr\r\n#define rtmGetTPtr(rtm)                ((rtm)->Timing.t)\r\n#endif\r\n\r\n#ifndef rtmSetTPtr\r\n#define rtmSetTPtr(rtm, val)           ((rtm)->Timing.t = (val))\r\n#endif\r\n\r\n#ifndef rtmGetTStart\r\n#define rtmGetTStart(rtm)              ((rtm)->Timing.tStart)\r\n#endif\r\n\r\n#ifndef rtmSetTStart\r\n#define rtmSetTStart(rtm, val)         ((rtm)->Timing.tStart = (val))\r\n#endif\r\n\r\n#ifndef rtmGetTaskTime\r\n#define rtmGetTaskTime(rtm, sti)       (rtmGetTPtr((rtm))[(rtm)->Timing.sampleTimeTaskIDPtr[sti]])\r\n#endif\r\n\r\n#ifndef rtmSetTaskTime\r\n#define rtmSetTaskTime(rtm, sti, val)  (rtmGetTPtr((rtm))[sti] = (val))\r\n#endif\r\n\r\n#ifndef rtmGetTimeOfLastOutput\r\n#define rtmGetTimeOfLastOutput(rtm)    ((rtm)->Timing.timeOfLastOutput)\r\n#endif\r\n\r\n#ifdef rtmGetRTWSolverInfo\r\n#undef rtmGetRTWSolverInfo\r\n#endif\r\n\r\n#define rtmGetRTWSolverInfo(rtm)       &((rtm)->solverInfo)\r\n\r\n/* Definition for use in the target main file */\r\n#define test_normal_sim_rtModel        RT_MODEL_test_normal_sim_T\r\n\r\n/* Block signals (default storage) */\r\ntypedef struct {\r\n  real_T TmpSignalConversionAtSFunctionI[2];\r\n  real_T TmpSignalConversionAtSFunctio_j[12];\r\n  real_T SFunction;                    /* '<Root>/S-Function' */\r\n} B_test_normal_sim_T;\r\n\r\n/* Block states (default storage) for system '<Root>' */\r\ntypedef struct {\r\n  real_T HILInitialize_FilterFrequency[2];/* '<Root>/HIL Initialize' */\r\n  t_card HILInitialize_Card;           /* '<Root>/HIL Initialize' */\r\n  real_T SFunction_RWORK[980];         /* '<Root>/S-Function' */\r\n  void *SFunction_PWORK[55];           /* '<Root>/S-Function' */\r\n  int32_T HILInitialize_ClockModes;    /* '<Root>/HIL Initialize' */\r\n  int32_T HILInitialize_DOStates;      /* '<Root>/HIL Initialize' */\r\n  int32_T HILInitialize_QuadratureModes[2];/* '<Root>/HIL Initialize' */\r\n  int32_T HILInitialize_InitialEICounts[2];/* '<Root>/HIL Initialize' */\r\n  int_T SFunction_IWORK[18];           /* '<Root>/S-Function' */\r\n} DW_test_normal_sim_T;\r\n\r\n/* Backward compatible GRT Identifiers */\r\n#define rtB                            test_normal_sim_B\r\n#define BlockIO                        B_test_normal_sim_T\r\n#define rtP                            test_normal_sim_P\r\n#define Parameters                     P_test_normal_sim_T\r\n#define rtDWork                        test_normal_sim_DW\r\n#define D_Work                         DW_test_normal_sim_T\r\n\r\n/* Parameters (default storage) */\r\nstruct P_test_normal_sim_T_ {\r\n  real_T HILInitialize_OOTerminate;/* Expression: set_other_outputs_at_terminate\r\n                                    * Referenced by: '<Root>/HIL Initialize'\r\n                                    */\r\n  real_T HILInitialize_OOExit;    /* Expression: set_other_outputs_at_switch_out\r\n                                   * Referenced by: '<Root>/HIL Initialize'\r\n                                   */\r\n  real_T HILInitialize_OOStart;        /* Expression: set_other_outputs_at_start\r\n                                        * Referenced by: '<Root>/HIL Initialize'\r\n                                        */\r\n  real_T HILInitialize_OOEnter;    /* Expression: set_other_outputs_at_switch_in\r\n                                    * Referenced by: '<Root>/HIL Initialize'\r\n                                    */\r\n  real_T HILInitialize_AOFinal;        /* Expression: final_analog_outputs\r\n                                        * Referenced by: '<Root>/HIL Initialize'\r\n                                        */\r\n  real_T HILInitialize_POFinal;        /* Expression: final_pwm_outputs\r\n                                        * Referenced by: '<Root>/HIL Initialize'\r\n                                        */\r\n  real_T HILInitialize_OOFinal[3];     /* Expression: final_other_outputs\r\n                                        * Referenced by: '<Root>/HIL Initialize'\r\n                                        */\r\n  real_T HILInitialize_AIHigh;         /* Expression: analog_input_maximums\r\n                                        * Referenced by: '<Root>/HIL Initialize'\r\n                                        */\r\n  real_T HILInitialize_AILow;          /* Expression: analog_input_minimums\r\n                                        * Referenced by: '<Root>/HIL Initialize'\r\n                                        */\r\n  real_T HILInitialize_AOHigh;         /* Expression: analog_output_maximums\r\n                                        * Referenced by: '<Root>/HIL Initialize'\r\n                                        */\r\n  real_T HILInitialize_AOLow;          /* Expression: analog_output_minimums\r\n                                        * Referenced by: '<Root>/HIL Initialize'\r\n                                        */\r\n  real_T HILInitialize_AOInitial;      /* Expression: initial_analog_outputs\r\n                                        * Referenced by: '<Root>/HIL Initialize'\r\n                                        */\r\n  real_T HILInitialize_AOWatchdog;     /* Expression: watchdog_analog_outputs\r\n                                        * Referenced by: '<Root>/HIL Initialize'\r\n                                        */\r\n  real_T HILInitialize_POFrequency;    /* Expression: pwm_frequency\r\n                                        * Referenced by: '<Root>/HIL Initialize'\r\n                                        */\r\n  real_T HILInitialize_POLeading;      /* Expression: pwm_leading_deadband\r\n                                        * Referenced by: '<Root>/HIL Initialize'\r\n                                        */\r\n  real_T HILInitialize_POTrailing;     /* Expression: pwm_trailing_deadband\r\n                                        * Referenced by: '<Root>/HIL Initialize'\r\n                                        */\r\n  real_T HILInitialize_POInitial;      /* Expression: initial_pwm_outputs\r\n                                        * Referenced by: '<Root>/HIL Initialize'\r\n                                        */\r\n  real_T HILInitialize_OOInitial[3];   /* Expression: initial_other_outputs\r\n                                        * Referenced by: '<Root>/HIL Initialize'\r\n                                        */\r\n  real_T HILInitialize_OOWatchdog[3];  /* Expression: watchdog_other_outputs\r\n                                        * Referenced by: '<Root>/HIL Initialize'\r\n                                        */\r\n  int32_T HILInitialize_CKChannels;\r\n                                 /* Computed Parameter: HILInitialize_CKChannels\r\n                                  * Referenced by: '<Root>/HIL Initialize'\r\n                                  */\r\n  int32_T HILInitialize_DOWatchdog;\r\n                                 /* Computed Parameter: HILInitialize_DOWatchdog\r\n                                  * Referenced by: '<Root>/HIL Initialize'\r\n                                  */\r\n  int32_T HILInitialize_EIInitial;/* Computed Parameter: HILInitialize_EIInitial\r\n                                   * Referenced by: '<Root>/HIL Initialize'\r\n                                   */\r\n  int32_T HILInitialize_POModes;    /* Computed Parameter: HILInitialize_POModes\r\n                                     * Referenced by: '<Root>/HIL Initialize'\r\n                                     */\r\n  int32_T HILInitialize_POConfiguration;\r\n                            /* Computed Parameter: HILInitialize_POConfiguration\r\n                             * Referenced by: '<Root>/HIL Initialize'\r\n                             */\r\n  int32_T HILInitialize_POAlignment;\r\n                                /* Computed Parameter: HILInitialize_POAlignment\r\n                                 * Referenced by: '<Root>/HIL Initialize'\r\n                                 */\r\n  int32_T HILInitialize_POPolarity;\r\n                                 /* Computed Parameter: HILInitialize_POPolarity\r\n                                  * Referenced by: '<Root>/HIL Initialize'\r\n                                  */\r\n  uint32_T HILInitialize_AIChannels;\r\n                                 /* Computed Parameter: HILInitialize_AIChannels\r\n                                  * Referenced by: '<Root>/HIL Initialize'\r\n                                  */\r\n  uint32_T HILInitialize_AOChannels;\r\n                                 /* Computed Parameter: HILInitialize_AOChannels\r\n                                  * Referenced by: '<Root>/HIL Initialize'\r\n                                  */\r\n  uint32_T HILInitialize_DOChannels;\r\n                                 /* Computed Parameter: HILInitialize_DOChannels\r\n                                  * Referenced by: '<Root>/HIL Initialize'\r\n                                  */\r\n  uint32_T HILInitialize_EIChannels[2];\r\n                                 /* Computed Parameter: HILInitialize_EIChannels\r\n                                  * Referenced by: '<Root>/HIL Initialize'\r\n                                  */\r\n  uint32_T HILInitialize_EIQuadrature;\r\n                               /* Computed Parameter: HILInitialize_EIQuadrature\r\n                                * Referenced by: '<Root>/HIL Initialize'\r\n                                */\r\n  uint32_T HILInitialize_OOChannels[3];\r\n                                 /* Computed Parameter: HILInitialize_OOChannels\r\n                                  * Referenced by: '<Root>/HIL Initialize'\r\n                                  */\r\n  boolean_T HILInitialize_Active;    /* Computed Parameter: HILInitialize_Active\r\n                                      * Referenced by: '<Root>/HIL Initialize'\r\n                                      */\r\n  boolean_T HILInitialize_AOTerminate;\r\n                                /* Computed Parameter: HILInitialize_AOTerminate\r\n                                 * Referenced by: '<Root>/HIL Initialize'\r\n                                 */\r\n  boolean_T HILInitialize_AOExit;    /* Computed Parameter: HILInitialize_AOExit\r\n                                      * Referenced by: '<Root>/HIL Initialize'\r\n                                      */\r\n  boolean_T HILInitialize_DOTerminate;\r\n                                /* Computed Parameter: HILInitialize_DOTerminate\r\n                                 * Referenced by: '<Root>/HIL Initialize'\r\n                                 */\r\n  boolean_T HILInitialize_DOExit;    /* Computed Parameter: HILInitialize_DOExit\r\n                                      * Referenced by: '<Root>/HIL Initialize'\r\n                                      */\r\n  boolean_T HILInitialize_POTerminate;\r\n                                /* Computed Parameter: HILInitialize_POTerminate\r\n                                 * Referenced by: '<Root>/HIL Initialize'\r\n                                 */\r\n  boolean_T HILInitialize_POExit;    /* Computed Parameter: HILInitialize_POExit\r\n                                      * Referenced by: '<Root>/HIL Initialize'\r\n                                      */\r\n  boolean_T HILInitialize_CKPStart;/* Computed Parameter: HILInitialize_CKPStart\r\n                                    * Referenced by: '<Root>/HIL Initialize'\r\n                                    */\r\n  boolean_T HILInitialize_CKPEnter;/* Computed Parameter: HILInitialize_CKPEnter\r\n                                    * Referenced by: '<Root>/HIL Initialize'\r\n                                    */\r\n  boolean_T HILInitialize_CKStart;  /* Computed Parameter: HILInitialize_CKStart\r\n                                     * Referenced by: '<Root>/HIL Initialize'\r\n                                     */\r\n  boolean_T HILInitialize_CKEnter;  /* Computed Parameter: HILInitialize_CKEnter\r\n                                     * Referenced by: '<Root>/HIL Initialize'\r\n                                     */\r\n  boolean_T HILInitialize_AIPStart;/* Computed Parameter: HILInitialize_AIPStart\r\n                                    * Referenced by: '<Root>/HIL Initialize'\r\n                                    */\r\n  boolean_T HILInitialize_AIPEnter;/* Computed Parameter: HILInitialize_AIPEnter\r\n                                    * Referenced by: '<Root>/HIL Initialize'\r\n                                    */\r\n  boolean_T HILInitialize_AOPStart;/* Computed Parameter: HILInitialize_AOPStart\r\n                                    * Referenced by: '<Root>/HIL Initialize'\r\n                                    */\r\n  boolean_T HILInitialize_AOPEnter;/* Computed Parameter: HILInitialize_AOPEnter\r\n                                    * Referenced by: '<Root>/HIL Initialize'\r\n                                    */\r\n  boolean_T HILInitialize_AOStart;  /* Computed Parameter: HILInitialize_AOStart\r\n                                     * Referenced by: '<Root>/HIL Initialize'\r\n                                     */\r\n  boolean_T HILInitialize_AOEnter;  /* Computed Parameter: HILInitialize_AOEnter\r\n                                     * Referenced by: '<Root>/HIL Initialize'\r\n                                     */\r\n  boolean_T HILInitialize_AOReset;  /* Computed Parameter: HILInitialize_AOReset\r\n                                     * Referenced by: '<Root>/HIL Initialize'\r\n                                     */\r\n  boolean_T HILInitialize_DOPStart;/* Computed Parameter: HILInitialize_DOPStart\r\n                                    * Referenced by: '<Root>/HIL Initialize'\r\n                                    */\r\n  boolean_T HILInitialize_DOPEnter;/* Computed Parameter: HILInitialize_DOPEnter\r\n                                    * Referenced by: '<Root>/HIL Initialize'\r\n                                    */\r\n  boolean_T HILInitialize_DOStart;  /* Computed Parameter: HILInitialize_DOStart\r\n                                     * Referenced by: '<Root>/HIL Initialize'\r\n                                     */\r\n  boolean_T HILInitialize_DOEnter;  /* Computed Parameter: HILInitialize_DOEnter\r\n                                     * Referenced by: '<Root>/HIL Initialize'\r\n                                     */\r\n  boolean_T HILInitialize_DOReset;  /* Computed Parameter: HILInitialize_DOReset\r\n                                     * Referenced by: '<Root>/HIL Initialize'\r\n                                     */\r\n  boolean_T HILInitialize_EIPStart;/* Computed Parameter: HILInitialize_EIPStart\r\n                                    * Referenced by: '<Root>/HIL Initialize'\r\n                                    */\r\n  boolean_T HILInitialize_EIPEnter;/* Computed Parameter: HILInitialize_EIPEnter\r\n                                    * Referenced by: '<Root>/HIL Initialize'\r\n                                    */\r\n  boolean_T HILInitialize_EIStart;  /* Computed Parameter: HILInitialize_EIStart\r\n                                     * Referenced by: '<Root>/HIL Initialize'\r\n                                     */\r\n  boolean_T HILInitialize_EIEnter;  /* Computed Parameter: HILInitialize_EIEnter\r\n                                     * Referenced by: '<Root>/HIL Initialize'\r\n                                     */\r\n  boolean_T HILInitialize_POPStart;/* Computed Parameter: HILInitialize_POPStart\r\n                                    * Referenced by: '<Root>/HIL Initialize'\r\n                                    */\r\n  boolean_T HILInitialize_POPEnter;/* Computed Parameter: HILInitialize_POPEnter\r\n                                    * Referenced by: '<Root>/HIL Initialize'\r\n                                    */\r\n  boolean_T HILInitialize_POStart;  /* Computed Parameter: HILInitialize_POStart\r\n                                     * Referenced by: '<Root>/HIL Initialize'\r\n                                     */\r\n  boolean_T HILInitialize_POEnter;  /* Computed Parameter: HILInitialize_POEnter\r\n                                     * Referenced by: '<Root>/HIL Initialize'\r\n                                     */\r\n  boolean_T HILInitialize_POReset;  /* Computed Parameter: HILInitialize_POReset\r\n                                     * Referenced by: '<Root>/HIL Initialize'\r\n                                     */\r\n  boolean_T HILInitialize_OOReset;  /* Computed Parameter: HILInitialize_OOReset\r\n                                     * Referenced by: '<Root>/HIL Initialize'\r\n                                     */\r\n  boolean_T HILInitialize_DOFinal;  /* Computed Parameter: HILInitialize_DOFinal\r\n                                     * Referenced by: '<Root>/HIL Initialize'\r\n                                     */\r\n  boolean_T HILInitialize_DOInitial;\r\n                                  /* Computed Parameter: HILInitialize_DOInitial\r\n                                   * Referenced by: '<Root>/HIL Initialize'\r\n                                   */\r\n};\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM_test_normal_sim_T {\r\n  const char_T *path;\r\n  const char_T *modelName;\r\n  struct SimStruct_tag * *childSfunctions;\r\n  const char_T *errorStatus;\r\n  SS_SimMode simMode;\r\n  RTWExtModeInfo *extModeInfo;\r\n  RTWSolverInfo solverInfo;\r\n  RTWSolverInfo *solverInfoPtr;\r\n  void *sfcnInfo;\r\n\r\n  /*\r\n   * NonInlinedSFcns:\r\n   * The following substructure contains information regarding\r\n   * non-inlined s-functions used in the model.\r\n   */\r\n  struct {\r\n    RTWSfcnInfo sfcnInfo;\r\n    time_T *taskTimePtrs[1];\r\n    SimStruct childSFunctions[1];\r\n    SimStruct *childSFunctionPtrs[1];\r\n    struct _ssBlkInfo2 blkInfo2[1];\r\n    struct _ssSFcnModelMethods2 methods2[1];\r\n    struct _ssSFcnModelMethods3 methods3[1];\r\n    struct _ssSFcnModelMethods4 methods4[1];\r\n    struct _ssStatesInfo2 statesInfo2[1];\r\n    ssPeriodicStatesInfo periodicStatesInfo[1];\r\n    struct _ssPortInfo2 inputOutputPortInfo2[1];\r\n    struct {\r\n      time_T sfcnPeriod[1];\r\n      time_T sfcnOffset[1];\r\n      int_T sfcnTsMap[1];\r\n      struct _ssPortInputs inputPortInfo[2];\r\n      struct _ssInPortUnit inputPortUnits[2];\r\n      struct _ssInPortCoSimAttribute inputPortCoSimAttribute[2];\r\n      int_T iDims0[2];\r\n      int_T iDims1[2];\r\n      struct _ssPortOutputs outputPortInfo[1];\r\n      struct _ssOutPortUnit outputPortUnits[1];\r\n      struct _ssOutPortCoSimAttribute outputPortCoSimAttribute[1];\r\n      int_T oDims0[2];\r\n      struct _ssDWorkRecord dWork[3];\r\n      struct _ssDWorkAuxRecord dWorkAux[3];\r\n    } Sfcn0;\r\n  } NonInlinedSFcns;\r\n\r\n  void *blockIO;\r\n  const void *constBlockIO;\r\n  void *defaultParam;\r\n  ZCSigState *prevZCSigState;\r\n  real_T *contStates;\r\n  int_T *periodicContStateIndices;\r\n  real_T *periodicContStateRanges;\r\n  real_T *derivs;\r\n  void *zcSignalValues;\r\n  void *inputs;\r\n  void *outputs;\r\n  boolean_T *contStateDisabled;\r\n  boolean_T zCCacheNeedsReset;\r\n  boolean_T derivCacheNeedsReset;\r\n  boolean_T CTOutputIncnstWithState;\r\n  void *dwork;\r\n\r\n  /*\r\n   * Sizes:\r\n   * The following substructure contains sizes information\r\n   * for many of the model attributes such as inputs, outputs,\r\n   * dwork, sample times, etc.\r\n   */\r\n  struct {\r\n    uint32_T checksums[4];\r\n    uint32_T options;\r\n    int_T numContStates;\r\n    int_T numPeriodicContStates;\r\n    int_T numU;\r\n    int_T numY;\r\n    int_T numSampTimes;\r\n    int_T numBlocks;\r\n    int_T numBlockIO;\r\n    int_T numBlockPrms;\r\n    int_T numDwork;\r\n    int_T numSFcnPrms;\r\n    int_T numSFcns;\r\n    int_T numIports;\r\n    int_T numOports;\r\n    int_T numNonSampZCs;\r\n    int_T sysDirFeedThru;\r\n    int_T rtwGenSfcn;\r\n  } Sizes;\r\n\r\n  /*\r\n   * SpecialInfo:\r\n   * The following substructure contains special information\r\n   * related to other components that are dependent on RTW.\r\n   */\r\n  struct {\r\n    const void *mappingInfo;\r\n    void *xpcData;\r\n  } SpecialInfo;\r\n\r\n  /*\r\n   * Timing:\r\n   * The following substructure contains information regarding\r\n   * the timing information for the model.\r\n   */\r\n  struct {\r\n    time_T stepSize;\r\n    uint32_T clockTick0;\r\n    uint32_T clockTickH0;\r\n    time_T stepSize0;\r\n    time_T tStart;\r\n    time_T tFinal;\r\n    time_T timeOfLastOutput;\r\n    void *timingData;\r\n    real_T *varNextHitTimesList;\r\n    SimTimeStep simTimeStep;\r\n    boolean_T stopRequestedFlag;\r\n    time_T *sampleTimes;\r\n    time_T *offsetTimes;\r\n    int_T *sampleTimeTaskIDPtr;\r\n    int_T *sampleHits;\r\n    int_T *perTaskSampleHits;\r\n    time_T *t;\r\n    time_T sampleTimesArray[1];\r\n    time_T offsetTimesArray[1];\r\n    int_T sampleTimeTaskIDArray[1];\r\n    int_T sampleHitArray[1];\r\n    int_T perTaskSampleHitsArray[1];\r\n    time_T tArray[1];\r\n  } Timing;\r\n};\r\n\r\n/* Block parameters (default storage) */\r\nextern P_test_normal_sim_T test_normal_sim_P;\r\n\r\n/* Block signals (default storage) */\r\nextern B_test_normal_sim_T test_normal_sim_B;\r\n\r\n/* Block states (default storage) */\r\nextern DW_test_normal_sim_T test_normal_sim_DW;\r\n\r\n/* Model entry point functions */\r\nextern void test_normal_sim_initialize(void);\r\nextern void test_normal_sim_output(void);\r\nextern void test_normal_sim_update(void);\r\nextern void test_normal_sim_terminate(void);\r\n\r\n/*====================*\r\n * External functions *\r\n *====================*/\r\nextern test_normal_sim_rtModel *test_normal_sim(void);\r\nextern void MdlInitializeSizes(void);\r\nextern void MdlInitializeSampleTimes(void);\r\nextern void MdlInitialize(void);\r\nextern void MdlStart(void);\r\nextern void MdlOutputs(int_T tid);\r\nextern void MdlUpdate(int_T tid);\r\nextern void MdlTerminate(void);\r\n\r\n/* Real-time Model object */\r\nextern RT_MODEL_test_normal_sim_T *const test_normal_sim_M;\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'test_normal_sim'\r\n * '<S1>'   : 'test_normal_sim/Powered by QUARC'\r\n * '<S2>'   : 'test_normal_sim/Quanser'\r\n */\r\n#endif                                 /* test_normal_sim_h_ */\r\n"},{"name":"test_normal_sim_private.h","type":"header","group":"model","path":"C:\\Users\\khanh\\dev\\python\\projects\\casadi_codegen\\approaches\\01\\test_normal_sim_quarc_win64","tag":"","groupDisplay":"Model files","code":"/*\r\n * test_normal_sim_private.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"test_normal_sim\".\r\n *\r\n * Model version              : 19.0\r\n * Simulink Coder version : 25.1 (R2025a) 21-Nov-2024\r\n * C source code generated on : Fri Sep 12 15:50:10 2025\r\n *\r\n * Target selection: quarc_win64.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef test_normal_sim_private_h_\r\n#define test_normal_sim_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"multiword_types.h\"\r\n#include \"zero_crossing_types.h\"\r\n#include \"test_normal_sim_types.h\"\r\n#include \"test_normal_sim.h\"\r\n\r\n/* A global buffer for storing error messages (defined in quanser_common library) */\r\nEXTERN char _rt_error_message[512];\r\nextern void solver_01_wrapper(SimStruct *rts);\r\n\r\n#endif                                 /* test_normal_sim_private_h_ */\r\n"},{"name":"test_normal_sim_types.h","type":"header","group":"model","path":"C:\\Users\\khanh\\dev\\python\\projects\\casadi_codegen\\approaches\\01\\test_normal_sim_quarc_win64","tag":"","groupDisplay":"Model files","code":"/*\r\n * test_normal_sim_types.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"test_normal_sim\".\r\n *\r\n * Model version              : 19.0\r\n * Simulink Coder version : 25.1 (R2025a) 21-Nov-2024\r\n * C source code generated on : Fri Sep 12 15:50:10 2025\r\n *\r\n * Target selection: quarc_win64.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef test_normal_sim_types_h_\r\n#define test_normal_sim_types_h_\r\n\r\n/* Parameters (default storage) */\r\ntypedef struct P_test_normal_sim_T_ P_test_normal_sim_T;\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM_test_normal_sim_T RT_MODEL_test_normal_sim_T;\r\n\r\n#endif                                 /* test_normal_sim_types_h_ */\r\n"},{"name":"test_normal_sim_data.c","type":"source","group":"data","path":"C:\\Users\\khanh\\dev\\python\\projects\\casadi_codegen\\approaches\\01\\test_normal_sim_quarc_win64","tag":"","groupDisplay":"Data files","code":"/*\r\n * test_normal_sim_data.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"test_normal_sim\".\r\n *\r\n * Model version              : 19.0\r\n * Simulink Coder version : 25.1 (R2025a) 21-Nov-2024\r\n * C source code generated on : Fri Sep 12 15:50:10 2025\r\n *\r\n * Target selection: quarc_win64.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"test_normal_sim.h\"\r\n\r\n/* Block parameters (default storage) */\r\nP_test_normal_sim_T test_normal_sim_P = {\r\n  /* Expression: set_other_outputs_at_terminate\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  1.0,\r\n\r\n  /* Expression: set_other_outputs_at_switch_out\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: set_other_outputs_at_start\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  1.0,\r\n\r\n  /* Expression: set_other_outputs_at_switch_in\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: final_analog_outputs\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: final_pwm_outputs\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: final_other_outputs\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  { 1.0, 0.0, 0.0 },\r\n\r\n  /* Expression: analog_input_maximums\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  3.0,\r\n\r\n  /* Expression: analog_input_minimums\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  -3.0,\r\n\r\n  /* Expression: analog_output_maximums\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  15.0,\r\n\r\n  /* Expression: analog_output_minimums\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  -15.0,\r\n\r\n  /* Expression: initial_analog_outputs\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: watchdog_analog_outputs\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: pwm_frequency\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  23195.0,\r\n\r\n  /* Expression: pwm_leading_deadband\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: pwm_trailing_deadband\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: initial_pwm_outputs\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: initial_other_outputs\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  { 0.0, 1.0, 0.0 },\r\n\r\n  /* Expression: watchdog_other_outputs\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  { 0.0, 0.0, 1.0 },\r\n\r\n  /* Computed Parameter: HILInitialize_CKChannels\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  0,\r\n\r\n  /* Computed Parameter: HILInitialize_DOWatchdog\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  0,\r\n\r\n  /* Computed Parameter: HILInitialize_EIInitial\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  0,\r\n\r\n  /* Computed Parameter: HILInitialize_POModes\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  0,\r\n\r\n  /* Computed Parameter: HILInitialize_POConfiguration\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  1,\r\n\r\n  /* Computed Parameter: HILInitialize_POAlignment\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  0,\r\n\r\n  /* Computed Parameter: HILInitialize_POPolarity\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  1,\r\n\r\n  /* Computed Parameter: HILInitialize_AIChannels\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  0U,\r\n\r\n  /* Computed Parameter: HILInitialize_AOChannels\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  0U,\r\n\r\n  /* Computed Parameter: HILInitialize_DOChannels\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  0U,\r\n\r\n  /* Computed Parameter: HILInitialize_EIChannels\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  { 0U, 1U },\r\n\r\n  /* Computed Parameter: HILInitialize_EIQuadrature\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  4U,\r\n\r\n  /* Computed Parameter: HILInitialize_OOChannels\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  { 11000U, 11001U, 11002U },\r\n\r\n  /* Computed Parameter: HILInitialize_Active\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  true,\r\n\r\n  /* Computed Parameter: HILInitialize_AOTerminate\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  true,\r\n\r\n  /* Computed Parameter: HILInitialize_AOExit\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  false,\r\n\r\n  /* Computed Parameter: HILInitialize_DOTerminate\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  true,\r\n\r\n  /* Computed Parameter: HILInitialize_DOExit\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  false,\r\n\r\n  /* Computed Parameter: HILInitialize_POTerminate\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  false,\r\n\r\n  /* Computed Parameter: HILInitialize_POExit\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  false,\r\n\r\n  /* Computed Parameter: HILInitialize_CKPStart\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  false,\r\n\r\n  /* Computed Parameter: HILInitialize_CKPEnter\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  false,\r\n\r\n  /* Computed Parameter: HILInitialize_CKStart\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  false,\r\n\r\n  /* Computed Parameter: HILInitialize_CKEnter\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  false,\r\n\r\n  /* Computed Parameter: HILInitialize_AIPStart\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  false,\r\n\r\n  /* Computed Parameter: HILInitialize_AIPEnter\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  false,\r\n\r\n  /* Computed Parameter: HILInitialize_AOPStart\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  false,\r\n\r\n  /* Computed Parameter: HILInitialize_AOPEnter\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  false,\r\n\r\n  /* Computed Parameter: HILInitialize_AOStart\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  true,\r\n\r\n  /* Computed Parameter: HILInitialize_AOEnter\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  false,\r\n\r\n  /* Computed Parameter: HILInitialize_AOReset\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  true,\r\n\r\n  /* Computed Parameter: HILInitialize_DOPStart\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  false,\r\n\r\n  /* Computed Parameter: HILInitialize_DOPEnter\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  false,\r\n\r\n  /* Computed Parameter: HILInitialize_DOStart\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  true,\r\n\r\n  /* Computed Parameter: HILInitialize_DOEnter\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  false,\r\n\r\n  /* Computed Parameter: HILInitialize_DOReset\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  true,\r\n\r\n  /* Computed Parameter: HILInitialize_EIPStart\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  false,\r\n\r\n  /* Computed Parameter: HILInitialize_EIPEnter\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  false,\r\n\r\n  /* Computed Parameter: HILInitialize_EIStart\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  true,\r\n\r\n  /* Computed Parameter: HILInitialize_EIEnter\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  false,\r\n\r\n  /* Computed Parameter: HILInitialize_POPStart\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  false,\r\n\r\n  /* Computed Parameter: HILInitialize_POPEnter\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  false,\r\n\r\n  /* Computed Parameter: HILInitialize_POStart\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  false,\r\n\r\n  /* Computed Parameter: HILInitialize_POEnter\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  false,\r\n\r\n  /* Computed Parameter: HILInitialize_POReset\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  false,\r\n\r\n  /* Computed Parameter: HILInitialize_OOReset\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  true,\r\n\r\n  /* Computed Parameter: HILInitialize_DOFinal\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  false,\r\n\r\n  /* Computed Parameter: HILInitialize_DOInitial\r\n   * Referenced by: '<Root>/HIL Initialize'\r\n   */\r\n  true\r\n};\r\n"},{"name":"multiword_types.h","type":"header","group":"utility","path":"C:\\Users\\khanh\\dev\\python\\projects\\casadi_codegen\\approaches\\01\\test_normal_sim_quarc_win64","tag":"","groupDisplay":"Utility files","code":"/*\r\n * multiword_types.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"test_normal_sim\".\r\n *\r\n * Model version              : 19.0\r\n * Simulink Coder version : 25.1 (R2025a) 21-Nov-2024\r\n * C source code generated on : Fri Sep 12 15:50:10 2025\r\n *\r\n * Target selection: quarc_win64.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef MULTIWORD_TYPES_H\r\n#define MULTIWORD_TYPES_H\r\n#include \"rtwtypes.h\"\r\n\r\n/*\r\n * Definitions supporting external data access\r\n */\r\ntypedef int32_T chunk_T;\r\ntypedef uint32_T uchunk_T;\r\n\r\n/*\r\n * MultiWord supporting definitions\r\n */\r\ntypedef long int long_T;\r\n\r\n/*\r\n * MultiWord types\r\n */\r\ntypedef struct {\r\n  uint32_T chunks[2];\r\n} int64m_T;\r\n\r\ntypedef struct {\r\n  int64m_T re;\r\n  int64m_T im;\r\n} cint64m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[2];\r\n} uint64m_T;\r\n\r\ntypedef struct {\r\n  uint64m_T re;\r\n  uint64m_T im;\r\n} cuint64m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[3];\r\n} int96m_T;\r\n\r\ntypedef struct {\r\n  int96m_T re;\r\n  int96m_T im;\r\n} cint96m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[3];\r\n} uint96m_T;\r\n\r\ntypedef struct {\r\n  uint96m_T re;\r\n  uint96m_T im;\r\n} cuint96m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[4];\r\n} int128m_T;\r\n\r\ntypedef struct {\r\n  int128m_T re;\r\n  int128m_T im;\r\n} cint128m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[4];\r\n} uint128m_T;\r\n\r\ntypedef struct {\r\n  uint128m_T re;\r\n  uint128m_T im;\r\n} cuint128m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[5];\r\n} int160m_T;\r\n\r\ntypedef struct {\r\n  int160m_T re;\r\n  int160m_T im;\r\n} cint160m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[5];\r\n} uint160m_T;\r\n\r\ntypedef struct {\r\n  uint160m_T re;\r\n  uint160m_T im;\r\n} cuint160m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[6];\r\n} int192m_T;\r\n\r\ntypedef struct {\r\n  int192m_T re;\r\n  int192m_T im;\r\n} cint192m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[6];\r\n} uint192m_T;\r\n\r\ntypedef struct {\r\n  uint192m_T re;\r\n  uint192m_T im;\r\n} cuint192m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[7];\r\n} int224m_T;\r\n\r\ntypedef struct {\r\n  int224m_T re;\r\n  int224m_T im;\r\n} cint224m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[7];\r\n} uint224m_T;\r\n\r\ntypedef struct {\r\n  uint224m_T re;\r\n  uint224m_T im;\r\n} cuint224m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[8];\r\n} int256m_T;\r\n\r\ntypedef struct {\r\n  int256m_T re;\r\n  int256m_T im;\r\n} cint256m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[8];\r\n} uint256m_T;\r\n\r\ntypedef struct {\r\n  uint256m_T re;\r\n  uint256m_T im;\r\n} cuint256m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[9];\r\n} int288m_T;\r\n\r\ntypedef struct {\r\n  int288m_T re;\r\n  int288m_T im;\r\n} cint288m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[9];\r\n} uint288m_T;\r\n\r\ntypedef struct {\r\n  uint288m_T re;\r\n  uint288m_T im;\r\n} cuint288m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[10];\r\n} int320m_T;\r\n\r\ntypedef struct {\r\n  int320m_T re;\r\n  int320m_T im;\r\n} cint320m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[10];\r\n} uint320m_T;\r\n\r\ntypedef struct {\r\n  uint320m_T re;\r\n  uint320m_T im;\r\n} cuint320m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[11];\r\n} int352m_T;\r\n\r\ntypedef struct {\r\n  int352m_T re;\r\n  int352m_T im;\r\n} cint352m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[11];\r\n} uint352m_T;\r\n\r\ntypedef struct {\r\n  uint352m_T re;\r\n  uint352m_T im;\r\n} cuint352m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[12];\r\n} int384m_T;\r\n\r\ntypedef struct {\r\n  int384m_T re;\r\n  int384m_T im;\r\n} cint384m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[12];\r\n} uint384m_T;\r\n\r\ntypedef struct {\r\n  uint384m_T re;\r\n  uint384m_T im;\r\n} cuint384m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[13];\r\n} int416m_T;\r\n\r\ntypedef struct {\r\n  int416m_T re;\r\n  int416m_T im;\r\n} cint416m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[13];\r\n} uint416m_T;\r\n\r\ntypedef struct {\r\n  uint416m_T re;\r\n  uint416m_T im;\r\n} cuint416m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[14];\r\n} int448m_T;\r\n\r\ntypedef struct {\r\n  int448m_T re;\r\n  int448m_T im;\r\n} cint448m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[14];\r\n} uint448m_T;\r\n\r\ntypedef struct {\r\n  uint448m_T re;\r\n  uint448m_T im;\r\n} cuint448m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[15];\r\n} int480m_T;\r\n\r\ntypedef struct {\r\n  int480m_T re;\r\n  int480m_T im;\r\n} cint480m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[15];\r\n} uint480m_T;\r\n\r\ntypedef struct {\r\n  uint480m_T re;\r\n  uint480m_T im;\r\n} cuint480m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[16];\r\n} int512m_T;\r\n\r\ntypedef struct {\r\n  int512m_T re;\r\n  int512m_T im;\r\n} cint512m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[16];\r\n} uint512m_T;\r\n\r\ntypedef struct {\r\n  uint512m_T re;\r\n  uint512m_T im;\r\n} cuint512m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[17];\r\n} int544m_T;\r\n\r\ntypedef struct {\r\n  int544m_T re;\r\n  int544m_T im;\r\n} cint544m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[17];\r\n} uint544m_T;\r\n\r\ntypedef struct {\r\n  uint544m_T re;\r\n  uint544m_T im;\r\n} cuint544m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[18];\r\n} int576m_T;\r\n\r\ntypedef struct {\r\n  int576m_T re;\r\n  int576m_T im;\r\n} cint576m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[18];\r\n} uint576m_T;\r\n\r\ntypedef struct {\r\n  uint576m_T re;\r\n  uint576m_T im;\r\n} cuint576m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[19];\r\n} int608m_T;\r\n\r\ntypedef struct {\r\n  int608m_T re;\r\n  int608m_T im;\r\n} cint608m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[19];\r\n} uint608m_T;\r\n\r\ntypedef struct {\r\n  uint608m_T re;\r\n  uint608m_T im;\r\n} cuint608m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[20];\r\n} int640m_T;\r\n\r\ntypedef struct {\r\n  int640m_T re;\r\n  int640m_T im;\r\n} cint640m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[20];\r\n} uint640m_T;\r\n\r\ntypedef struct {\r\n  uint640m_T re;\r\n  uint640m_T im;\r\n} cuint640m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[21];\r\n} int672m_T;\r\n\r\ntypedef struct {\r\n  int672m_T re;\r\n  int672m_T im;\r\n} cint672m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[21];\r\n} uint672m_T;\r\n\r\ntypedef struct {\r\n  uint672m_T re;\r\n  uint672m_T im;\r\n} cuint672m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[22];\r\n} int704m_T;\r\n\r\ntypedef struct {\r\n  int704m_T re;\r\n  int704m_T im;\r\n} cint704m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[22];\r\n} uint704m_T;\r\n\r\ntypedef struct {\r\n  uint704m_T re;\r\n  uint704m_T im;\r\n} cuint704m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[23];\r\n} int736m_T;\r\n\r\ntypedef struct {\r\n  int736m_T re;\r\n  int736m_T im;\r\n} cint736m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[23];\r\n} uint736m_T;\r\n\r\ntypedef struct {\r\n  uint736m_T re;\r\n  uint736m_T im;\r\n} cuint736m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[24];\r\n} int768m_T;\r\n\r\ntypedef struct {\r\n  int768m_T re;\r\n  int768m_T im;\r\n} cint768m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[24];\r\n} uint768m_T;\r\n\r\ntypedef struct {\r\n  uint768m_T re;\r\n  uint768m_T im;\r\n} cuint768m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[25];\r\n} int800m_T;\r\n\r\ntypedef struct {\r\n  int800m_T re;\r\n  int800m_T im;\r\n} cint800m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[25];\r\n} uint800m_T;\r\n\r\ntypedef struct {\r\n  uint800m_T re;\r\n  uint800m_T im;\r\n} cuint800m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[26];\r\n} int832m_T;\r\n\r\ntypedef struct {\r\n  int832m_T re;\r\n  int832m_T im;\r\n} cint832m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[26];\r\n} uint832m_T;\r\n\r\ntypedef struct {\r\n  uint832m_T re;\r\n  uint832m_T im;\r\n} cuint832m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[27];\r\n} int864m_T;\r\n\r\ntypedef struct {\r\n  int864m_T re;\r\n  int864m_T im;\r\n} cint864m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[27];\r\n} uint864m_T;\r\n\r\ntypedef struct {\r\n  uint864m_T re;\r\n  uint864m_T im;\r\n} cuint864m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[28];\r\n} int896m_T;\r\n\r\ntypedef struct {\r\n  int896m_T re;\r\n  int896m_T im;\r\n} cint896m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[28];\r\n} uint896m_T;\r\n\r\ntypedef struct {\r\n  uint896m_T re;\r\n  uint896m_T im;\r\n} cuint896m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[29];\r\n} int928m_T;\r\n\r\ntypedef struct {\r\n  int928m_T re;\r\n  int928m_T im;\r\n} cint928m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[29];\r\n} uint928m_T;\r\n\r\ntypedef struct {\r\n  uint928m_T re;\r\n  uint928m_T im;\r\n} cuint928m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[30];\r\n} int960m_T;\r\n\r\ntypedef struct {\r\n  int960m_T re;\r\n  int960m_T im;\r\n} cint960m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[30];\r\n} uint960m_T;\r\n\r\ntypedef struct {\r\n  uint960m_T re;\r\n  uint960m_T im;\r\n} cuint960m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[31];\r\n} int992m_T;\r\n\r\ntypedef struct {\r\n  int992m_T re;\r\n  int992m_T im;\r\n} cint992m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[31];\r\n} uint992m_T;\r\n\r\ntypedef struct {\r\n  uint992m_T re;\r\n  uint992m_T im;\r\n} cuint992m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[32];\r\n} int1024m_T;\r\n\r\ntypedef struct {\r\n  int1024m_T re;\r\n  int1024m_T im;\r\n} cint1024m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[32];\r\n} uint1024m_T;\r\n\r\ntypedef struct {\r\n  uint1024m_T re;\r\n  uint1024m_T im;\r\n} cuint1024m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[33];\r\n} int1056m_T;\r\n\r\ntypedef struct {\r\n  int1056m_T re;\r\n  int1056m_T im;\r\n} cint1056m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[33];\r\n} uint1056m_T;\r\n\r\ntypedef struct {\r\n  uint1056m_T re;\r\n  uint1056m_T im;\r\n} cuint1056m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[34];\r\n} int1088m_T;\r\n\r\ntypedef struct {\r\n  int1088m_T re;\r\n  int1088m_T im;\r\n} cint1088m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[34];\r\n} uint1088m_T;\r\n\r\ntypedef struct {\r\n  uint1088m_T re;\r\n  uint1088m_T im;\r\n} cuint1088m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[35];\r\n} int1120m_T;\r\n\r\ntypedef struct {\r\n  int1120m_T re;\r\n  int1120m_T im;\r\n} cint1120m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[35];\r\n} uint1120m_T;\r\n\r\ntypedef struct {\r\n  uint1120m_T re;\r\n  uint1120m_T im;\r\n} cuint1120m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[36];\r\n} int1152m_T;\r\n\r\ntypedef struct {\r\n  int1152m_T re;\r\n  int1152m_T im;\r\n} cint1152m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[36];\r\n} uint1152m_T;\r\n\r\ntypedef struct {\r\n  uint1152m_T re;\r\n  uint1152m_T im;\r\n} cuint1152m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[37];\r\n} int1184m_T;\r\n\r\ntypedef struct {\r\n  int1184m_T re;\r\n  int1184m_T im;\r\n} cint1184m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[37];\r\n} uint1184m_T;\r\n\r\ntypedef struct {\r\n  uint1184m_T re;\r\n  uint1184m_T im;\r\n} cuint1184m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[38];\r\n} int1216m_T;\r\n\r\ntypedef struct {\r\n  int1216m_T re;\r\n  int1216m_T im;\r\n} cint1216m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[38];\r\n} uint1216m_T;\r\n\r\ntypedef struct {\r\n  uint1216m_T re;\r\n  uint1216m_T im;\r\n} cuint1216m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[39];\r\n} int1248m_T;\r\n\r\ntypedef struct {\r\n  int1248m_T re;\r\n  int1248m_T im;\r\n} cint1248m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[39];\r\n} uint1248m_T;\r\n\r\ntypedef struct {\r\n  uint1248m_T re;\r\n  uint1248m_T im;\r\n} cuint1248m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[40];\r\n} int1280m_T;\r\n\r\ntypedef struct {\r\n  int1280m_T re;\r\n  int1280m_T im;\r\n} cint1280m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[40];\r\n} uint1280m_T;\r\n\r\ntypedef struct {\r\n  uint1280m_T re;\r\n  uint1280m_T im;\r\n} cuint1280m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[41];\r\n} int1312m_T;\r\n\r\ntypedef struct {\r\n  int1312m_T re;\r\n  int1312m_T im;\r\n} cint1312m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[41];\r\n} uint1312m_T;\r\n\r\ntypedef struct {\r\n  uint1312m_T re;\r\n  uint1312m_T im;\r\n} cuint1312m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[42];\r\n} int1344m_T;\r\n\r\ntypedef struct {\r\n  int1344m_T re;\r\n  int1344m_T im;\r\n} cint1344m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[42];\r\n} uint1344m_T;\r\n\r\ntypedef struct {\r\n  uint1344m_T re;\r\n  uint1344m_T im;\r\n} cuint1344m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[43];\r\n} int1376m_T;\r\n\r\ntypedef struct {\r\n  int1376m_T re;\r\n  int1376m_T im;\r\n} cint1376m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[43];\r\n} uint1376m_T;\r\n\r\ntypedef struct {\r\n  uint1376m_T re;\r\n  uint1376m_T im;\r\n} cuint1376m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[44];\r\n} int1408m_T;\r\n\r\ntypedef struct {\r\n  int1408m_T re;\r\n  int1408m_T im;\r\n} cint1408m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[44];\r\n} uint1408m_T;\r\n\r\ntypedef struct {\r\n  uint1408m_T re;\r\n  uint1408m_T im;\r\n} cuint1408m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[45];\r\n} int1440m_T;\r\n\r\ntypedef struct {\r\n  int1440m_T re;\r\n  int1440m_T im;\r\n} cint1440m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[45];\r\n} uint1440m_T;\r\n\r\ntypedef struct {\r\n  uint1440m_T re;\r\n  uint1440m_T im;\r\n} cuint1440m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[46];\r\n} int1472m_T;\r\n\r\ntypedef struct {\r\n  int1472m_T re;\r\n  int1472m_T im;\r\n} cint1472m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[46];\r\n} uint1472m_T;\r\n\r\ntypedef struct {\r\n  uint1472m_T re;\r\n  uint1472m_T im;\r\n} cuint1472m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[47];\r\n} int1504m_T;\r\n\r\ntypedef struct {\r\n  int1504m_T re;\r\n  int1504m_T im;\r\n} cint1504m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[47];\r\n} uint1504m_T;\r\n\r\ntypedef struct {\r\n  uint1504m_T re;\r\n  uint1504m_T im;\r\n} cuint1504m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[48];\r\n} int1536m_T;\r\n\r\ntypedef struct {\r\n  int1536m_T re;\r\n  int1536m_T im;\r\n} cint1536m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[48];\r\n} uint1536m_T;\r\n\r\ntypedef struct {\r\n  uint1536m_T re;\r\n  uint1536m_T im;\r\n} cuint1536m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[49];\r\n} int1568m_T;\r\n\r\ntypedef struct {\r\n  int1568m_T re;\r\n  int1568m_T im;\r\n} cint1568m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[49];\r\n} uint1568m_T;\r\n\r\ntypedef struct {\r\n  uint1568m_T re;\r\n  uint1568m_T im;\r\n} cuint1568m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[50];\r\n} int1600m_T;\r\n\r\ntypedef struct {\r\n  int1600m_T re;\r\n  int1600m_T im;\r\n} cint1600m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[50];\r\n} uint1600m_T;\r\n\r\ntypedef struct {\r\n  uint1600m_T re;\r\n  uint1600m_T im;\r\n} cuint1600m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[51];\r\n} int1632m_T;\r\n\r\ntypedef struct {\r\n  int1632m_T re;\r\n  int1632m_T im;\r\n} cint1632m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[51];\r\n} uint1632m_T;\r\n\r\ntypedef struct {\r\n  uint1632m_T re;\r\n  uint1632m_T im;\r\n} cuint1632m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[52];\r\n} int1664m_T;\r\n\r\ntypedef struct {\r\n  int1664m_T re;\r\n  int1664m_T im;\r\n} cint1664m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[52];\r\n} uint1664m_T;\r\n\r\ntypedef struct {\r\n  uint1664m_T re;\r\n  uint1664m_T im;\r\n} cuint1664m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[53];\r\n} int1696m_T;\r\n\r\ntypedef struct {\r\n  int1696m_T re;\r\n  int1696m_T im;\r\n} cint1696m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[53];\r\n} uint1696m_T;\r\n\r\ntypedef struct {\r\n  uint1696m_T re;\r\n  uint1696m_T im;\r\n} cuint1696m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[54];\r\n} int1728m_T;\r\n\r\ntypedef struct {\r\n  int1728m_T re;\r\n  int1728m_T im;\r\n} cint1728m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[54];\r\n} uint1728m_T;\r\n\r\ntypedef struct {\r\n  uint1728m_T re;\r\n  uint1728m_T im;\r\n} cuint1728m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[55];\r\n} int1760m_T;\r\n\r\ntypedef struct {\r\n  int1760m_T re;\r\n  int1760m_T im;\r\n} cint1760m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[55];\r\n} uint1760m_T;\r\n\r\ntypedef struct {\r\n  uint1760m_T re;\r\n  uint1760m_T im;\r\n} cuint1760m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[56];\r\n} int1792m_T;\r\n\r\ntypedef struct {\r\n  int1792m_T re;\r\n  int1792m_T im;\r\n} cint1792m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[56];\r\n} uint1792m_T;\r\n\r\ntypedef struct {\r\n  uint1792m_T re;\r\n  uint1792m_T im;\r\n} cuint1792m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[57];\r\n} int1824m_T;\r\n\r\ntypedef struct {\r\n  int1824m_T re;\r\n  int1824m_T im;\r\n} cint1824m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[57];\r\n} uint1824m_T;\r\n\r\ntypedef struct {\r\n  uint1824m_T re;\r\n  uint1824m_T im;\r\n} cuint1824m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[58];\r\n} int1856m_T;\r\n\r\ntypedef struct {\r\n  int1856m_T re;\r\n  int1856m_T im;\r\n} cint1856m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[58];\r\n} uint1856m_T;\r\n\r\ntypedef struct {\r\n  uint1856m_T re;\r\n  uint1856m_T im;\r\n} cuint1856m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[59];\r\n} int1888m_T;\r\n\r\ntypedef struct {\r\n  int1888m_T re;\r\n  int1888m_T im;\r\n} cint1888m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[59];\r\n} uint1888m_T;\r\n\r\ntypedef struct {\r\n  uint1888m_T re;\r\n  uint1888m_T im;\r\n} cuint1888m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[60];\r\n} int1920m_T;\r\n\r\ntypedef struct {\r\n  int1920m_T re;\r\n  int1920m_T im;\r\n} cint1920m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[60];\r\n} uint1920m_T;\r\n\r\ntypedef struct {\r\n  uint1920m_T re;\r\n  uint1920m_T im;\r\n} cuint1920m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[61];\r\n} int1952m_T;\r\n\r\ntypedef struct {\r\n  int1952m_T re;\r\n  int1952m_T im;\r\n} cint1952m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[61];\r\n} uint1952m_T;\r\n\r\ntypedef struct {\r\n  uint1952m_T re;\r\n  uint1952m_T im;\r\n} cuint1952m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[62];\r\n} int1984m_T;\r\n\r\ntypedef struct {\r\n  int1984m_T re;\r\n  int1984m_T im;\r\n} cint1984m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[62];\r\n} uint1984m_T;\r\n\r\ntypedef struct {\r\n  uint1984m_T re;\r\n  uint1984m_T im;\r\n} cuint1984m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[63];\r\n} int2016m_T;\r\n\r\ntypedef struct {\r\n  int2016m_T re;\r\n  int2016m_T im;\r\n} cint2016m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[63];\r\n} uint2016m_T;\r\n\r\ntypedef struct {\r\n  uint2016m_T re;\r\n  uint2016m_T im;\r\n} cuint2016m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[64];\r\n} int2048m_T;\r\n\r\ntypedef struct {\r\n  int2048m_T re;\r\n  int2048m_T im;\r\n} cint2048m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[64];\r\n} uint2048m_T;\r\n\r\ntypedef struct {\r\n  uint2048m_T re;\r\n  uint2048m_T im;\r\n} cuint2048m_T;\r\n\r\n#endif                                 /* MULTIWORD_TYPES_H */\r\n"},{"name":"rt_defines.h","type":"header","group":"utility","path":"C:\\Users\\khanh\\dev\\python\\projects\\casadi_codegen\\approaches\\01\\test_normal_sim_quarc_win64","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rt_defines.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"test_normal_sim\".\r\n *\r\n * Model version              : 19.0\r\n * Simulink Coder version : 25.1 (R2025a) 21-Nov-2024\r\n * C source code generated on : Fri Sep 12 15:50:10 2025\r\n *\r\n * Target selection: quarc_win64.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef rt_defines_h_\r\n#define rt_defines_h_\r\n\r\n/*===========*\r\n * Constants *\r\n *===========*/\r\n#define RT_PI                          3.14159265358979323846\r\n#define RT_PIF                         3.1415927F\r\n#define RT_LN_10                       2.30258509299404568402\r\n#define RT_LN_10F                      2.3025851F\r\n#define RT_LOG10E                      0.43429448190325182765\r\n#define RT_LOG10EF                     0.43429449F\r\n#define RT_E                           2.7182818284590452354\r\n#define RT_EF                          2.7182817F\r\n\r\n/*\r\n * UNUSED_PARAMETER(x)\r\n *   Used to specify that a function parameter (argument) is required but not\r\n *   accessed by the function body.\r\n */\r\n#ifndef UNUSED_PARAMETER\r\n#if defined(__LCC__)\r\n#define UNUSED_PARAMETER(x)                                      /* do nothing */\r\n#else\r\n\r\n/*\r\n * This is the semi-ANSI standard way of indicating that an\r\n * unused function parameter is required.\r\n */\r\n#define UNUSED_PARAMETER(x)            (void) (x)\r\n#endif\r\n#endif\r\n#endif                                 /* rt_defines_h_ */\r\n"},{"name":"rt_nonfinite.c","type":"source","group":"utility","path":"C:\\Users\\khanh\\dev\\python\\projects\\casadi_codegen\\approaches\\01\\test_normal_sim_quarc_win64","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rt_nonfinite.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"test_normal_sim\".\r\n *\r\n * Model version              : 19.0\r\n * Simulink Coder version : 25.1 (R2025a) 21-Nov-2024\r\n * C source code generated on : Fri Sep 12 15:50:10 2025\r\n *\r\n * Target selection: quarc_win64.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"rt_nonfinite.h\"\r\n#include \"math.h\"\r\n\r\nreal_T rtNaN = -(real_T)NAN;\r\nreal_T rtInf = (real_T)INFINITY;\r\nreal_T rtMinusInf = -(real_T)INFINITY;\r\nreal32_T rtNaNF = -(real32_T)NAN;\r\nreal32_T rtInfF = (real32_T)INFINITY;\r\nreal32_T rtMinusInfF = -(real32_T)INFINITY;\r\n\r\n/* Test if value is infinite */\r\nboolean_T rtIsInf(real_T value)\r\n{\r\n  return (boolean_T)isinf(value);\r\n}\r\n\r\n/* Test if single-precision value is infinite */\r\nboolean_T rtIsInfF(real32_T value)\r\n{\r\n  return (boolean_T)isinf(value);\r\n}\r\n\r\n/* Test if value is not a number */\r\nboolean_T rtIsNaN(real_T value)\r\n{\r\n  return (boolean_T)(isnan(value) != 0);\r\n}\r\n\r\n/* Test if single-precision value is not a number */\r\nboolean_T rtIsNaNF(real32_T value)\r\n{\r\n  return (boolean_T)(isnan(value) != 0);\r\n}\r\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"C:\\Users\\khanh\\dev\\python\\projects\\casadi_codegen\\approaches\\01\\test_normal_sim_quarc_win64","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rt_nonfinite.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"test_normal_sim\".\r\n *\r\n * Model version              : 19.0\r\n * Simulink Coder version : 25.1 (R2025a) 21-Nov-2024\r\n * C source code generated on : Fri Sep 12 15:50:10 2025\r\n *\r\n * Target selection: quarc_win64.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef rt_nonfinite_h_\r\n#define rt_nonfinite_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rtInf;\r\nextern real_T rtMinusInf;\r\nextern real_T rtNaN;\r\nextern real32_T rtInfF;\r\nextern real32_T rtMinusInfF;\r\nextern real32_T rtNaNF;\r\nextern boolean_T rtIsInf(real_T value);\r\nextern boolean_T rtIsInfF(real32_T value);\r\nextern boolean_T rtIsNaN(real_T value);\r\nextern boolean_T rtIsNaNF(real32_T value);\r\n\r\n#endif                                 /* rt_nonfinite_h_ */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"C:\\Users\\khanh\\dev\\python\\projects\\casadi_codegen\\approaches\\01\\test_normal_sim_quarc_win64","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtwtypes.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"test_normal_sim\".\r\n *\r\n * Model version              : 19.0\r\n * Simulink Coder version : 25.1 (R2025a) 21-Nov-2024\r\n * C source code generated on : Fri Sep 12 15:50:10 2025\r\n *\r\n * Target selection: quarc_win64.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n#include \"tmwtypes.h\"\r\n#ifndef POINTER_T\r\n#define POINTER_T\r\n\r\ntypedef void * pointer_T;\r\n\r\n#endif\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n#endif                                 /* RTWTYPES_H */\r\n"},{"name":"zero_crossing_types.h","type":"header","group":"utility","path":"C:\\Users\\khanh\\dev\\python\\projects\\casadi_codegen\\approaches\\01\\test_normal_sim_quarc_win64","tag":"","groupDisplay":"Utility files","code":"/*\r\n * zero_crossing_types.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"test_normal_sim\".\r\n *\r\n * Model version              : 19.0\r\n * Simulink Coder version : 25.1 (R2025a) 21-Nov-2024\r\n * C source code generated on : Fri Sep 12 15:50:10 2025\r\n *\r\n * Target selection: quarc_win64.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef ZERO_CROSSING_TYPES_H\r\n#define ZERO_CROSSING_TYPES_H\r\n#include \"rtwtypes.h\"\r\n\r\n/* Trigger directions: falling, either, and rising */\r\ntypedef enum {\r\n  FALLING_ZERO_CROSSING = -1,\r\n  ANY_ZERO_CROSSING = 0,\r\n  RISING_ZERO_CROSSING = 1\r\n} ZCDirection;\r\n\r\n/* Previous state of a trigger signal */\r\ntypedef uint8_T ZCSigState;\r\n\r\n/* Initial value of a trigger zero crossing signal */\r\n#define UNINITIALIZED_ZCSIG            0x03U\r\n#define NEG_ZCSIG                      0x02U\r\n#define POS_ZCSIG                      0x01U\r\n#define ZERO_ZCSIG                     0x00U\r\n\r\n/* Current state of a trigger signal */\r\ntypedef enum { FALLING_ZCEVENT = -1, NO_ZCEVENT = 0, RISING_ZCEVENT = 1 }\r\n  ZCEventType;\r\n\r\n#endif                                 /* ZERO_CROSSING_TYPES_H */\r\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"C:\\Users\\khanh\\dev\\python\\projects\\casadi_codegen\\approaches\\01\\test_normal_sim_quarc_win64","tag":"","groupDisplay":"Interface files","code":"/*\r\n *  rtmodel.h:\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"test_normal_sim\".\r\n *\r\n * Model version              : 19.0\r\n * Simulink Coder version : 25.1 (R2025a) 21-Nov-2024\r\n * C source code generated on : Fri Sep 12 15:50:10 2025\r\n *\r\n * Target selection: quarc_win64.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef rtmodel_h_\r\n#define rtmodel_h_\r\n#include \"test_normal_sim.h\"\r\n#define GRTINTERFACE                   1\r\n#endif                                 /* rtmodel_h_ */\r\n"},{"name":"solver_01.c","type":"source","group":"interface","path":"C:\\Users\\khanh\\dev\\python\\projects\\casadi_codegen\\approaches\\01","tag":"","groupDisplay":"Interface files","code":"/* This file was automatically generated by CasADi 3.7.1.\n *  It consists of: \n *   1) content generated by CasADi runtime: not copyrighted\n *   2) template code copied from CasADi source: permissively licensed (MIT-0)\n *   3) user code: owned by the user\n *\n */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* How to prefix internal symbols */\n#ifdef CASADI_CODEGEN_PREFIX\n  #define CASADI_NAMESPACE_CONCAT(NS, ID) _CASADI_NAMESPACE_CONCAT(NS, ID)\n  #define _CASADI_NAMESPACE_CONCAT(NS, ID) NS ## ID\n  #define CASADI_PREFIX(ID) CASADI_NAMESPACE_CONCAT(CODEGEN_PREFIX, ID)\n#else\n  #define CASADI_PREFIX(ID) solver_01_ ## ID\n#endif\n\n#include <math.h>\n#include <simstruc.h>\n#include <osqp/osqp.h>\n\n#ifndef casadi_real\n#define casadi_real real_T\n#endif\n\n#ifndef casadi_int\n#define casadi_int int_T\n#endif\n\n#ifndef CASADI_MAX_NUM_THREADS\n#define CASADI_MAX_NUM_THREADS 1\n#endif\n\n/* Add prefix to internal symbols */\n#define casadi_axpy CASADI_PREFIX(axpy)\n#define casadi_c0 CASADI_PREFIX(c0)\n#define casadi_c1 CASADI_PREFIX(c1)\n#define casadi_c2 CASADI_PREFIX(c2)\n#define casadi_c3 CASADI_PREFIX(c3)\n#define casadi_clear CASADI_PREFIX(clear)\n#define casadi_copy CASADI_PREFIX(copy)\n#define casadi_densify CASADI_PREFIX(densify)\n#define casadi_dot CASADI_PREFIX(dot)\n#define casadi_f0 CASADI_PREFIX(f0)\n#define casadi_f1 CASADI_PREFIX(f1)\n#define casadi_f1_alloc_mem CASADI_PREFIX(f1_alloc_mem)\n#define casadi_f1_init_mem CASADI_PREFIX(f1_init_mem)\n#define casadi_f1_mem CASADI_PREFIX(f1_mem)\n#define casadi_f1_mem_counter CASADI_PREFIX(f1_mem_counter)\n#define casadi_f1_unused_stack CASADI_PREFIX(f1_unused_stack)\n#define casadi_f1_unused_stack_counter CASADI_PREFIX(f1_unused_stack_counter)\n#define casadi_f2 CASADI_PREFIX(f2)\n#define casadi_f3 CASADI_PREFIX(f3)\n#define casadi_f4 CASADI_PREFIX(f4)\n#define casadi_f5 CASADI_PREFIX(f5)\n#define casadi_f6 CASADI_PREFIX(f6)\n#define casadi_f6_alloc_mem CASADI_PREFIX(f6_alloc_mem)\n#define casadi_f6_init_mem CASADI_PREFIX(f6_init_mem)\n#define casadi_f6_mem CASADI_PREFIX(f6_mem)\n#define casadi_f6_mem_counter CASADI_PREFIX(f6_mem_counter)\n#define casadi_f6_unused_stack CASADI_PREFIX(f6_unused_stack)\n#define casadi_f6_unused_stack_counter CASADI_PREFIX(f6_unused_stack_counter)\n#define casadi_f7 CASADI_PREFIX(f7)\n#define casadi_fabs CASADI_PREFIX(fabs)\n#define casadi_fill CASADI_PREFIX(fill)\n#define casadi_fmax CASADI_PREFIX(fmax)\n#define casadi_max_viol CASADI_PREFIX(max_viol)\n#define casadi_mtimes CASADI_PREFIX(mtimes)\n#define casadi_mv CASADI_PREFIX(mv)\n#define casadi_nlpsol_data CASADI_PREFIX(nlpsol_data)\n#define casadi_nlpsol_detect_bounds_after CASADI_PREFIX(nlpsol_detect_bounds_after)\n#define casadi_nlpsol_detect_bounds_before CASADI_PREFIX(nlpsol_detect_bounds_before)\n#define casadi_nlpsol_detect_bounds_data CASADI_PREFIX(nlpsol_detect_bounds_data)\n#define casadi_nlpsol_detect_bounds_prob CASADI_PREFIX(nlpsol_detect_bounds_prob)\n#define casadi_nlpsol_init CASADI_PREFIX(nlpsol_init)\n#define casadi_nlpsol_prob CASADI_PREFIX(nlpsol_prob)\n#define casadi_nlpsol_work CASADI_PREFIX(nlpsol_work)\n#define casadi_norm_inf CASADI_PREFIX(norm_inf)\n#define casadi_oracle_data CASADI_PREFIX(oracle_data)\n#define casadi_oracle_init CASADI_PREFIX(oracle_init)\n#define casadi_qp_data CASADI_PREFIX(qp_data)\n#define casadi_qp_init CASADI_PREFIX(qp_init)\n#define casadi_qp_prob CASADI_PREFIX(qp_prob)\n#define casadi_qp_setup CASADI_PREFIX(qp_setup)\n#define casadi_qp_work CASADI_PREFIX(qp_work)\n#define casadi_s0 CASADI_PREFIX(s0)\n#define casadi_s1 CASADI_PREFIX(s1)\n#define casadi_s10 CASADI_PREFIX(s10)\n#define casadi_s11 CASADI_PREFIX(s11)\n#define casadi_s12 CASADI_PREFIX(s12)\n#define casadi_s13 CASADI_PREFIX(s13)\n#define casadi_s14 CASADI_PREFIX(s14)\n#define casadi_s15 CASADI_PREFIX(s15)\n#define casadi_s16 CASADI_PREFIX(s16)\n#define casadi_s17 CASADI_PREFIX(s17)\n#define casadi_s18 CASADI_PREFIX(s18)\n#define casadi_s19 CASADI_PREFIX(s19)\n#define casadi_s2 CASADI_PREFIX(s2)\n#define casadi_s20 CASADI_PREFIX(s20)\n#define casadi_s21 CASADI_PREFIX(s21)\n#define casadi_s22 CASADI_PREFIX(s22)\n#define casadi_s23 CASADI_PREFIX(s23)\n#define casadi_s24 CASADI_PREFIX(s24)\n#define casadi_s25 CASADI_PREFIX(s25)\n#define casadi_s3 CASADI_PREFIX(s3)\n#define casadi_s4 CASADI_PREFIX(s4)\n#define casadi_s5 CASADI_PREFIX(s5)\n#define casadi_s6 CASADI_PREFIX(s6)\n#define casadi_s7 CASADI_PREFIX(s7)\n#define casadi_s8 CASADI_PREFIX(s8)\n#define casadi_s9 CASADI_PREFIX(s9)\n#define casadi_scal CASADI_PREFIX(scal)\n#define casadi_sq CASADI_PREFIX(sq)\n#define casadi_sqpmethod_data CASADI_PREFIX(sqpmethod_data)\n#define casadi_sqpmethod_init CASADI_PREFIX(sqpmethod_init)\n#define casadi_sqpmethod_prob CASADI_PREFIX(sqpmethod_prob)\n#define casadi_sqpmethod_work CASADI_PREFIX(sqpmethod_work)\n#define casadi_sum_viol CASADI_PREFIX(sum_viol)\n#define casadi_trans CASADI_PREFIX(trans)\n#define casadi_tri_project CASADI_PREFIX(tri_project)\n#define casadi_zeros CASADI_PREFIX(zeros)\n\n/* Symbol visibility in DLLs */\n#ifndef CASADI_SYMBOL_EXPORT\n  #if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)\n    #if defined(STATIC_LINKED)\n      #define CASADI_SYMBOL_EXPORT\n    #else\n      #define CASADI_SYMBOL_EXPORT __declspec(dllexport)\n    #endif\n  #elif defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)\n    #define CASADI_SYMBOL_EXPORT __attribute__ ((visibility (\"default\")))\n  #else\n    #define CASADI_SYMBOL_EXPORT\n  #endif\n#endif\n\nvoid casadi_fill(casadi_real* x, casadi_int n, casadi_real alpha) {\n  casadi_int i;\n  if (x) {\n    for (i=0; i<n; ++i) *x++ = alpha;\n  }\n}\n\nvoid casadi_clear(casadi_real* x, casadi_int n) {\n  casadi_int i;\n  if (x) {\n    for (i=0; i<n; ++i) *x++ = 0;\n  }\n}\n\nvoid casadi_copy(const casadi_real* x, casadi_int n, casadi_real* y) {\n  casadi_int i;\n  if (y) {\n    if (x) {\n      for (i=0; i<n; ++i) *y++ = *x++;\n    } else {\n      for (i=0; i<n; ++i) *y++ = 0.;\n    }\n  }\n}\n\ncasadi_real casadi_sq(casadi_real x) { return x*x;}\n\ncasadi_real casadi_dot(casadi_int n, const casadi_real* x, const casadi_real* y) {\n  casadi_int i;\n  casadi_real r = 0;\n  for (i=0; i<n; ++i) r += *x++ * *y++;\n  return r;\n}\n\n#define CASADI_CAST(x,y) ((x) y)\n\nvoid casadi_densify(const casadi_real* x, const casadi_int* sp_x, casadi_real* y, casadi_int tr) {\n  casadi_int nrow_x, ncol_x, i, el;\n  const casadi_int *colind_x, *row_x;\n  if (!y) return;\n  nrow_x = sp_x[0]; ncol_x = sp_x[1];\n  colind_x = sp_x+2; row_x = sp_x+ncol_x+3;\n  casadi_clear(y, nrow_x*ncol_x);\n  if (!x) return;\n  if (tr) {\n    for (i=0; i<ncol_x; ++i) {\n      for (el=colind_x[i]; el!=colind_x[i+1]; ++el) {\n        y[i + row_x[el]*ncol_x] = CASADI_CAST(casadi_real, *x++);\n      }\n    }\n  } else {\n    for (i=0; i<ncol_x; ++i) {\n      for (el=colind_x[i]; el!=colind_x[i+1]; ++el) {\n        y[row_x[el]] = CASADI_CAST(casadi_real, *x++);\n      }\n      y += nrow_x;\n    }\n  }\n}\n\nvoid casadi_mtimes(const casadi_real* x, const casadi_int* sp_x, const casadi_real* y, const casadi_int* sp_y, casadi_real* z, const casadi_int* sp_z, casadi_real* w, casadi_int tr) {\n  casadi_int ncol_x, ncol_y, ncol_z, cc;\n  const casadi_int *colind_x, *row_x, *colind_y, *row_y, *colind_z, *row_z;\n  ncol_x = sp_x[1];\n  colind_x = sp_x+2; row_x = sp_x + 2 + ncol_x+1;\n  ncol_y = sp_y[1];\n  colind_y = sp_y+2; row_y = sp_y + 2 + ncol_y+1;\n  ncol_z = sp_z[1];\n  colind_z = sp_z+2; row_z = sp_z + 2 + ncol_z+1;\n  if (tr) {\n    for (cc=0; cc<ncol_z; ++cc) {\n      casadi_int kk;\n      for (kk=colind_y[cc]; kk<colind_y[cc+1]; ++kk) {\n        w[row_y[kk]] = y[kk];\n      }\n      for (kk=colind_z[cc]; kk<colind_z[cc+1]; ++kk) {\n        casadi_int kk1;\n        casadi_int rr = row_z[kk];\n        for (kk1=colind_x[rr]; kk1<colind_x[rr+1]; ++kk1) {\n          z[kk] += x[kk1] * w[row_x[kk1]];\n        }\n      }\n    }\n  } else {\n    for (cc=0; cc<ncol_y; ++cc) {\n      casadi_int kk;\n      for (kk=colind_z[cc]; kk<colind_z[cc+1]; ++kk) {\n        w[row_z[kk]] = z[kk];\n      }\n      for (kk=colind_y[cc]; kk<colind_y[cc+1]; ++kk) {\n        casadi_int kk1;\n        casadi_int rr = row_y[kk];\n        for (kk1=colind_x[rr]; kk1<colind_x[rr+1]; ++kk1) {\n          w[row_x[kk1]] += x[kk1]*y[kk];\n        }\n      }\n      for (kk=colind_z[cc]; kk<colind_z[cc+1]; ++kk) {\n        z[kk] = w[row_z[kk]];\n      }\n    }\n  }\n}\n\nvoid casadi_trans(const casadi_real* x, const casadi_int* sp_x, casadi_real* y,\n    const casadi_int* sp_y, casadi_int* tmp) {\n  casadi_int ncol_x, nnz_x, ncol_y, k;\n  const casadi_int* row_x, *colind_y;\n  ncol_x = sp_x[1];\n  nnz_x = sp_x[2 + ncol_x];\n  row_x = sp_x + 2 + ncol_x+1;\n  ncol_y = sp_y[1];\n  colind_y = sp_y+2;\n  for (k=0; k<ncol_y; ++k) tmp[k] = colind_y[k];\n  for (k=0; k<nnz_x; ++k) {\n    y[tmp[row_x[k]]++] = x[k];\n  }\n}\n\n#ifndef casadi_inf\n  #define casadi_inf INFINITY\n#endif\n\nvoid casadi_tri_project(const casadi_real* x, const casadi_int* sp_x, casadi_real* y, casadi_int lower) {\n  casadi_int ncol_x, j, k;\n  const casadi_int *colind_x, *row_x;\n  ncol_x = sp_x[1];\n  colind_x = sp_x+2; row_x = sp_x + 2 + ncol_x+1;\n  for (j=0; j<ncol_x; ++j) {\n    for (k=colind_x[j]; k<colind_x[j+1]; ++k) {\n      if (lower) {\n        if (row_x[k]>=j) *y++ = x ? x[k] : 0;\n      } else {\n        if (row_x[k]<=j) *y++ = x ? x[k] : 0;\n      }\n    }\n  }\n}\n\nstatic int casadi_f6_mem_counter = 0;\nstatic int casadi_f6_unused_stack_counter = -1;\nstatic int casadi_f6_unused_stack[CASADI_MAX_NUM_THREADS];\nstatic OSQPWorkspace* casadi_f6_mem[CASADI_MAX_NUM_THREADS];\n\nstruct casadi_qp_prob {\n  const casadi_int *sp_a, *sp_h;\n  casadi_int nx, na, nz;\n  casadi_int nnz_a, nnz_h;\n};\nvoid casadi_qp_setup(struct casadi_qp_prob* p) {\n  p->na = p->sp_a[0];\n  p->nx = p->sp_a[1];\n  p->nz = p->na+p->nx;\n  p->nnz_a = p->sp_a[2+p->sp_a[1]];\n  p->nnz_h = p->sp_h[2+p->sp_h[1]];\n}\nstruct casadi_qp_data {\n  const struct casadi_qp_prob* prob;\n  int unified_return_status;\n  int success;\n  casadi_int iter_count;\n  const casadi_real *a, *h, *g, *lbx, *ubx, *lba, *uba, *x0, *lam_x0, *lam_a0;\n  casadi_real *f, *x, *lam_x, *lam_a;\n};\nvoid casadi_qp_init(struct casadi_qp_data* d, casadi_int** iw, casadi_real** w) {\n}\nvoid casadi_qp_work(const struct casadi_qp_prob* p, casadi_int* sz_arg, casadi_int* sz_res,\n    casadi_int* sz_iw, casadi_int* sz_w) {\n  *sz_arg = *sz_res = 0;\n  *sz_w = *sz_iw = 0;\n}\n\nstruct casadi_oracle_data {\n  const casadi_real** arg;\n  casadi_real** res;\n  casadi_int* iw;\n  casadi_real* w;\n  void* m;\n};\nvoid casadi_oracle_init(struct casadi_oracle_data* d, const casadi_real*** arg, casadi_real*** res,\n    casadi_int** iw, casadi_real** w) {\n  d->arg = *arg;\n  d->res = *res;\n  d->iw = *iw;\n  d->w = *w;\n}\n\nstruct casadi_nlpsol_detect_bounds_prob {\n  casadi_int sz_arg;\n  casadi_int sz_res;\n  casadi_int sz_iw;\n  casadi_int sz_w;\n  casadi_int ng;\n  casadi_int nb;\n  const casadi_int *target_x;\n  const casadi_int *target_g;\n  const char *is_simple;\n  int (*callback)(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, void* callback_data);\n  void* callback_data;\n};\nstruct casadi_nlpsol_prob {\n  casadi_int nx, ng, np;\n  struct casadi_nlpsol_detect_bounds_prob detect_bounds;\n};\nstruct casadi_nlpsol_detect_bounds_data {\n  const casadi_real** arg;\n  casadi_real** res;\n  casadi_int* iw;\n  casadi_real* w;\n  casadi_real* a;\n  casadi_real* b;\n  casadi_int* target_l;\n  casadi_int* target_u;\n  casadi_real* lam_xl;\n  casadi_real* lam_xu;\n};\nstruct casadi_nlpsol_data {\n  const struct casadi_nlpsol_prob* prob;\n  struct casadi_oracle_data* oracle;\n  casadi_real *lbz, *ubz;\n  casadi_real *z;\n  casadi_real *lam;\n  casadi_real objective;\n  const casadi_real *p, *lbx, *ubx, *lbg, *ubg, *x0, *lam_x0, *lam_g0;\n  casadi_real *f, *x, *g, *lam_x, *lam_g, *lam_p;\n  struct casadi_nlpsol_detect_bounds_data detect_bounds;\n};\nvoid casadi_nlpsol_work(const struct casadi_nlpsol_prob* p, casadi_int* sz_arg, casadi_int* sz_res,\n    casadi_int* sz_iw, casadi_int* sz_w) {\n  *sz_arg = *sz_res = 0;\n  *sz_w = *sz_iw = 0;\n  *sz_w += p->nx + p->ng;\n  *sz_w += p->nx + p->ng;\n  *sz_w += p->nx + p->ng;\n  *sz_w += p->nx + p->ng;\n  if (p->detect_bounds.ng) {\n    *sz_arg += p->detect_bounds.sz_arg;\n    *sz_res += p->detect_bounds.sz_res;\n    *sz_iw += p->detect_bounds.sz_iw;\n    *sz_w += p->detect_bounds.sz_w;\n    *sz_w += p->detect_bounds.nb;\n    *sz_w += p->detect_bounds.nb;\n    *sz_iw += p->nx;\n    *sz_iw += p->nx;\n    *sz_w += p->nx;\n    *sz_w += p->nx;\n  }\n}\nvoid casadi_nlpsol_init(struct casadi_nlpsol_data* d, const casadi_real*** arg, casadi_real*** res,\n    casadi_int** iw, casadi_real** w) {\n  casadi_int nx, ng;\n  const struct casadi_nlpsol_prob* p = d->prob;\n  nx = p->nx;\n  ng = p->ng;\n  d->z = *w; *w += nx + ng;\n  d->lbz = *w; *w += nx + ng;\n  d->ubz = *w; *w += nx + ng;\n  d->lam = *w; *w += nx + ng;\n  if (p->detect_bounds.ng) {\n    d->detect_bounds.arg = *arg; *arg += p->detect_bounds.sz_arg;\n    d->detect_bounds.res = *res; *res += p->detect_bounds.sz_res;\n    d->detect_bounds.iw = *iw; *iw += p->detect_bounds.sz_iw;\n    d->detect_bounds.w = *w; *w += p->detect_bounds.sz_w;\n    d->detect_bounds.a = *w; *w += p->detect_bounds.nb;\n    d->detect_bounds.b = *w; *w += p->detect_bounds.nb;\n    d->detect_bounds.target_l = *iw; *iw += p->nx;\n    d->detect_bounds.target_u = *iw; *iw += p->nx;\n    d->detect_bounds.lam_xl = *w; *w += nx;\n    d->detect_bounds.lam_xu = *w; *w += nx;\n  }\n}\nint casadi_detect_bounds_before(struct casadi_nlpsol_data* d_nlp) {\n  const struct casadi_nlpsol_prob* p_nlp = d_nlp->prob;\n  struct casadi_nlpsol_detect_bounds_data* d_bounds = &d_nlp->detect_bounds;\n  const struct casadi_nlpsol_detect_bounds_prob* p_bounds = &p_nlp->detect_bounds;\n  casadi_int nx = p_nlp->nx;\n  d_bounds->arg[0] = d_nlp->z;\n  d_bounds->arg[1] = d_nlp->p;\n  d_bounds->res[0] = d_bounds->a;\n  d_bounds->res[1] = d_bounds->b;\n  p_bounds->callback(d_bounds->arg, d_bounds->res,\n    d_bounds->iw, d_bounds->w, p_bounds->callback_data);\n  for (casadi_int i=0;i<p_bounds->nb;++i) {\n    if (d_bounds->a[i]==0) {\n      casadi_int k = p_bounds->target_g[i];\n      if (d_nlp->lbg[k]>d_bounds->b[i]) return 1;\n      if (d_nlp->ubg[k]<d_bounds->b[i]) return 1;\n    }\n  }\n  casadi_real* lbz = d_nlp->lbz+nx;\n  casadi_real* ubz = d_nlp->ubz+nx;\n  casadi_real* lam = d_nlp->lam+nx;\n  for (casadi_int i=0;i<nx;++i) {\n    d_bounds->lam_xl[i] = d_nlp->lam_x0 ? (d_nlp->lam_x0[i]<0)*d_nlp->lam_x0[i] : 0.;\n    d_bounds->lam_xu[i] = d_nlp->lam_x0 ? (d_nlp->lam_x0[i]>0)*d_nlp->lam_x0[i] : 0.;\n  }\n  for (casadi_int i=0;i<nx;++i) {\n    d_bounds->target_l[i] = i;\n    d_bounds->target_u[i] = i;\n  }\n  casadi_int k=0;\n  for (casadi_int i=0;i<p_bounds->ng;++i) {\n    if (p_bounds->is_simple[i]) {\n      casadi_real lb = (d_nlp->lbg[i]-d_bounds->b[k])/d_bounds->a[k];\n      casadi_real ub = (d_nlp->ubg[i]-d_bounds->b[k])/d_bounds->a[k];\n      if (d_bounds->a[k]<0) {\n        casadi_real tmp = lb;\n        lb = ub;\n        ub = tmp;\n      }\n      casadi_int j = p_bounds->target_x[k];\n      lb += d_nlp->z[j];\n      ub += d_nlp->z[j];\n      if (lb==d_nlp->lbz[j]) {\n        if (d_nlp->lam_g0) d_bounds->lam_xl[j] += (d_nlp->lam_g0[i]<0)*d_nlp->lam_g0[i];\n      } else if (lb>d_nlp->lbz[j]) {\n        d_nlp->lbz[j] = lb;\n        d_bounds->target_l[j] = nx+i;\n        if (d_nlp->lam_g0) d_bounds->lam_xl[j] = (d_nlp->lam_g0[i]<0)*d_nlp->lam_g0[i];\n      }\n      if (ub==d_nlp->ubz[j]) {\n        if (d_nlp->lam_g0) d_bounds->lam_xu[j] += (d_nlp->lam_g0[i]>0)*d_nlp->lam_g0[i];\n      } else if (ub<d_nlp->ubz[j]) {\n        d_nlp->ubz[j] = ub;\n        d_bounds->target_u[j] = nx+i;\n        if (d_nlp->lam_g0) d_bounds->lam_xu[j] = (d_nlp->lam_g0[i]>0)*d_nlp->lam_g0[i];\n      }\n      k++;\n    } else {\n      *lbz++ = d_nlp->lbg[i];\n      *ubz++ = d_nlp->ubg[i];\n      if (d_nlp->lam_g0) *lam++ = d_nlp->lam_g0[i];\n    }\n  }\n  for (casadi_int i=0;i<nx;++i) {\n    d_nlp->lam[i] = d_bounds->lam_xl[i]+d_bounds->lam_xu[i];\n  }\n  return 0;\n}\nint casadi_detect_bounds_after(struct casadi_nlpsol_data* d_nlp) {\n  const struct casadi_nlpsol_prob* p_nlp = d_nlp->prob;\n  struct casadi_nlpsol_detect_bounds_data* d_bounds = &d_nlp->detect_bounds;\n  const struct casadi_nlpsol_detect_bounds_prob* p_bounds = &p_nlp->detect_bounds;\n  casadi_int nx = p_nlp->nx;\n  casadi_fill(d_nlp->lam_x, nx, 0.);\n  casadi_fill(d_nlp->lam_g, p_bounds->ng, 0.);\n  casadi_int k = 0;\n  casadi_int k_normal = 0;\n  for (casadi_int i=0;i<p_bounds->ng;++i) {\n    if (p_bounds->is_simple[i]) {\n      casadi_int j = p_bounds->target_x[k];\n      if (d_nlp->g) {\n        d_nlp->g[i] = d_bounds->a[k]*d_nlp->z[j]-d_bounds->b[k];\n        if (d_nlp->x0) d_nlp->g[i] += d_nlp->x0[j];\n      }\n      k++;\n    } else {\n      if (d_nlp->g) d_nlp->g[i] = d_nlp->z[nx+k_normal];\n      if (d_nlp->lam_g) d_nlp->lam_g[i] = d_nlp->lam[nx+k_normal];\n      k_normal++;\n    }\n  }\n  for (casadi_int i=0;i<nx;++i) {\n    if (d_bounds->target_l[i]<nx) {\n      if (d_nlp->lam_x) d_nlp->lam_x[i] += (d_nlp->lam[i]<0)*d_nlp->lam[i];\n    } else {\n      if (d_nlp->lam_g)\n        d_nlp->lam_g[d_bounds->target_l[i]-nx] += (d_nlp->lam[i]<0)*d_nlp->lam[i];\n    }\n    if (d_bounds->target_u[i]<nx) {\n      if (d_nlp->lam_x) d_nlp->lam_x[i] += (d_nlp->lam[i]>0)*d_nlp->lam[i];\n    } else {\n      if (d_nlp->lam_g)\n        d_nlp->lam_g[d_bounds->target_u[i]-nx] += (d_nlp->lam[i]>0)*d_nlp->lam[i];\n    }\n  }\n  k = 0;\n  for (casadi_int i=0;i<p_bounds->ng;++i) {\n    if (p_bounds->is_simple[i]) {\n      if (d_nlp->lam_g) d_nlp->lam_g[i] /= d_bounds->a[k];\n      k++;\n    }\n  }\n  return 0;\n}\n\ncasadi_real casadi_fabs(casadi_real x) {\n/* Pre-c99 compatibility */\n#if __STDC_VERSION__ < 199901L\n  return x>0 ? x : -x;\n#else\n  return fabs(x);\n#endif\n}\n\nstruct casadi_sqpmethod_prob {\n  const struct casadi_nlpsol_prob* nlp;\n  const casadi_int *sp_h, *sp_a, *sp_hr;\n  casadi_int merit_memsize;\n  casadi_int max_iter_ls;\n};\nstruct casadi_sqpmethod_data {\n  const struct casadi_sqpmethod_prob* prob;\n  casadi_real* z_cand;\n  casadi_real *gLag, *gLag_old;\n  casadi_real *gf;\n  casadi_real *lbdz, *ubdz;\n  casadi_real *dx, *dlam;\n  casadi_real *Bk;\n  casadi_real* Jk;\n  casadi_real* merit_mem;\n  casadi_real* temp_mem;\n  casadi_real* temp_sol;\n  const casadi_real** arg;\n  casadi_real** res;\n  casadi_int* iw;\n  casadi_real* w;\n};\nvoid casadi_sqpmethod_work(const struct casadi_sqpmethod_prob* p,\n    casadi_int* sz_iw, casadi_int* sz_w, int elastic_mode, int so_corr) {\n  casadi_int nnz_h, nnz_a, nx, ng;\n  nnz_h = p->sp_h[2+p->sp_h[1]];\n  nnz_a = p->sp_a[2+p->sp_a[1]];\n  nx = p->nlp->nx;\n  ng = p->nlp->ng;\n  *sz_w = *sz_iw = 0;\n  if (p->max_iter_ls>0 || so_corr) *sz_w += nx + ng;\n  *sz_w += nx;\n  *sz_w += nx;\n  *sz_w += nx;\n  *sz_w += nx + ng;\n  *sz_w += nx + ng;\n  *sz_w += nx;\n  *sz_w += nx + ng;\n  *sz_w += nnz_h;\n  *sz_w += nnz_a;\n  if (p->max_iter_ls>0 || so_corr) *sz_w += p->merit_memsize;\n  if (elastic_mode) {\n    *sz_w += 2*ng;\n    *sz_w += 2*ng;\n    *sz_w += 2*ng;\n    *sz_w += 2*ng;\n    *sz_w += 2*ng;\n    *sz_w += 2*ng;\n    *sz_w += ng;\n  }\n  if (so_corr) *sz_w += nx+nx+ng;\n}\nvoid casadi_sqpmethod_init(struct casadi_sqpmethod_data* d,\n    const casadi_real*** arg, casadi_real*** res, casadi_int** iw, casadi_real** w,\n    int elastic_mode, int so_corr) {\n  casadi_int nnz_h, nnz_a, nx, ng;\n  const struct casadi_sqpmethod_prob* p = d->prob;\n  nnz_h = p->sp_h[2+p->sp_h[1]];\n  nnz_a = p->sp_a[2+p->sp_a[1]];\n  nx = p->nlp->nx;\n  ng = p->nlp->ng;\n  if (p->max_iter_ls>0 || so_corr) {\n    d->z_cand = *w; *w += nx + ng;\n  }\n  d->gLag = *w; *w += nx;\n  d->gLag_old = *w; *w += nx;\n  d->Bk = *w; *w += nnz_h;\n  if (p->max_iter_ls>0 || so_corr) {\n    d->merit_mem = *w; *w += p->merit_memsize;\n  }\n  if (so_corr) {\n    d->temp_sol = *w; *w += nx+nx+ng;\n  }\n  if (elastic_mode) {\n    d->gf = *w; *w += nx + 2*ng;\n    d->lbdz = *w; *w += nx + 3*ng;\n    d->ubdz = *w; *w += nx + 3*ng;\n    d->dx = *w; *w += nx + 2*ng;\n    d->dlam = *w; *w += nx + 3*ng;\n    d->Jk = *w; *w += nnz_a + 2*ng;\n    d->temp_mem = *w; *w += ng;\n  } else {\n    d->gf = *w; *w += nx;\n    d->lbdz = *w; *w += nx + ng;\n    d->ubdz = *w; *w += nx + ng;\n    d->dx = *w; *w += nx;\n    d->dlam = *w; *w += nx + ng;\n    d->Jk = *w; *w += nnz_a;\n  }\n  d->arg = *arg;\n  d->res = *res;\n  d->iw = *iw;\n  d->w = *w;\n}\n\nvoid casadi_mv(const casadi_real* x, const casadi_int* sp_x, const casadi_real* y, casadi_real* z, casadi_int tr) {\n  casadi_int ncol_x, i, el;\n  const casadi_int *colind_x, *row_x;\n  if (!x || !y || !z) return;\n  ncol_x = sp_x[1];\n  colind_x = sp_x+2; row_x = sp_x + 2 + ncol_x+1;\n  if (tr) {\n    for (i=0; i<ncol_x; ++i) {\n      for (el=colind_x[i]; el<colind_x[i+1]; ++el) {\n        z[i] += x[el] * y[row_x[el]];\n      }\n    }\n  } else {\n    for (i=0; i<ncol_x; ++i) {\n      for (el=colind_x[i]; el<colind_x[i+1]; ++el) {\n        z[row_x[el]] += x[el] * y[i];\n      }\n    }\n  }\n}\n\nvoid casadi_axpy(casadi_int n, casadi_real alpha, const casadi_real* x, casadi_real* y) {\n  casadi_int i;\n  if (!x || !y) return;\n  for (i=0; i<n; ++i) *y++ += alpha**x++;\n}\n\ncasadi_real casadi_fmax(casadi_real x, casadi_real y) {\n/* Pre-c99 compatibility */\n#if __STDC_VERSION__ < 199901L\n  return x>y ? x : y;\n#else\n  return fmax(x, y);\n#endif\n}\n\ncasadi_real casadi_max_viol(casadi_int n, const casadi_real* x, const casadi_real* lb, const casadi_real* ub) {\n  casadi_real r;\n  casadi_int i;\n  const casadi_real zero = 0;\n  r = 0;\n  for (i=0; i<n; ++i) {\n    casadi_real x_i, lb_i, ub_i;\n    x_i = x ? *x++ : zero;\n    lb_i = lb ? *lb++ : zero;\n    ub_i = ub ? *ub++ : zero;\n    r = casadi_fmax(r, casadi_fmax(x_i-ub_i, zero));\n    r = casadi_fmax(r, casadi_fmax(lb_i-x_i, zero));\n  }\n  return r;\n}\n\ncasadi_real casadi_norm_inf(casadi_int n, const casadi_real* x) {\n  casadi_int i;\n  casadi_real ret = 0;\n  for (i=0; i<n; ++i) ret = casadi_fmax(ret, fabs(*x++));\n  return ret;\n}\n\ncasadi_real casadi_sum_viol(casadi_int n, const casadi_real* x, const casadi_real* lb, const casadi_real* ub) {\n  casadi_real r;\n  casadi_int i;\n  const casadi_real zero = 0;\n  r = 0;\n  for (i=0; i<n; ++i) {\n    casadi_real x_i, lb_i, ub_i;\n    x_i = x ? *x++ : zero;\n    lb_i = lb ? *lb++ : zero;\n    ub_i = ub ? *ub++ : zero;\n    r += casadi_fmax(x_i-ub_i, zero);\n    r += casadi_fmax(lb_i-x_i, zero);\n  }\n  return r;\n}\n\nvoid casadi_scal(casadi_int n, casadi_real alpha, casadi_real* x) {\n  casadi_int i;\n  if (!x) return;\n  for (i=0; i<n; ++i) *x++ *= alpha;\n}\n\nstatic int casadi_f1_mem_counter = 0;\nstatic int casadi_f1_unused_stack_counter = -1;\nstatic int casadi_f1_unused_stack[CASADI_MAX_NUM_THREADS];\nstatic struct casadi_sqpmethod_data casadi_f1_mem[CASADI_MAX_NUM_THREADS];\n\nstatic const casadi_int casadi_s0[16] = \n  {14, 1, 0, 12, 2, 3, 4, 5,\n  6, 7, 8, 9, 10, 11, 12, 13};\nstatic const casadi_int casadi_s1[6] = {2, 1, 0, 2, 0, 1};\nstatic const casadi_int casadi_s2[5] = {2, 1, 0, 1, 0};\nstatic const casadi_int casadi_s3[9] = \n  {2, 2, 0, 2, 4, 0, 1, 0,\n  1};\nstatic const casadi_int casadi_s4[9] = \n  {0, 2, 6, 14, 22, 26, 34, 42,\n  46};\nstatic const casadi_int casadi_s5[5] = {2, 1, 0, 1, 1};\nstatic const casadi_int casadi_s6[9] = \n  {1, 3, 7, 18, 23, 27, 38, 43,\n  47};\nstatic const casadi_int casadi_s7[8] = {4, 12, 16, 24, 32, 36, 44, 48};\nstatic const casadi_int casadi_s8[10] = \n  {8, 13, 17, 28, 33, 37, 45, 49,\n  50, 51};\nstatic const casadi_int casadi_s9[16] = \n  {5, 9, 10, 11, 15, 19, 20, 21,\n  25, 29, 30, 31, 35, 39, 40, 41};\nstatic const casadi_int casadi_s10[72] = \n  {22, 17, 0, 3, 6, 9, 12, 15,\n  18, 21, 24, 27, 30, 31, 32, 36,\n  40, 44, 48, 52, 0, 2, 3, 1,\n  2, 3, 2, 6, 7, 3, 6, 7,\n  6, 10, 11, 7, 10, 11, 10, 14,\n  15, 11, 14, 15, 14, 18, 19, 15,\n  18, 19, 18, 19, 2, 3, 4, 5,\n  6, 7, 8, 9, 10, 11, 12, 13,\n  14, 15, 16, 17, 18, 19, 20, 21};\nstatic const casadi_int casadi_s11[77] = \n  {17, 22, 0, 1, 2, 6, 10, 11,\n  12, 16, 20, 21, 22, 26, 30, 31,\n  32, 36, 40, 41, 42, 46, 50, 51,\n  52, 0, 1, 0, 1, 2, 12, 0,\n  1, 3, 12, 12, 12, 2, 3, 4,\n  13, 2, 3, 5, 13, 13, 13, 4,\n  5, 6, 14, 4, 5, 7, 14, 14,\n  14, 6, 7, 8, 15, 6, 7, 9,\n  15, 15, 15, 8, 9, 10, 16, 8,\n  9, 11, 16, 16, 16};\nstatic const casadi_int casadi_s12[7] = {1, 2, 0, 1, 2, 0, 0};\nstatic const casadi_int casadi_s13[6] = {1, 2, 0, 1, 1, 0};\nstatic const casadi_int casadi_s14[17] = \n  {0, 1, 4, 5, 8, 9, 12, 13,\n  16, 17, 20, 21, 24, 25, 26, 27,\n  28};\nstatic const casadi_int casadi_s15[17] = \n  {0, 2, 4, 6, 8, 10, 12, 14,\n  16, 18, 20, 22, 24, 25, 26, 27,\n  28};\nstatic const casadi_int casadi_s16[6] = {1, 2, 0, 0, 1, 0};\nstatic const casadi_int casadi_s17[49] = \n  {17, 17, 0, 2, 4, 6, 8, 10,\n  12, 14, 16, 18, 20, 22, 24, 25,\n  26, 27, 28, 29, 0, 1, 0, 1,\n  2, 3, 2, 3, 4, 5, 4, 5,\n  6, 7, 6, 7, 8, 9, 8, 9,\n  10, 11, 10, 11, 12, 13, 14, 15,\n  16};\nstatic const casadi_int casadi_s18[18] = \n  {0, 3, 6, 9, 12, 15, 18, 21,\n  24, 27, 30, 31, 32, 36, 40, 44,\n  48, 52};\nstatic const casadi_int casadi_s19[69] = \n  {0, 17, 19, 20, 1, 18, 19, 20,\n  2, 19, 23, 24, 3, 20, 23, 24,\n  4, 23, 27, 28, 5, 24, 27, 28,\n  6, 27, 31, 32, 7, 28, 31, 32,\n  8, 31, 35, 36, 9, 32, 35, 36,\n  10, 35, 11, 36, 12, 19, 20, 21,\n  22, 13, 23, 24, 25, 26, 14, 27,\n  28, 29, 30, 15, 31, 32, 33, 34,\n  16, 35, 36, 37, 38};\nstatic const casadi_int casadi_s20[18] = \n  {0, 4, 8, 12, 16, 20, 24, 28,\n  32, 36, 40, 42, 44, 49, 54, 59,\n  64, 69};\nstatic const casadi_int casadi_s21[23] = \n  {0, 0, 1, 2, 2, 3, 4, 4,\n  5, 6, 6, 7, 8, 8, 9, 10,\n  10, 11, 12, 13, 14, 15, 16};\nstatic const casadi_int casadi_s22[18] = \n  {0, 1, 3, 4, 6, 7, 9, 10,\n  12, 13, 15, 16, 18, 19, 20, 21,\n  22, 23};\nstatic const casadi_int casadi_s23[3] = {2, 1, 1};\nstatic const casadi_int casadi_s24[3] = {2, 6, 1};\nstatic const casadi_int casadi_s25[3] = {1, 1, 1};\n\nstatic const casadi_real casadi_c0[4] = {500., 0., 0., 1.};\nstatic const casadi_real casadi_c1[4] = {5000., 0., 0., 10.};\nstatic const casadi_real casadi_c2[4] = {1., 0., 1.8117356846526805e-02, 8.1783684537750823e-01};\nstatic const casadi_real casadi_c3[2] = {4.4824836987457060e-02, 4.3372179672021867e+00};\n\nstatic const casadi_real casadi_zeros[22] = \n  {0., 0., 0., 0., 0., 0., 0., 0.,\n  0., 0., 0., 0., 0., 0., 0., 0.,\n  0., 0., 0., 0., 0., 0.};\n\n/* nlp_grad:(x[17],p[14],lam_f,lam_g[22])->(f,g[22],grad_gamma_x[17],grad_gamma_p[14]) */\nstatic int casadi_f2(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {\n  casadi_int i, j, k;\n  casadi_real *rr, w00, *w01=w+3, *w02=w+5, *w03=w+17, *w04=w+19, *w05=w+31, *w06=w+33, *w07=w+37, w08, w09, *w10=w+44;\n  casadi_real *w11=w+46, *w12=w+48, w13, *w14=w+53, *w15=w+55, *w16=w+57, w17, *w18=w+62, *w19=w+64, *w20=w+66, w21, *w22=w+71;\n  casadi_real *w23=w+73, *w24=w+75, w25, *w26=w+80, *w27=w+82, *w28=w+84, *w29=w+88, *w30=w+90, *w31=w+94, *w32=w+96, *w33=w+98, *w34=w+102;\n  casadi_real *w35=w+104, *w36=w+108, *w37=w+110, *w38=w+114, *w39=w+116, *w40=w+120, *w41=w+122, *w43=w+148, w44, w45, *w46=w+152, w47;\n  casadi_real w48, *w49=w+156, w50, w51, *w52=w+160, w53, w54, *w55=w+164, w56, *w58=w+167;\n  const casadi_real *cr, *cs, *ct, *wr02, *wr03, *wr04, *wr05, *wr10, *wr11, *wr14, *wr15, *wr18;\n  const casadi_real *wr19, *wr22, *wr23, *wr26, *wr27, *wr29, *wr31, *wr32, *wr34, *wr36, *wr38, *wr40;\n  const casadi_real *wr42, *wr43, *wr46, *wr49, *wr52;\n  /* #0: @0 = 0 */\n  w00 = 0.;\n  /* #1: @1 = zeros(1x2) */\n  casadi_clear(w01, 2);\n  /* #2: @2 = input[0][0] */\n  wr02 = arg[0] ? arg[0] : casadi_zeros;\n  /* #3: @3 = @2[:2] */\n  wr03 = wr02+0;\n  /* #4: @4 = input[1][1] */\n  wr04 = arg[1] ? arg[1]+2 : casadi_zeros;\n  /* #5: @5 = @4[:2] */\n  wr05 = wr04+0;\n  /* #6: @3 = (@3-@5) */\n  for (i=0, rr=w03, cr=wr03, cs=wr05; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #7: @3 = @3' */\n  /* #8: @6 = \n  [[500, 0], \n   [0, 1]] */\n  casadi_copy(casadi_c0, 4, w06);\n  /* #9: @1 = mac(@3,@6,@1) */\n  for (i=0, rr=w01; i<2; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w03+j, ct=w06+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #10: @3 = @2[:2] */\n  wr03 = wr02+0;\n  /* #11: @5 = @4[:2] */\n  wr05 = wr04+0;\n  /* #12: @3 = (@3-@5) */\n  for (i=0, rr=w03, cr=wr03, cs=wr05; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #13: @0 = mac(@1,@3,@0) */\n  for (i=0, rr=(&w00); i<1; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w01+j, ct=w03+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #14: @7 = input[0][1] */\n  casadi_copy(arg[0] ? arg[0]+12 : 0, 5, w07);\n  /* #15: @8 = @7[0] */\n  for (rr=(&w08), cs=w07+0; cs!=w07+1; cs+=1) *rr++ = *cs;\n  /* #16: @9 = sq(@8) */\n  w09 = casadi_sq( w08 );\n  /* #17: @0 = (@0+@9) */\n  w00 += w09;\n  /* #18: @9 = 0 */\n  w09 = 0.;\n  /* #19: @5 = zeros(1x2) */\n  casadi_clear(w05, 2);\n  /* #20: @10 = @2[2:4] */\n  wr10 = wr02+2;\n  /* #21: @11 = @4[2:4] */\n  wr11 = wr04+2;\n  /* #22: @10 = (@10-@11) */\n  for (i=0, rr=w10, cr=wr10, cs=wr11; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #23: @10 = @10' */\n  /* #24: @12 = \n  [[500, 0], \n   [0, 1]] */\n  casadi_copy(casadi_c0, 4, w12);\n  /* #25: @5 = mac(@10,@12,@5) */\n  for (i=0, rr=w05; i<2; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w10+j, ct=w12+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #26: @10 = @2[2:4] */\n  wr10 = wr02+2;\n  /* #27: @11 = @4[2:4] */\n  wr11 = wr04+2;\n  /* #28: @10 = (@10-@11) */\n  for (i=0, rr=w10, cr=wr10, cs=wr11; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #29: @9 = mac(@5,@10,@9) */\n  for (i=0, rr=(&w09); i<1; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w05+j, ct=w10+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #30: @0 = (@0+@9) */\n  w00 += w09;\n  /* #31: @9 = @7[1] */\n  for (rr=(&w09), cs=w07+1; cs!=w07+2; cs+=1) *rr++ = *cs;\n  /* #32: @13 = sq(@9) */\n  w13 = casadi_sq( w09 );\n  /* #33: @0 = (@0+@13) */\n  w00 += w13;\n  /* #34: @13 = 0 */\n  w13 = 0.;\n  /* #35: @11 = zeros(1x2) */\n  casadi_clear(w11, 2);\n  /* #36: @14 = @2[4:6] */\n  wr14 = wr02+4;\n  /* #37: @15 = @4[4:6] */\n  wr15 = wr04+4;\n  /* #38: @14 = (@14-@15) */\n  for (i=0, rr=w14, cr=wr14, cs=wr15; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #39: @14 = @14' */\n  /* #40: @16 = \n  [[500, 0], \n   [0, 1]] */\n  casadi_copy(casadi_c0, 4, w16);\n  /* #41: @11 = mac(@14,@16,@11) */\n  for (i=0, rr=w11; i<2; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w14+j, ct=w16+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #42: @14 = @2[4:6] */\n  wr14 = wr02+4;\n  /* #43: @15 = @4[4:6] */\n  wr15 = wr04+4;\n  /* #44: @14 = (@14-@15) */\n  for (i=0, rr=w14, cr=wr14, cs=wr15; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #45: @13 = mac(@11,@14,@13) */\n  for (i=0, rr=(&w13); i<1; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w11+j, ct=w14+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #46: @0 = (@0+@13) */\n  w00 += w13;\n  /* #47: @13 = @7[2] */\n  for (rr=(&w13), cs=w07+2; cs!=w07+3; cs+=1) *rr++ = *cs;\n  /* #48: @17 = sq(@13) */\n  w17 = casadi_sq( w13 );\n  /* #49: @0 = (@0+@17) */\n  w00 += w17;\n  /* #50: @17 = 0 */\n  w17 = 0.;\n  /* #51: @15 = zeros(1x2) */\n  casadi_clear(w15, 2);\n  /* #52: @18 = @2[6:8] */\n  wr18 = wr02+6;\n  /* #53: @19 = @4[6:8] */\n  wr19 = wr04+6;\n  /* #54: @18 = (@18-@19) */\n  for (i=0, rr=w18, cr=wr18, cs=wr19; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #55: @18 = @18' */\n  /* #56: @20 = \n  [[500, 0], \n   [0, 1]] */\n  casadi_copy(casadi_c0, 4, w20);\n  /* #57: @15 = mac(@18,@20,@15) */\n  for (i=0, rr=w15; i<2; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w18+j, ct=w20+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #58: @18 = @2[6:8] */\n  wr18 = wr02+6;\n  /* #59: @19 = @4[6:8] */\n  wr19 = wr04+6;\n  /* #60: @18 = (@18-@19) */\n  for (i=0, rr=w18, cr=wr18, cs=wr19; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #61: @17 = mac(@15,@18,@17) */\n  for (i=0, rr=(&w17); i<1; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w15+j, ct=w18+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #62: @0 = (@0+@17) */\n  w00 += w17;\n  /* #63: @17 = @7[3] */\n  for (rr=(&w17), cs=w07+3; cs!=w07+4; cs+=1) *rr++ = *cs;\n  /* #64: @21 = sq(@17) */\n  w21 = casadi_sq( w17 );\n  /* #65: @0 = (@0+@21) */\n  w00 += w21;\n  /* #66: @21 = 0 */\n  w21 = 0.;\n  /* #67: @19 = zeros(1x2) */\n  casadi_clear(w19, 2);\n  /* #68: @22 = @2[8:10] */\n  wr22 = wr02+8;\n  /* #69: @23 = @4[8:10] */\n  wr23 = wr04+8;\n  /* #70: @22 = (@22-@23) */\n  for (i=0, rr=w22, cr=wr22, cs=wr23; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #71: @22 = @22' */\n  /* #72: @24 = \n  [[500, 0], \n   [0, 1]] */\n  casadi_copy(casadi_c0, 4, w24);\n  /* #73: @19 = mac(@22,@24,@19) */\n  for (i=0, rr=w19; i<2; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w22+j, ct=w24+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #74: @22 = @2[8:10] */\n  wr22 = wr02+8;\n  /* #75: @23 = @4[8:10] */\n  wr23 = wr04+8;\n  /* #76: @22 = (@22-@23) */\n  for (i=0, rr=w22, cr=wr22, cs=wr23; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #77: @21 = mac(@19,@22,@21) */\n  for (i=0, rr=(&w21); i<1; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w19+j, ct=w22+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #78: @0 = (@0+@21) */\n  w00 += w21;\n  /* #79: @21 = @7[4] */\n  for (rr=(&w21), cs=w07+4; cs!=w07+5; cs+=1) *rr++ = *cs;\n  /* #80: @25 = sq(@21) */\n  w25 = casadi_sq( w21 );\n  /* #81: @0 = (@0+@25) */\n  w00 += w25;\n  /* #82: @25 = 0 */\n  w25 = 0.;\n  /* #83: @23 = zeros(1x2) */\n  casadi_clear(w23, 2);\n  /* #84: @26 = @2[10:12] */\n  wr26 = wr02+10;\n  /* #85: @27 = @4[10:12] */\n  wr27 = wr04+10;\n  /* #86: @26 = (@26-@27) */\n  for (i=0, rr=w26, cr=wr26, cs=wr27; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #87: @26 = @26' */\n  /* #88: @28 = \n  [[5000, 0], \n   [0, 10]] */\n  casadi_copy(casadi_c1, 4, w28);\n  /* #89: @23 = mac(@26,@28,@23) */\n  for (i=0, rr=w23; i<2; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w26+j, ct=w28+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #90: @26 = @2[10:12] */\n  wr26 = wr02+10;\n  /* #91: @27 = @4[10:12] */\n  wr27 = wr04+10;\n  /* #92: @26 = (@26-@27) */\n  for (i=0, rr=w26, cr=wr26, cs=wr27; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #93: @25 = mac(@23,@26,@25) */\n  for (i=0, rr=(&w25); i<1; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w23+j, ct=w26+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #94: @0 = (@0+@25) */\n  w00 += w25;\n  /* #95: output[0][0] = @0 */\n  if (res[0]) res[0][0] = w00;\n  /* #96: @27 = @2[:2] */\n  wr27 = wr02+0;\n  /* #97: output[1][0] = @27 */\n  casadi_copy(wr27, 2, res[1]);\n  /* #98: @27 = @2[2:4] */\n  wr27 = wr02+2;\n  /* #99: @29 = zeros(2x1) */\n  casadi_clear(w29, 2);\n  /* #100: @30 = \n  [[1, 0.0181174], \n   [0, 0.817837]] */\n  casadi_copy(casadi_c2, 4, w30);\n  /* #101: @31 = @2[:2] */\n  wr31 = wr02+0;\n  /* #102: @29 = mac(@30,@31,@29) */\n  for (i=0, rr=w29; i<1; ++i) for (j=0; j<2; ++j, ++rr) for (k=0, cs=w30+j, ct=wr31+i*2; k<2; ++k) *rr += cs[k*2]**ct++;\n  /* #103: @31 = [0.0448248, 4.33722] */\n  casadi_copy(casadi_c3, 2, w31);\n  /* #104: @0 = @7[0] */\n  for (rr=(&w00), cs=w07+0; cs!=w07+1; cs+=1) *rr++ = *cs;\n  /* #105: @32 = (@31*@0) */\n  for (i=0, rr=w32, cr=w31; i<2; ++i) (*rr++)  = ((*cr++)*w00);\n  /* #106: @29 = (@29+@32) */\n  for (i=0, rr=w29, cs=w32; i<2; ++i) (*rr++) += (*cs++);\n  /* #107: @27 = (@27-@29) */\n  for (i=0, rr=w27, cr=wr27, cs=w29; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #108: output[1][1] = @27 */\n  if (res[1]) casadi_copy(w27, 2, res[1]+2);\n  /* #109: @0 = @7[0] */\n  for (rr=(&w00), cs=w07+0; cs!=w07+1; cs+=1) *rr++ = *cs;\n  /* #110: output[1][2] = @0 */\n  if (res[1]) res[1][4] = w00;\n  /* #111: @0 = @7[0] */\n  for (rr=(&w00), cs=w07+0; cs!=w07+1; cs+=1) *rr++ = *cs;\n  /* #112: output[1][3] = @0 */\n  if (res[1]) res[1][5] = w00;\n  /* #113: @27 = @2[4:6] */\n  wr27 = wr02+4;\n  /* #114: @29 = zeros(2x1) */\n  casadi_clear(w29, 2);\n  /* #115: @33 = \n  [[1, 0.0181174], \n   [0, 0.817837]] */\n  casadi_copy(casadi_c2, 4, w33);\n  /* #116: @32 = @2[2:4] */\n  wr32 = wr02+2;\n  /* #117: @29 = mac(@33,@32,@29) */\n  for (i=0, rr=w29; i<1; ++i) for (j=0; j<2; ++j, ++rr) for (k=0, cs=w33+j, ct=wr32+i*2; k<2; ++k) *rr += cs[k*2]**ct++;\n  /* #118: @32 = [0.0448248, 4.33722] */\n  casadi_copy(casadi_c3, 2, w32);\n  /* #119: @0 = @7[1] */\n  for (rr=(&w00), cs=w07+1; cs!=w07+2; cs+=1) *rr++ = *cs;\n  /* #120: @34 = (@32*@0) */\n  for (i=0, rr=w34, cr=w32; i<2; ++i) (*rr++)  = ((*cr++)*w00);\n  /* #121: @29 = (@29+@34) */\n  for (i=0, rr=w29, cs=w34; i<2; ++i) (*rr++) += (*cs++);\n  /* #122: @27 = (@27-@29) */\n  for (i=0, rr=w27, cr=wr27, cs=w29; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #123: output[1][4] = @27 */\n  if (res[1]) casadi_copy(w27, 2, res[1]+6);\n  /* #124: @0 = @7[1] */\n  for (rr=(&w00), cs=w07+1; cs!=w07+2; cs+=1) *rr++ = *cs;\n  /* #125: output[1][5] = @0 */\n  if (res[1]) res[1][8] = w00;\n  /* #126: @0 = @7[1] */\n  for (rr=(&w00), cs=w07+1; cs!=w07+2; cs+=1) *rr++ = *cs;\n  /* #127: output[1][6] = @0 */\n  if (res[1]) res[1][9] = w00;\n  /* #128: @27 = @2[6:8] */\n  wr27 = wr02+6;\n  /* #129: @29 = zeros(2x1) */\n  casadi_clear(w29, 2);\n  /* #130: @35 = \n  [[1, 0.0181174], \n   [0, 0.817837]] */\n  casadi_copy(casadi_c2, 4, w35);\n  /* #131: @34 = @2[4:6] */\n  wr34 = wr02+4;\n  /* #132: @29 = mac(@35,@34,@29) */\n  for (i=0, rr=w29; i<1; ++i) for (j=0; j<2; ++j, ++rr) for (k=0, cs=w35+j, ct=wr34+i*2; k<2; ++k) *rr += cs[k*2]**ct++;\n  /* #133: @34 = [0.0448248, 4.33722] */\n  casadi_copy(casadi_c3, 2, w34);\n  /* #134: @0 = @7[2] */\n  for (rr=(&w00), cs=w07+2; cs!=w07+3; cs+=1) *rr++ = *cs;\n  /* #135: @36 = (@34*@0) */\n  for (i=0, rr=w36, cr=w34; i<2; ++i) (*rr++)  = ((*cr++)*w00);\n  /* #136: @29 = (@29+@36) */\n  for (i=0, rr=w29, cs=w36; i<2; ++i) (*rr++) += (*cs++);\n  /* #137: @27 = (@27-@29) */\n  for (i=0, rr=w27, cr=wr27, cs=w29; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #138: output[1][7] = @27 */\n  if (res[1]) casadi_copy(w27, 2, res[1]+10);\n  /* #139: @0 = @7[2] */\n  for (rr=(&w00), cs=w07+2; cs!=w07+3; cs+=1) *rr++ = *cs;\n  /* #140: output[1][8] = @0 */\n  if (res[1]) res[1][12] = w00;\n  /* #141: @0 = @7[2] */\n  for (rr=(&w00), cs=w07+2; cs!=w07+3; cs+=1) *rr++ = *cs;\n  /* #142: output[1][9] = @0 */\n  if (res[1]) res[1][13] = w00;\n  /* #143: @27 = @2[8:10] */\n  wr27 = wr02+8;\n  /* #144: @29 = zeros(2x1) */\n  casadi_clear(w29, 2);\n  /* #145: @37 = \n  [[1, 0.0181174], \n   [0, 0.817837]] */\n  casadi_copy(casadi_c2, 4, w37);\n  /* #146: @36 = @2[6:8] */\n  wr36 = wr02+6;\n  /* #147: @29 = mac(@37,@36,@29) */\n  for (i=0, rr=w29; i<1; ++i) for (j=0; j<2; ++j, ++rr) for (k=0, cs=w37+j, ct=wr36+i*2; k<2; ++k) *rr += cs[k*2]**ct++;\n  /* #148: @36 = [0.0448248, 4.33722] */\n  casadi_copy(casadi_c3, 2, w36);\n  /* #149: @0 = @7[3] */\n  for (rr=(&w00), cs=w07+3; cs!=w07+4; cs+=1) *rr++ = *cs;\n  /* #150: @38 = (@36*@0) */\n  for (i=0, rr=w38, cr=w36; i<2; ++i) (*rr++)  = ((*cr++)*w00);\n  /* #151: @29 = (@29+@38) */\n  for (i=0, rr=w29, cs=w38; i<2; ++i) (*rr++) += (*cs++);\n  /* #152: @27 = (@27-@29) */\n  for (i=0, rr=w27, cr=wr27, cs=w29; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #153: output[1][10] = @27 */\n  if (res[1]) casadi_copy(w27, 2, res[1]+14);\n  /* #154: @0 = @7[3] */\n  for (rr=(&w00), cs=w07+3; cs!=w07+4; cs+=1) *rr++ = *cs;\n  /* #155: output[1][11] = @0 */\n  if (res[1]) res[1][16] = w00;\n  /* #156: @0 = @7[3] */\n  for (rr=(&w00), cs=w07+3; cs!=w07+4; cs+=1) *rr++ = *cs;\n  /* #157: output[1][12] = @0 */\n  if (res[1]) res[1][17] = w00;\n  /* #158: @27 = @2[10:12] */\n  wr27 = wr02+10;\n  /* #159: @29 = zeros(2x1) */\n  casadi_clear(w29, 2);\n  /* #160: @39 = \n  [[1, 0.0181174], \n   [0, 0.817837]] */\n  casadi_copy(casadi_c2, 4, w39);\n  /* #161: @38 = @2[8:10] */\n  wr38 = wr02+8;\n  /* #162: @29 = mac(@39,@38,@29) */\n  for (i=0, rr=w29; i<1; ++i) for (j=0; j<2; ++j, ++rr) for (k=0, cs=w39+j, ct=wr38+i*2; k<2; ++k) *rr += cs[k*2]**ct++;\n  /* #163: @38 = [0.0448248, 4.33722] */\n  casadi_copy(casadi_c3, 2, w38);\n  /* #164: @0 = @7[4] */\n  for (rr=(&w00), cs=w07+4; cs!=w07+5; cs+=1) *rr++ = *cs;\n  /* #165: @40 = (@38*@0) */\n  for (i=0, rr=w40, cr=w38; i<2; ++i) (*rr++)  = ((*cr++)*w00);\n  /* #166: @29 = (@29+@40) */\n  for (i=0, rr=w29, cs=w40; i<2; ++i) (*rr++) += (*cs++);\n  /* #167: @27 = (@27-@29) */\n  for (i=0, rr=w27, cr=wr27, cs=w29; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #168: output[1][13] = @27 */\n  if (res[1]) casadi_copy(w27, 2, res[1]+18);\n  /* #169: @0 = @7[4] */\n  for (rr=(&w00), cs=w07+4; cs!=w07+5; cs+=1) *rr++ = *cs;\n  /* #170: output[1][14] = @0 */\n  if (res[1]) res[1][20] = w00;\n  /* #171: @0 = @7[4] */\n  for (rr=(&w00), cs=w07+4; cs!=w07+5; cs+=1) *rr++ = *cs;\n  /* #172: output[1][15] = @0 */\n  if (res[1]) res[1][21] = w00;\n  /* #173: @2 = zeros(2x6) */\n  casadi_clear(w02, 12);\n  /* #174: @27 = zeros(2x1) */\n  casadi_clear(w27, 2);\n  /* #175: @41 = @39' */\n  for (i=0, rr=w41, cs=w39; i<2; ++i) for (j=0; j<2; ++j) rr[i+j*2] = *cs++;\n  /* #176: @42 = input[3][0] */\n  wr42 = arg[3] ? arg[3] : casadi_zeros;\n  /* #177: {@29, @40, @0, @25, @43, @44, @45, @46, @47, @48, @49, @50, @51, @52, @53, @54} = vertsplit(@42) */\n  wr29 = wr42;\n  wr40 = wr42+2;\n  w00 = wr42[4];\n  w25 = wr42[5];\n  wr43 = wr42+6;\n  w44 = wr42[8];\n  w45 = wr42[9];\n  wr46 = wr42+10;\n  w47 = wr42[12];\n  w48 = wr42[13];\n  wr49 = wr42+14;\n  w50 = wr42[16];\n  w51 = wr42[17];\n  wr52 = wr42+18;\n  w53 = wr42[20];\n  w54 = wr42[21];\n  /* #178: @55 = (-@52) */\n  for (i=0, rr=w55, cs=wr52; i<2; ++i) *rr++ = (- *cs++ );\n  /* #179: @27 = mac(@41,@55,@27) */\n  for (i=0, rr=w27; i<1; ++i) for (j=0; j<2; ++j, ++rr) for (k=0, cs=w41+j, ct=w55+i*2; k<2; ++k) *rr += cs[k*2]**ct++;\n  /* #180: (@2[8:10] += @27) */\n  for (rr=w02+8, cs=w27; rr!=w02+10; rr+=1) *rr += *cs++;\n  /* #181: (@2[10:12] += @52) */\n  for (rr=w02+10, cs=wr52; rr!=w02+12; rr+=1) *rr += *cs++;\n  /* #182: @52 = zeros(2x1) */\n  casadi_clear(w52, 2);\n  /* #183: @41 = @37' */\n  for (i=0, rr=w41, cs=w37; i<2; ++i) for (j=0; j<2; ++j) rr[i+j*2] = *cs++;\n  /* #184: @27 = (-@49) */\n  for (i=0, rr=w27, cs=wr49; i<2; ++i) *rr++ = (- *cs++ );\n  /* #185: @52 = mac(@41,@27,@52) */\n  for (i=0, rr=w52; i<1; ++i) for (j=0; j<2; ++j, ++rr) for (k=0, cs=w41+j, ct=w27+i*2; k<2; ++k) *rr += cs[k*2]**ct++;\n  /* #186: (@2[6:8] += @52) */\n  for (rr=w02+6, cs=w52; rr!=w02+8; rr+=1) *rr += *cs++;\n  /* #187: (@2[8:10] += @49) */\n  for (rr=w02+8, cs=wr49; rr!=w02+10; rr+=1) *rr += *cs++;\n  /* #188: @49 = zeros(2x1) */\n  casadi_clear(w49, 2);\n  /* #189: @41 = @35' */\n  for (i=0, rr=w41, cs=w35; i<2; ++i) for (j=0; j<2; ++j) rr[i+j*2] = *cs++;\n  /* #190: @52 = (-@46) */\n  for (i=0, rr=w52, cs=wr46; i<2; ++i) *rr++ = (- *cs++ );\n  /* #191: @49 = mac(@41,@52,@49) */\n  for (i=0, rr=w49; i<1; ++i) for (j=0; j<2; ++j, ++rr) for (k=0, cs=w41+j, ct=w52+i*2; k<2; ++k) *rr += cs[k*2]**ct++;\n  /* #192: (@2[4:6] += @49) */\n  for (rr=w02+4, cs=w49; rr!=w02+6; rr+=1) *rr += *cs++;\n  /* #193: (@2[6:8] += @46) */\n  for (rr=w02+6, cs=wr46; rr!=w02+8; rr+=1) *rr += *cs++;\n  /* #194: @46 = zeros(2x1) */\n  casadi_clear(w46, 2);\n  /* #195: @41 = @33' */\n  for (i=0, rr=w41, cs=w33; i<2; ++i) for (j=0; j<2; ++j) rr[i+j*2] = *cs++;\n  /* #196: @49 = (-@43) */\n  for (i=0, rr=w49, cs=wr43; i<2; ++i) *rr++ = (- *cs++ );\n  /* #197: @46 = mac(@41,@49,@46) */\n  for (i=0, rr=w46; i<1; ++i) for (j=0; j<2; ++j, ++rr) for (k=0, cs=w41+j, ct=w49+i*2; k<2; ++k) *rr += cs[k*2]**ct++;\n  /* #198: (@2[2:4] += @46) */\n  for (rr=w02+2, cs=w46; rr!=w02+4; rr+=1) *rr += *cs++;\n  /* #199: (@2[4:6] += @43) */\n  for (rr=w02+4, cs=wr43; rr!=w02+6; rr+=1) *rr += *cs++;\n  /* #200: @43 = zeros(2x1) */\n  casadi_clear(w43, 2);\n  /* #201: @41 = @30' */\n  for (i=0, rr=w41, cs=w30; i<2; ++i) for (j=0; j<2; ++j) rr[i+j*2] = *cs++;\n  /* #202: @46 = (-@40) */\n  for (i=0, rr=w46, cs=wr40; i<2; ++i) *rr++ = (- *cs++ );\n  /* #203: @43 = mac(@41,@46,@43) */\n  for (i=0, rr=w43; i<1; ++i) for (j=0; j<2; ++j, ++rr) for (k=0, cs=w41+j, ct=w46+i*2; k<2; ++k) *rr += cs[k*2]**ct++;\n  /* #204: (@2[:2] += @43) */\n  for (rr=w02+0, cs=w43; rr!=w02+2; rr+=1) *rr += *cs++;\n  /* #205: (@2[2:4] += @40) */\n  for (rr=w02+2, cs=wr40; rr!=w02+4; rr+=1) *rr += *cs++;\n  /* #206: (@2[:2] += @29) */\n  for (rr=w02+0, cs=wr29; rr!=w02+2; rr+=1) *rr += *cs++;\n  /* #207: @29 = @23' */\n  casadi_copy(w23, 2, w29);\n  /* #208: @56 = input[2][0] */\n  w56 = arg[2] ? arg[2][0] : 0;\n  /* #209: @29 = (@29*@56) */\n  for (i=0, rr=w29; i<2; ++i) (*rr++) *= w56;\n  /* #210: (@2[10:12] += @29) */\n  for (rr=w02+10, cs=w29; rr!=w02+12; rr+=1) *rr += *cs++;\n  /* #211: @29 = zeros(1x2) */\n  casadi_clear(w29, 2);\n  /* #212: @40 = @26' */\n  casadi_copy(w26, 2, w40);\n  /* #213: @40 = (@56*@40) */\n  for (i=0, rr=w40, cs=w40; i<2; ++i) (*rr++)  = (w56*(*cs++));\n  /* #214: @41 = @28' */\n  for (i=0, rr=w41, cs=w28; i<2; ++i) for (j=0; j<2; ++j) rr[i+j*2] = *cs++;\n  /* #215: @29 = mac(@40,@41,@29) */\n  for (i=0, rr=w29; i<2; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w40+j, ct=w41+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #216: @29 = @29' */\n  /* #217: (@2[10:12] += @29) */\n  for (rr=w02+10, cs=w29; rr!=w02+12; rr+=1) *rr += *cs++;\n  /* #218: @29 = @19' */\n  casadi_copy(w19, 2, w29);\n  /* #219: @29 = (@29*@56) */\n  for (i=0, rr=w29; i<2; ++i) (*rr++) *= w56;\n  /* #220: (@2[8:10] += @29) */\n  for (rr=w02+8, cs=w29; rr!=w02+10; rr+=1) *rr += *cs++;\n  /* #221: @29 = zeros(1x2) */\n  casadi_clear(w29, 2);\n  /* #222: @40 = @22' */\n  casadi_copy(w22, 2, w40);\n  /* #223: @40 = (@56*@40) */\n  for (i=0, rr=w40, cs=w40; i<2; ++i) (*rr++)  = (w56*(*cs++));\n  /* #224: @41 = @24' */\n  for (i=0, rr=w41, cs=w24; i<2; ++i) for (j=0; j<2; ++j) rr[i+j*2] = *cs++;\n  /* #225: @29 = mac(@40,@41,@29) */\n  for (i=0, rr=w29; i<2; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w40+j, ct=w41+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #226: @29 = @29' */\n  /* #227: (@2[8:10] += @29) */\n  for (rr=w02+8, cs=w29; rr!=w02+10; rr+=1) *rr += *cs++;\n  /* #228: @29 = @15' */\n  casadi_copy(w15, 2, w29);\n  /* #229: @29 = (@29*@56) */\n  for (i=0, rr=w29; i<2; ++i) (*rr++) *= w56;\n  /* #230: (@2[6:8] += @29) */\n  for (rr=w02+6, cs=w29; rr!=w02+8; rr+=1) *rr += *cs++;\n  /* #231: @29 = zeros(1x2) */\n  casadi_clear(w29, 2);\n  /* #232: @40 = @18' */\n  casadi_copy(w18, 2, w40);\n  /* #233: @40 = (@56*@40) */\n  for (i=0, rr=w40, cs=w40; i<2; ++i) (*rr++)  = (w56*(*cs++));\n  /* #234: @41 = @20' */\n  for (i=0, rr=w41, cs=w20; i<2; ++i) for (j=0; j<2; ++j) rr[i+j*2] = *cs++;\n  /* #235: @29 = mac(@40,@41,@29) */\n  for (i=0, rr=w29; i<2; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w40+j, ct=w41+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #236: @29 = @29' */\n  /* #237: (@2[6:8] += @29) */\n  for (rr=w02+6, cs=w29; rr!=w02+8; rr+=1) *rr += *cs++;\n  /* #238: @29 = @11' */\n  casadi_copy(w11, 2, w29);\n  /* #239: @29 = (@29*@56) */\n  for (i=0, rr=w29; i<2; ++i) (*rr++) *= w56;\n  /* #240: (@2[4:6] += @29) */\n  for (rr=w02+4, cs=w29; rr!=w02+6; rr+=1) *rr += *cs++;\n  /* #241: @29 = zeros(1x2) */\n  casadi_clear(w29, 2);\n  /* #242: @40 = @14' */\n  casadi_copy(w14, 2, w40);\n  /* #243: @40 = (@56*@40) */\n  for (i=0, rr=w40, cs=w40; i<2; ++i) (*rr++)  = (w56*(*cs++));\n  /* #244: @41 = @16' */\n  for (i=0, rr=w41, cs=w16; i<2; ++i) for (j=0; j<2; ++j) rr[i+j*2] = *cs++;\n  /* #245: @29 = mac(@40,@41,@29) */\n  for (i=0, rr=w29; i<2; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w40+j, ct=w41+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #246: @29 = @29' */\n  /* #247: (@2[4:6] += @29) */\n  for (rr=w02+4, cs=w29; rr!=w02+6; rr+=1) *rr += *cs++;\n  /* #248: @29 = @5' */\n  casadi_copy(w05, 2, w29);\n  /* #249: @29 = (@29*@56) */\n  for (i=0, rr=w29; i<2; ++i) (*rr++) *= w56;\n  /* #250: (@2[2:4] += @29) */\n  for (rr=w02+2, cs=w29; rr!=w02+4; rr+=1) *rr += *cs++;\n  /* #251: @29 = zeros(1x2) */\n  casadi_clear(w29, 2);\n  /* #252: @40 = @10' */\n  casadi_copy(w10, 2, w40);\n  /* #253: @40 = (@56*@40) */\n  for (i=0, rr=w40, cs=w40; i<2; ++i) (*rr++)  = (w56*(*cs++));\n  /* #254: @41 = @12' */\n  for (i=0, rr=w41, cs=w12; i<2; ++i) for (j=0; j<2; ++j) rr[i+j*2] = *cs++;\n  /* #255: @29 = mac(@40,@41,@29) */\n  for (i=0, rr=w29; i<2; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w40+j, ct=w41+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #256: @29 = @29' */\n  /* #257: (@2[2:4] += @29) */\n  for (rr=w02+2, cs=w29; rr!=w02+4; rr+=1) *rr += *cs++;\n  /* #258: @29 = @1' */\n  casadi_copy(w01, 2, w29);\n  /* #259: @29 = (@29*@56) */\n  for (i=0, rr=w29; i<2; ++i) (*rr++) *= w56;\n  /* #260: (@2[:2] += @29) */\n  for (rr=w02+0, cs=w29; rr!=w02+2; rr+=1) *rr += *cs++;\n  /* #261: @29 = zeros(1x2) */\n  casadi_clear(w29, 2);\n  /* #262: @40 = @3' */\n  casadi_copy(w03, 2, w40);\n  /* #263: @40 = (@56*@40) */\n  for (i=0, rr=w40, cs=w40; i<2; ++i) (*rr++)  = (w56*(*cs++));\n  /* #264: @41 = @6' */\n  for (i=0, rr=w41, cs=w06; i<2; ++i) for (j=0; j<2; ++j) rr[i+j*2] = *cs++;\n  /* #265: @29 = mac(@40,@41,@29) */\n  for (i=0, rr=w29; i<2; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w40+j, ct=w41+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #266: @29 = @29' */\n  /* #267: (@2[:2] += @29) */\n  for (rr=w02+0, cs=w29; rr!=w02+2; rr+=1) *rr += *cs++;\n  /* #268: output[2][0] = @2 */\n  casadi_copy(w02, 12, res[2]);\n  /* #269: @7 = zeros(1x5) */\n  casadi_clear(w07, 5);\n  /* #270: (@7[4] += @54) */\n  for (rr=w07+4, cs=(&w54); rr!=w07+5; rr+=1) *rr += *cs++;\n  /* #271: (@7[4] += @53) */\n  for (rr=w07+4, cs=(&w53); rr!=w07+5; rr+=1) *rr += *cs++;\n  /* #272: @53 = dot(@38, @55) */\n  w53 = casadi_dot(2, w38, w55);\n  /* #273: (@7[4] += @53) */\n  for (rr=w07+4, cs=(&w53); rr!=w07+5; rr+=1) *rr += *cs++;\n  /* #274: (@7[3] += @51) */\n  for (rr=w07+3, cs=(&w51); rr!=w07+4; rr+=1) *rr += *cs++;\n  /* #275: (@7[3] += @50) */\n  for (rr=w07+3, cs=(&w50); rr!=w07+4; rr+=1) *rr += *cs++;\n  /* #276: @50 = dot(@36, @27) */\n  w50 = casadi_dot(2, w36, w27);\n  /* #277: (@7[3] += @50) */\n  for (rr=w07+3, cs=(&w50); rr!=w07+4; rr+=1) *rr += *cs++;\n  /* #278: (@7[2] += @48) */\n  for (rr=w07+2, cs=(&w48); rr!=w07+3; rr+=1) *rr += *cs++;\n  /* #279: (@7[2] += @47) */\n  for (rr=w07+2, cs=(&w47); rr!=w07+3; rr+=1) *rr += *cs++;\n  /* #280: @47 = dot(@34, @52) */\n  w47 = casadi_dot(2, w34, w52);\n  /* #281: (@7[2] += @47) */\n  for (rr=w07+2, cs=(&w47); rr!=w07+3; rr+=1) *rr += *cs++;\n  /* #282: (@7[1] += @45) */\n  for (rr=w07+1, cs=(&w45); rr!=w07+2; rr+=1) *rr += *cs++;\n  /* #283: (@7[1] += @44) */\n  for (rr=w07+1, cs=(&w44); rr!=w07+2; rr+=1) *rr += *cs++;\n  /* #284: @44 = dot(@32, @49) */\n  w44 = casadi_dot(2, w32, w49);\n  /* #285: (@7[1] += @44) */\n  for (rr=w07+1, cs=(&w44); rr!=w07+2; rr+=1) *rr += *cs++;\n  /* #286: (@7[0] += @25) */\n  for (rr=w07+0, cs=(&w25); rr!=w07+1; rr+=1) *rr += *cs++;\n  /* #287: (@7[0] += @0) */\n  for (rr=w07+0, cs=(&w00); rr!=w07+1; rr+=1) *rr += *cs++;\n  /* #288: @0 = dot(@31, @46) */\n  w00 = casadi_dot(2, w31, w46);\n  /* #289: (@7[0] += @0) */\n  for (rr=w07+0, cs=(&w00); rr!=w07+1; rr+=1) *rr += *cs++;\n  /* #290: @21 = (2.*@21) */\n  w21 = (2.* w21 );\n  /* #291: @21 = (@21*@56) */\n  w21 *= w56;\n  /* #292: (@7[4] += @21) */\n  for (rr=w07+4, cs=(&w21); rr!=w07+5; rr+=1) *rr += *cs++;\n  /* #293: @17 = (2.*@17) */\n  w17 = (2.* w17 );\n  /* #294: @17 = (@17*@56) */\n  w17 *= w56;\n  /* #295: (@7[3] += @17) */\n  for (rr=w07+3, cs=(&w17); rr!=w07+4; rr+=1) *rr += *cs++;\n  /* #296: @13 = (2.*@13) */\n  w13 = (2.* w13 );\n  /* #297: @13 = (@13*@56) */\n  w13 *= w56;\n  /* #298: (@7[2] += @13) */\n  for (rr=w07+2, cs=(&w13); rr!=w07+3; rr+=1) *rr += *cs++;\n  /* #299: @9 = (2.*@9) */\n  w09 = (2.* w09 );\n  /* #300: @9 = (@9*@56) */\n  w09 *= w56;\n  /* #301: (@7[1] += @9) */\n  for (rr=w07+1, cs=(&w09); rr!=w07+2; rr+=1) *rr += *cs++;\n  /* #302: @8 = (2.*@8) */\n  w08 = (2.* w08 );\n  /* #303: @8 = (@8*@56) */\n  w08 *= w56;\n  /* #304: (@7[0] += @8) */\n  for (rr=w07+0, cs=(&w08); rr!=w07+1; rr+=1) *rr += *cs++;\n  /* #305: output[2][1] = @7 */\n  if (res[2]) casadi_copy(w07, 5, res[2]+12);\n  /* #306: @57 = zeros(2x1,0nz) */\n  /* #307: @2 = zeros(2x6) */\n  casadi_clear(w02, 12);\n  /* #308: @23 = @23' */\n  /* #309: @23 = (@23*@56) */\n  for (i=0, rr=w23; i<2; ++i) (*rr++) *= w56;\n  /* #310: @23 = (-@23) */\n  for (i=0, rr=w23, cs=w23; i<2; ++i) *rr++ = (- *cs++ );\n  /* #311: (@2[10:12] += @23) */\n  for (rr=w02+10, cs=w23; rr!=w02+12; rr+=1) *rr += *cs++;\n  /* #312: @23 = zeros(1x2) */\n  casadi_clear(w23, 2);\n  /* #313: @26 = @26' */\n  /* #314: @26 = (@56*@26) */\n  for (i=0, rr=w26, cs=w26; i<2; ++i) (*rr++)  = (w56*(*cs++));\n  /* #315: @41 = @28' */\n  for (i=0, rr=w41, cs=w28; i<2; ++i) for (j=0; j<2; ++j) rr[i+j*2] = *cs++;\n  /* #316: @23 = mac(@26,@41,@23) */\n  for (i=0, rr=w23; i<2; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w26+j, ct=w41+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #317: @23 = @23' */\n  /* #318: @23 = (-@23) */\n  for (i=0, rr=w23, cs=w23; i<2; ++i) *rr++ = (- *cs++ );\n  /* #319: (@2[10:12] += @23) */\n  for (rr=w02+10, cs=w23; rr!=w02+12; rr+=1) *rr += *cs++;\n  /* #320: @19 = @19' */\n  /* #321: @19 = (@19*@56) */\n  for (i=0, rr=w19; i<2; ++i) (*rr++) *= w56;\n  /* #322: @19 = (-@19) */\n  for (i=0, rr=w19, cs=w19; i<2; ++i) *rr++ = (- *cs++ );\n  /* #323: (@2[8:10] += @19) */\n  for (rr=w02+8, cs=w19; rr!=w02+10; rr+=1) *rr += *cs++;\n  /* #324: @19 = zeros(1x2) */\n  casadi_clear(w19, 2);\n  /* #325: @22 = @22' */\n  /* #326: @22 = (@56*@22) */\n  for (i=0, rr=w22, cs=w22; i<2; ++i) (*rr++)  = (w56*(*cs++));\n  /* #327: @41 = @24' */\n  for (i=0, rr=w41, cs=w24; i<2; ++i) for (j=0; j<2; ++j) rr[i+j*2] = *cs++;\n  /* #328: @19 = mac(@22,@41,@19) */\n  for (i=0, rr=w19; i<2; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w22+j, ct=w41+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #329: @19 = @19' */\n  /* #330: @19 = (-@19) */\n  for (i=0, rr=w19, cs=w19; i<2; ++i) *rr++ = (- *cs++ );\n  /* #331: (@2[8:10] += @19) */\n  for (rr=w02+8, cs=w19; rr!=w02+10; rr+=1) *rr += *cs++;\n  /* #332: @15 = @15' */\n  /* #333: @15 = (@15*@56) */\n  for (i=0, rr=w15; i<2; ++i) (*rr++) *= w56;\n  /* #334: @15 = (-@15) */\n  for (i=0, rr=w15, cs=w15; i<2; ++i) *rr++ = (- *cs++ );\n  /* #335: (@2[6:8] += @15) */\n  for (rr=w02+6, cs=w15; rr!=w02+8; rr+=1) *rr += *cs++;\n  /* #336: @15 = zeros(1x2) */\n  casadi_clear(w15, 2);\n  /* #337: @18 = @18' */\n  /* #338: @18 = (@56*@18) */\n  for (i=0, rr=w18, cs=w18; i<2; ++i) (*rr++)  = (w56*(*cs++));\n  /* #339: @41 = @20' */\n  for (i=0, rr=w41, cs=w20; i<2; ++i) for (j=0; j<2; ++j) rr[i+j*2] = *cs++;\n  /* #340: @15 = mac(@18,@41,@15) */\n  for (i=0, rr=w15; i<2; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w18+j, ct=w41+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #341: @15 = @15' */\n  /* #342: @15 = (-@15) */\n  for (i=0, rr=w15, cs=w15; i<2; ++i) *rr++ = (- *cs++ );\n  /* #343: (@2[6:8] += @15) */\n  for (rr=w02+6, cs=w15; rr!=w02+8; rr+=1) *rr += *cs++;\n  /* #344: @11 = @11' */\n  /* #345: @11 = (@11*@56) */\n  for (i=0, rr=w11; i<2; ++i) (*rr++) *= w56;\n  /* #346: @11 = (-@11) */\n  for (i=0, rr=w11, cs=w11; i<2; ++i) *rr++ = (- *cs++ );\n  /* #347: (@2[4:6] += @11) */\n  for (rr=w02+4, cs=w11; rr!=w02+6; rr+=1) *rr += *cs++;\n  /* #348: @11 = zeros(1x2) */\n  casadi_clear(w11, 2);\n  /* #349: @14 = @14' */\n  /* #350: @14 = (@56*@14) */\n  for (i=0, rr=w14, cs=w14; i<2; ++i) (*rr++)  = (w56*(*cs++));\n  /* #351: @41 = @16' */\n  for (i=0, rr=w41, cs=w16; i<2; ++i) for (j=0; j<2; ++j) rr[i+j*2] = *cs++;\n  /* #352: @11 = mac(@14,@41,@11) */\n  for (i=0, rr=w11; i<2; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w14+j, ct=w41+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #353: @11 = @11' */\n  /* #354: @11 = (-@11) */\n  for (i=0, rr=w11, cs=w11; i<2; ++i) *rr++ = (- *cs++ );\n  /* #355: (@2[4:6] += @11) */\n  for (rr=w02+4, cs=w11; rr!=w02+6; rr+=1) *rr += *cs++;\n  /* #356: @5 = @5' */\n  /* #357: @5 = (@5*@56) */\n  for (i=0, rr=w05; i<2; ++i) (*rr++) *= w56;\n  /* #358: @5 = (-@5) */\n  for (i=0, rr=w05, cs=w05; i<2; ++i) *rr++ = (- *cs++ );\n  /* #359: (@2[2:4] += @5) */\n  for (rr=w02+2, cs=w05; rr!=w02+4; rr+=1) *rr += *cs++;\n  /* #360: @5 = zeros(1x2) */\n  casadi_clear(w05, 2);\n  /* #361: @10 = @10' */\n  /* #362: @10 = (@56*@10) */\n  for (i=0, rr=w10, cs=w10; i<2; ++i) (*rr++)  = (w56*(*cs++));\n  /* #363: @41 = @12' */\n  for (i=0, rr=w41, cs=w12; i<2; ++i) for (j=0; j<2; ++j) rr[i+j*2] = *cs++;\n  /* #364: @5 = mac(@10,@41,@5) */\n  for (i=0, rr=w05; i<2; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w10+j, ct=w41+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #365: @5 = @5' */\n  /* #366: @5 = (-@5) */\n  for (i=0, rr=w05, cs=w05; i<2; ++i) *rr++ = (- *cs++ );\n  /* #367: (@2[2:4] += @5) */\n  for (rr=w02+2, cs=w05; rr!=w02+4; rr+=1) *rr += *cs++;\n  /* #368: @1 = @1' */\n  /* #369: @1 = (@1*@56) */\n  for (i=0, rr=w01; i<2; ++i) (*rr++) *= w56;\n  /* #370: @1 = (-@1) */\n  for (i=0, rr=w01, cs=w01; i<2; ++i) *rr++ = (- *cs++ );\n  /* #371: (@2[:2] += @1) */\n  for (rr=w02+0, cs=w01; rr!=w02+2; rr+=1) *rr += *cs++;\n  /* #372: @1 = zeros(1x2) */\n  casadi_clear(w01, 2);\n  /* #373: @3 = @3' */\n  /* #374: @3 = (@56*@3) */\n  for (i=0, rr=w03, cs=w03; i<2; ++i) (*rr++)  = (w56*(*cs++));\n  /* #375: @41 = @6' */\n  for (i=0, rr=w41, cs=w06; i<2; ++i) for (j=0; j<2; ++j) rr[i+j*2] = *cs++;\n  /* #376: @1 = mac(@3,@41,@1) */\n  for (i=0, rr=w01; i<2; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w03+j, ct=w41+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #377: @1 = @1' */\n  /* #378: @1 = (-@1) */\n  for (i=0, rr=w01, cs=w01; i<2; ++i) *rr++ = (- *cs++ );\n  /* #379: (@2[:2] += @1) */\n  for (rr=w02+0, cs=w01; rr!=w02+2; rr+=1) *rr += *cs++;\n  /* #380: @2 = vec(@2) */\n  /* #381: @4 = vertcat(@57, @2) */\n  rr=w04;\n  for (i=0, cs=w02; i<12; ++i) *rr++ = *cs++;\n  /* #382: @58 = dense(@4) */\n  casadi_densify(w04, casadi_s0, w58, 0);\n  /* #383: output[3][0] = @58 */\n  casadi_copy(w58, 14, res[3]);\n  return 0;\n}\n\n/* nlp_fg:(x[17],p[14])->(f,g[22]) */\nstatic int casadi_f3(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {\n  casadi_int i, j, k;\n  casadi_real *rr, w0, *w1=w+3, *w3=w+17, *w5=w+31, *w6=w+33, *w7=w+37, w8;\n  const casadi_real *cr, *cs, *ct, *wr1, *wr2, *wr3, *wr4, *wr5;\n  /* #0: @0 = 0 */\n  w0 = 0.;\n  /* #1: @1 = zeros(1x2) */\n  casadi_clear(w1, 2);\n  /* #2: @2 = input[0][0] */\n  wr2 = arg[0] ? arg[0] : casadi_zeros;\n  /* #3: @3 = @2[:2] */\n  wr3 = wr2+0;\n  /* #4: @4 = input[1][1] */\n  wr4 = arg[1] ? arg[1]+2 : casadi_zeros;\n  /* #5: @5 = @4[:2] */\n  wr5 = wr4+0;\n  /* #6: @3 = (@3-@5) */\n  for (i=0, rr=w3, cr=wr3, cs=wr5; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #7: @3 = @3' */\n  /* #8: @6 = \n  [[500, 0], \n   [0, 1]] */\n  casadi_copy(casadi_c0, 4, w6);\n  /* #9: @1 = mac(@3,@6,@1) */\n  for (i=0, rr=w1; i<2; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w3+j, ct=w6+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #10: @3 = @2[:2] */\n  wr3 = wr2+0;\n  /* #11: @5 = @4[:2] */\n  wr5 = wr4+0;\n  /* #12: @3 = (@3-@5) */\n  for (i=0, rr=w3, cr=wr3, cs=wr5; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #13: @0 = mac(@1,@3,@0) */\n  for (i=0, rr=(&w0); i<1; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w1+j, ct=w3+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #14: @7 = input[0][1] */\n  casadi_copy(arg[0] ? arg[0]+12 : 0, 5, w7);\n  /* #15: @8 = @7[0] */\n  for (rr=(&w8), cs=w7+0; cs!=w7+1; cs+=1) *rr++ = *cs;\n  /* #16: @8 = sq(@8) */\n  w8 = casadi_sq( w8 );\n  /* #17: @0 = (@0+@8) */\n  w0 += w8;\n  /* #18: @8 = 0 */\n  w8 = 0.;\n  /* #19: @1 = zeros(1x2) */\n  casadi_clear(w1, 2);\n  /* #20: @3 = @2[2:4] */\n  wr3 = wr2+2;\n  /* #21: @5 = @4[2:4] */\n  wr5 = wr4+2;\n  /* #22: @3 = (@3-@5) */\n  for (i=0, rr=w3, cr=wr3, cs=wr5; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #23: @3 = @3' */\n  /* #24: @6 = \n  [[500, 0], \n   [0, 1]] */\n  casadi_copy(casadi_c0, 4, w6);\n  /* #25: @1 = mac(@3,@6,@1) */\n  for (i=0, rr=w1; i<2; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w3+j, ct=w6+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #26: @3 = @2[2:4] */\n  wr3 = wr2+2;\n  /* #27: @5 = @4[2:4] */\n  wr5 = wr4+2;\n  /* #28: @3 = (@3-@5) */\n  for (i=0, rr=w3, cr=wr3, cs=wr5; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #29: @8 = mac(@1,@3,@8) */\n  for (i=0, rr=(&w8); i<1; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w1+j, ct=w3+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #30: @0 = (@0+@8) */\n  w0 += w8;\n  /* #31: @8 = @7[1] */\n  for (rr=(&w8), cs=w7+1; cs!=w7+2; cs+=1) *rr++ = *cs;\n  /* #32: @8 = sq(@8) */\n  w8 = casadi_sq( w8 );\n  /* #33: @0 = (@0+@8) */\n  w0 += w8;\n  /* #34: @8 = 0 */\n  w8 = 0.;\n  /* #35: @1 = zeros(1x2) */\n  casadi_clear(w1, 2);\n  /* #36: @3 = @2[4:6] */\n  wr3 = wr2+4;\n  /* #37: @5 = @4[4:6] */\n  wr5 = wr4+4;\n  /* #38: @3 = (@3-@5) */\n  for (i=0, rr=w3, cr=wr3, cs=wr5; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #39: @3 = @3' */\n  /* #40: @6 = \n  [[500, 0], \n   [0, 1]] */\n  casadi_copy(casadi_c0, 4, w6);\n  /* #41: @1 = mac(@3,@6,@1) */\n  for (i=0, rr=w1; i<2; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w3+j, ct=w6+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #42: @3 = @2[4:6] */\n  wr3 = wr2+4;\n  /* #43: @5 = @4[4:6] */\n  wr5 = wr4+4;\n  /* #44: @3 = (@3-@5) */\n  for (i=0, rr=w3, cr=wr3, cs=wr5; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #45: @8 = mac(@1,@3,@8) */\n  for (i=0, rr=(&w8); i<1; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w1+j, ct=w3+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #46: @0 = (@0+@8) */\n  w0 += w8;\n  /* #47: @8 = @7[2] */\n  for (rr=(&w8), cs=w7+2; cs!=w7+3; cs+=1) *rr++ = *cs;\n  /* #48: @8 = sq(@8) */\n  w8 = casadi_sq( w8 );\n  /* #49: @0 = (@0+@8) */\n  w0 += w8;\n  /* #50: @8 = 0 */\n  w8 = 0.;\n  /* #51: @1 = zeros(1x2) */\n  casadi_clear(w1, 2);\n  /* #52: @3 = @2[6:8] */\n  wr3 = wr2+6;\n  /* #53: @5 = @4[6:8] */\n  wr5 = wr4+6;\n  /* #54: @3 = (@3-@5) */\n  for (i=0, rr=w3, cr=wr3, cs=wr5; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #55: @3 = @3' */\n  /* #56: @6 = \n  [[500, 0], \n   [0, 1]] */\n  casadi_copy(casadi_c0, 4, w6);\n  /* #57: @1 = mac(@3,@6,@1) */\n  for (i=0, rr=w1; i<2; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w3+j, ct=w6+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #58: @3 = @2[6:8] */\n  wr3 = wr2+6;\n  /* #59: @5 = @4[6:8] */\n  wr5 = wr4+6;\n  /* #60: @3 = (@3-@5) */\n  for (i=0, rr=w3, cr=wr3, cs=wr5; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #61: @8 = mac(@1,@3,@8) */\n  for (i=0, rr=(&w8); i<1; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w1+j, ct=w3+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #62: @0 = (@0+@8) */\n  w0 += w8;\n  /* #63: @8 = @7[3] */\n  for (rr=(&w8), cs=w7+3; cs!=w7+4; cs+=1) *rr++ = *cs;\n  /* #64: @8 = sq(@8) */\n  w8 = casadi_sq( w8 );\n  /* #65: @0 = (@0+@8) */\n  w0 += w8;\n  /* #66: @8 = 0 */\n  w8 = 0.;\n  /* #67: @1 = zeros(1x2) */\n  casadi_clear(w1, 2);\n  /* #68: @3 = @2[8:10] */\n  wr3 = wr2+8;\n  /* #69: @5 = @4[8:10] */\n  wr5 = wr4+8;\n  /* #70: @3 = (@3-@5) */\n  for (i=0, rr=w3, cr=wr3, cs=wr5; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #71: @3 = @3' */\n  /* #72: @6 = \n  [[500, 0], \n   [0, 1]] */\n  casadi_copy(casadi_c0, 4, w6);\n  /* #73: @1 = mac(@3,@6,@1) */\n  for (i=0, rr=w1; i<2; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w3+j, ct=w6+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #74: @3 = @2[8:10] */\n  wr3 = wr2+8;\n  /* #75: @5 = @4[8:10] */\n  wr5 = wr4+8;\n  /* #76: @3 = (@3-@5) */\n  for (i=0, rr=w3, cr=wr3, cs=wr5; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #77: @8 = mac(@1,@3,@8) */\n  for (i=0, rr=(&w8); i<1; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w1+j, ct=w3+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #78: @0 = (@0+@8) */\n  w0 += w8;\n  /* #79: @8 = @7[4] */\n  for (rr=(&w8), cs=w7+4; cs!=w7+5; cs+=1) *rr++ = *cs;\n  /* #80: @8 = sq(@8) */\n  w8 = casadi_sq( w8 );\n  /* #81: @0 = (@0+@8) */\n  w0 += w8;\n  /* #82: @8 = 0 */\n  w8 = 0.;\n  /* #83: @1 = zeros(1x2) */\n  casadi_clear(w1, 2);\n  /* #84: @3 = @2[10:12] */\n  wr3 = wr2+10;\n  /* #85: @5 = @4[10:12] */\n  wr5 = wr4+10;\n  /* #86: @3 = (@3-@5) */\n  for (i=0, rr=w3, cr=wr3, cs=wr5; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #87: @3 = @3' */\n  /* #88: @6 = \n  [[5000, 0], \n   [0, 10]] */\n  casadi_copy(casadi_c1, 4, w6);\n  /* #89: @1 = mac(@3,@6,@1) */\n  for (i=0, rr=w1; i<2; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w3+j, ct=w6+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #90: @3 = @2[10:12] */\n  wr3 = wr2+10;\n  /* #91: @5 = @4[10:12] */\n  wr5 = wr4+10;\n  /* #92: @3 = (@3-@5) */\n  for (i=0, rr=w3, cr=wr3, cs=wr5; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #93: @8 = mac(@1,@3,@8) */\n  for (i=0, rr=(&w8); i<1; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w1+j, ct=w3+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #94: @0 = (@0+@8) */\n  w0 += w8;\n  /* #95: output[0][0] = @0 */\n  if (res[0]) res[0][0] = w0;\n  /* #96: @1 = @2[:2] */\n  wr1 = wr2+0;\n  /* #97: output[1][0] = @1 */\n  casadi_copy(wr1, 2, res[1]);\n  /* #98: @1 = @2[2:4] */\n  wr1 = wr2+2;\n  /* #99: @3 = zeros(2x1) */\n  casadi_clear(w3, 2);\n  /* #100: @6 = \n  [[1, 0.0181174], \n   [0, 0.817837]] */\n  casadi_copy(casadi_c2, 4, w6);\n  /* #101: @5 = @2[:2] */\n  wr5 = wr2+0;\n  /* #102: @3 = mac(@6,@5,@3) */\n  for (i=0, rr=w3; i<1; ++i) for (j=0; j<2; ++j, ++rr) for (k=0, cs=w6+j, ct=wr5+i*2; k<2; ++k) *rr += cs[k*2]**ct++;\n  /* #103: @5 = [0.0448248, 4.33722] */\n  casadi_copy(casadi_c3, 2, w5);\n  /* #104: @0 = @7[0] */\n  for (rr=(&w0), cs=w7+0; cs!=w7+1; cs+=1) *rr++ = *cs;\n  /* #105: @5 = (@5*@0) */\n  for (i=0, rr=w5; i<2; ++i) (*rr++) *= w0;\n  /* #106: @3 = (@3+@5) */\n  for (i=0, rr=w3, cs=w5; i<2; ++i) (*rr++) += (*cs++);\n  /* #107: @1 = (@1-@3) */\n  for (i=0, rr=w1, cr=wr1, cs=w3; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #108: output[1][1] = @1 */\n  if (res[1]) casadi_copy(w1, 2, res[1]+2);\n  /* #109: @0 = @7[0] */\n  for (rr=(&w0), cs=w7+0; cs!=w7+1; cs+=1) *rr++ = *cs;\n  /* #110: output[1][2] = @0 */\n  if (res[1]) res[1][4] = w0;\n  /* #111: @0 = @7[0] */\n  for (rr=(&w0), cs=w7+0; cs!=w7+1; cs+=1) *rr++ = *cs;\n  /* #112: output[1][3] = @0 */\n  if (res[1]) res[1][5] = w0;\n  /* #113: @1 = @2[4:6] */\n  wr1 = wr2+4;\n  /* #114: @3 = zeros(2x1) */\n  casadi_clear(w3, 2);\n  /* #115: @6 = \n  [[1, 0.0181174], \n   [0, 0.817837]] */\n  casadi_copy(casadi_c2, 4, w6);\n  /* #116: @5 = @2[2:4] */\n  wr5 = wr2+2;\n  /* #117: @3 = mac(@6,@5,@3) */\n  for (i=0, rr=w3; i<1; ++i) for (j=0; j<2; ++j, ++rr) for (k=0, cs=w6+j, ct=wr5+i*2; k<2; ++k) *rr += cs[k*2]**ct++;\n  /* #118: @5 = [0.0448248, 4.33722] */\n  casadi_copy(casadi_c3, 2, w5);\n  /* #119: @0 = @7[1] */\n  for (rr=(&w0), cs=w7+1; cs!=w7+2; cs+=1) *rr++ = *cs;\n  /* #120: @5 = (@5*@0) */\n  for (i=0, rr=w5; i<2; ++i) (*rr++) *= w0;\n  /* #121: @3 = (@3+@5) */\n  for (i=0, rr=w3, cs=w5; i<2; ++i) (*rr++) += (*cs++);\n  /* #122: @1 = (@1-@3) */\n  for (i=0, rr=w1, cr=wr1, cs=w3; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #123: output[1][4] = @1 */\n  if (res[1]) casadi_copy(w1, 2, res[1]+6);\n  /* #124: @0 = @7[1] */\n  for (rr=(&w0), cs=w7+1; cs!=w7+2; cs+=1) *rr++ = *cs;\n  /* #125: output[1][5] = @0 */\n  if (res[1]) res[1][8] = w0;\n  /* #126: @0 = @7[1] */\n  for (rr=(&w0), cs=w7+1; cs!=w7+2; cs+=1) *rr++ = *cs;\n  /* #127: output[1][6] = @0 */\n  if (res[1]) res[1][9] = w0;\n  /* #128: @1 = @2[6:8] */\n  wr1 = wr2+6;\n  /* #129: @3 = zeros(2x1) */\n  casadi_clear(w3, 2);\n  /* #130: @6 = \n  [[1, 0.0181174], \n   [0, 0.817837]] */\n  casadi_copy(casadi_c2, 4, w6);\n  /* #131: @5 = @2[4:6] */\n  wr5 = wr2+4;\n  /* #132: @3 = mac(@6,@5,@3) */\n  for (i=0, rr=w3; i<1; ++i) for (j=0; j<2; ++j, ++rr) for (k=0, cs=w6+j, ct=wr5+i*2; k<2; ++k) *rr += cs[k*2]**ct++;\n  /* #133: @5 = [0.0448248, 4.33722] */\n  casadi_copy(casadi_c3, 2, w5);\n  /* #134: @0 = @7[2] */\n  for (rr=(&w0), cs=w7+2; cs!=w7+3; cs+=1) *rr++ = *cs;\n  /* #135: @5 = (@5*@0) */\n  for (i=0, rr=w5; i<2; ++i) (*rr++) *= w0;\n  /* #136: @3 = (@3+@5) */\n  for (i=0, rr=w3, cs=w5; i<2; ++i) (*rr++) += (*cs++);\n  /* #137: @1 = (@1-@3) */\n  for (i=0, rr=w1, cr=wr1, cs=w3; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #138: output[1][7] = @1 */\n  if (res[1]) casadi_copy(w1, 2, res[1]+10);\n  /* #139: @0 = @7[2] */\n  for (rr=(&w0), cs=w7+2; cs!=w7+3; cs+=1) *rr++ = *cs;\n  /* #140: output[1][8] = @0 */\n  if (res[1]) res[1][12] = w0;\n  /* #141: @0 = @7[2] */\n  for (rr=(&w0), cs=w7+2; cs!=w7+3; cs+=1) *rr++ = *cs;\n  /* #142: output[1][9] = @0 */\n  if (res[1]) res[1][13] = w0;\n  /* #143: @1 = @2[8:10] */\n  wr1 = wr2+8;\n  /* #144: @3 = zeros(2x1) */\n  casadi_clear(w3, 2);\n  /* #145: @6 = \n  [[1, 0.0181174], \n   [0, 0.817837]] */\n  casadi_copy(casadi_c2, 4, w6);\n  /* #146: @5 = @2[6:8] */\n  wr5 = wr2+6;\n  /* #147: @3 = mac(@6,@5,@3) */\n  for (i=0, rr=w3; i<1; ++i) for (j=0; j<2; ++j, ++rr) for (k=0, cs=w6+j, ct=wr5+i*2; k<2; ++k) *rr += cs[k*2]**ct++;\n  /* #148: @5 = [0.0448248, 4.33722] */\n  casadi_copy(casadi_c3, 2, w5);\n  /* #149: @0 = @7[3] */\n  for (rr=(&w0), cs=w7+3; cs!=w7+4; cs+=1) *rr++ = *cs;\n  /* #150: @5 = (@5*@0) */\n  for (i=0, rr=w5; i<2; ++i) (*rr++) *= w0;\n  /* #151: @3 = (@3+@5) */\n  for (i=0, rr=w3, cs=w5; i<2; ++i) (*rr++) += (*cs++);\n  /* #152: @1 = (@1-@3) */\n  for (i=0, rr=w1, cr=wr1, cs=w3; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #153: output[1][10] = @1 */\n  if (res[1]) casadi_copy(w1, 2, res[1]+14);\n  /* #154: @0 = @7[3] */\n  for (rr=(&w0), cs=w7+3; cs!=w7+4; cs+=1) *rr++ = *cs;\n  /* #155: output[1][11] = @0 */\n  if (res[1]) res[1][16] = w0;\n  /* #156: @0 = @7[3] */\n  for (rr=(&w0), cs=w7+3; cs!=w7+4; cs+=1) *rr++ = *cs;\n  /* #157: output[1][12] = @0 */\n  if (res[1]) res[1][17] = w0;\n  /* #158: @1 = @2[10:12] */\n  wr1 = wr2+10;\n  /* #159: @3 = zeros(2x1) */\n  casadi_clear(w3, 2);\n  /* #160: @6 = \n  [[1, 0.0181174], \n   [0, 0.817837]] */\n  casadi_copy(casadi_c2, 4, w6);\n  /* #161: @5 = @2[8:10] */\n  wr5 = wr2+8;\n  /* #162: @3 = mac(@6,@5,@3) */\n  for (i=0, rr=w3; i<1; ++i) for (j=0; j<2; ++j, ++rr) for (k=0, cs=w6+j, ct=wr5+i*2; k<2; ++k) *rr += cs[k*2]**ct++;\n  /* #163: @5 = [0.0448248, 4.33722] */\n  casadi_copy(casadi_c3, 2, w5);\n  /* #164: @0 = @7[4] */\n  for (rr=(&w0), cs=w7+4; cs!=w7+5; cs+=1) *rr++ = *cs;\n  /* #165: @5 = (@5*@0) */\n  for (i=0, rr=w5; i<2; ++i) (*rr++) *= w0;\n  /* #166: @3 = (@3+@5) */\n  for (i=0, rr=w3, cs=w5; i<2; ++i) (*rr++) += (*cs++);\n  /* #167: @1 = (@1-@3) */\n  for (i=0, rr=w1, cr=wr1, cs=w3; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #168: output[1][13] = @1 */\n  if (res[1]) casadi_copy(w1, 2, res[1]+18);\n  /* #169: @0 = @7[4] */\n  for (rr=(&w0), cs=w7+4; cs!=w7+5; cs+=1) *rr++ = *cs;\n  /* #170: output[1][14] = @0 */\n  if (res[1]) res[1][20] = w0;\n  /* #171: @0 = @7[4] */\n  for (rr=(&w0), cs=w7+4; cs!=w7+5; cs+=1) *rr++ = *cs;\n  /* #172: output[1][15] = @0 */\n  if (res[1]) res[1][21] = w0;\n  return 0;\n}\n\n/* nlp_jac_fg:(x[17],p[14])->(f,grad_f_x[17],g[22],jac_g_x[22x17,52nz]) */\nstatic int casadi_f4(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {\n  casadi_int i, j, k;\n  casadi_real *rr, w00, *w01=w+3, *w03=w+17, *w04=w+19, *w05=w+31, *w06=w+33, *w07=w+37, w08, w09, *w10=w+44, *w11=w+46;\n  casadi_real *w12=w+48, w13, *w14=w+53, *w15=w+55, *w16=w+57, w17, *w18=w+62, *w19=w+64, *w20=w+66, w21, *w22=w+71, *w23=w+73;\n  casadi_real *w24=w+75, w25, *w26=w+80, *w28=w+84, *w29=w+88, *w30=w+92, *w31=w+97, *w32=w+149, *w33=w+152, *w44=w+155, *w45=w+164, *w47=w+173;\n  casadi_real *w48=w+181, *w49=w+189, *w50=w+199, w51, *w52=w+210, *w53=w+226, *w54=w+242;\n  const casadi_int *cii;\n  const casadi_real *cr, *cs, *ct, *wr01, *wr02, *wr03, *wr04, *wr05, *wr10, *wr11, *wr14, *wr15;\n  const casadi_real *wr18, *wr19, *wr22, *wr23, *wr26, *wr27;\n  /* #0: @0 = 0 */\n  w00 = 0.;\n  /* #1: @1 = zeros(1x2) */\n  casadi_clear(w01, 2);\n  /* #2: @2 = input[0][0] */\n  wr02 = arg[0] ? arg[0] : casadi_zeros;\n  /* #3: @3 = @2[:2] */\n  wr03 = wr02+0;\n  /* #4: @4 = input[1][1] */\n  wr04 = arg[1] ? arg[1]+2 : casadi_zeros;\n  /* #5: @5 = @4[:2] */\n  wr05 = wr04+0;\n  /* #6: @3 = (@3-@5) */\n  for (i=0, rr=w03, cr=wr03, cs=wr05; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #7: @3 = @3' */\n  /* #8: @6 = \n  [[500, 0], \n   [0, 1]] */\n  casadi_copy(casadi_c0, 4, w06);\n  /* #9: @1 = mac(@3,@6,@1) */\n  for (i=0, rr=w01; i<2; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w03+j, ct=w06+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #10: @3 = @2[:2] */\n  wr03 = wr02+0;\n  /* #11: @5 = @4[:2] */\n  wr05 = wr04+0;\n  /* #12: @3 = (@3-@5) */\n  for (i=0, rr=w03, cr=wr03, cs=wr05; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #13: @0 = mac(@1,@3,@0) */\n  for (i=0, rr=(&w00); i<1; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w01+j, ct=w03+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #14: @7 = input[0][1] */\n  casadi_copy(arg[0] ? arg[0]+12 : 0, 5, w07);\n  /* #15: @8 = @7[0] */\n  for (rr=(&w08), cs=w07+0; cs!=w07+1; cs+=1) *rr++ = *cs;\n  /* #16: @9 = sq(@8) */\n  w09 = casadi_sq( w08 );\n  /* #17: @0 = (@0+@9) */\n  w00 += w09;\n  /* #18: @9 = 0 */\n  w09 = 0.;\n  /* #19: @5 = zeros(1x2) */\n  casadi_clear(w05, 2);\n  /* #20: @10 = @2[2:4] */\n  wr10 = wr02+2;\n  /* #21: @11 = @4[2:4] */\n  wr11 = wr04+2;\n  /* #22: @10 = (@10-@11) */\n  for (i=0, rr=w10, cr=wr10, cs=wr11; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #23: @10 = @10' */\n  /* #24: @12 = \n  [[500, 0], \n   [0, 1]] */\n  casadi_copy(casadi_c0, 4, w12);\n  /* #25: @5 = mac(@10,@12,@5) */\n  for (i=0, rr=w05; i<2; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w10+j, ct=w12+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #26: @10 = @2[2:4] */\n  wr10 = wr02+2;\n  /* #27: @11 = @4[2:4] */\n  wr11 = wr04+2;\n  /* #28: @10 = (@10-@11) */\n  for (i=0, rr=w10, cr=wr10, cs=wr11; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #29: @9 = mac(@5,@10,@9) */\n  for (i=0, rr=(&w09); i<1; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w05+j, ct=w10+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #30: @0 = (@0+@9) */\n  w00 += w09;\n  /* #31: @9 = @7[1] */\n  for (rr=(&w09), cs=w07+1; cs!=w07+2; cs+=1) *rr++ = *cs;\n  /* #32: @13 = sq(@9) */\n  w13 = casadi_sq( w09 );\n  /* #33: @0 = (@0+@13) */\n  w00 += w13;\n  /* #34: @13 = 0 */\n  w13 = 0.;\n  /* #35: @11 = zeros(1x2) */\n  casadi_clear(w11, 2);\n  /* #36: @14 = @2[4:6] */\n  wr14 = wr02+4;\n  /* #37: @15 = @4[4:6] */\n  wr15 = wr04+4;\n  /* #38: @14 = (@14-@15) */\n  for (i=0, rr=w14, cr=wr14, cs=wr15; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #39: @14 = @14' */\n  /* #40: @16 = \n  [[500, 0], \n   [0, 1]] */\n  casadi_copy(casadi_c0, 4, w16);\n  /* #41: @11 = mac(@14,@16,@11) */\n  for (i=0, rr=w11; i<2; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w14+j, ct=w16+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #42: @14 = @2[4:6] */\n  wr14 = wr02+4;\n  /* #43: @15 = @4[4:6] */\n  wr15 = wr04+4;\n  /* #44: @14 = (@14-@15) */\n  for (i=0, rr=w14, cr=wr14, cs=wr15; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #45: @13 = mac(@11,@14,@13) */\n  for (i=0, rr=(&w13); i<1; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w11+j, ct=w14+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #46: @0 = (@0+@13) */\n  w00 += w13;\n  /* #47: @13 = @7[2] */\n  for (rr=(&w13), cs=w07+2; cs!=w07+3; cs+=1) *rr++ = *cs;\n  /* #48: @17 = sq(@13) */\n  w17 = casadi_sq( w13 );\n  /* #49: @0 = (@0+@17) */\n  w00 += w17;\n  /* #50: @17 = 0 */\n  w17 = 0.;\n  /* #51: @15 = zeros(1x2) */\n  casadi_clear(w15, 2);\n  /* #52: @18 = @2[6:8] */\n  wr18 = wr02+6;\n  /* #53: @19 = @4[6:8] */\n  wr19 = wr04+6;\n  /* #54: @18 = (@18-@19) */\n  for (i=0, rr=w18, cr=wr18, cs=wr19; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #55: @18 = @18' */\n  /* #56: @20 = \n  [[500, 0], \n   [0, 1]] */\n  casadi_copy(casadi_c0, 4, w20);\n  /* #57: @15 = mac(@18,@20,@15) */\n  for (i=0, rr=w15; i<2; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w18+j, ct=w20+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #58: @18 = @2[6:8] */\n  wr18 = wr02+6;\n  /* #59: @19 = @4[6:8] */\n  wr19 = wr04+6;\n  /* #60: @18 = (@18-@19) */\n  for (i=0, rr=w18, cr=wr18, cs=wr19; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #61: @17 = mac(@15,@18,@17) */\n  for (i=0, rr=(&w17); i<1; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w15+j, ct=w18+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #62: @0 = (@0+@17) */\n  w00 += w17;\n  /* #63: @17 = @7[3] */\n  for (rr=(&w17), cs=w07+3; cs!=w07+4; cs+=1) *rr++ = *cs;\n  /* #64: @21 = sq(@17) */\n  w21 = casadi_sq( w17 );\n  /* #65: @0 = (@0+@21) */\n  w00 += w21;\n  /* #66: @21 = 0 */\n  w21 = 0.;\n  /* #67: @19 = zeros(1x2) */\n  casadi_clear(w19, 2);\n  /* #68: @22 = @2[8:10] */\n  wr22 = wr02+8;\n  /* #69: @23 = @4[8:10] */\n  wr23 = wr04+8;\n  /* #70: @22 = (@22-@23) */\n  for (i=0, rr=w22, cr=wr22, cs=wr23; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #71: @22 = @22' */\n  /* #72: @24 = \n  [[500, 0], \n   [0, 1]] */\n  casadi_copy(casadi_c0, 4, w24);\n  /* #73: @19 = mac(@22,@24,@19) */\n  for (i=0, rr=w19; i<2; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w22+j, ct=w24+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #74: @22 = @2[8:10] */\n  wr22 = wr02+8;\n  /* #75: @23 = @4[8:10] */\n  wr23 = wr04+8;\n  /* #76: @22 = (@22-@23) */\n  for (i=0, rr=w22, cr=wr22, cs=wr23; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #77: @21 = mac(@19,@22,@21) */\n  for (i=0, rr=(&w21); i<1; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w19+j, ct=w22+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #78: @0 = (@0+@21) */\n  w00 += w21;\n  /* #79: @21 = @7[4] */\n  for (rr=(&w21), cs=w07+4; cs!=w07+5; cs+=1) *rr++ = *cs;\n  /* #80: @25 = sq(@21) */\n  w25 = casadi_sq( w21 );\n  /* #81: @0 = (@0+@25) */\n  w00 += w25;\n  /* #82: @25 = 0 */\n  w25 = 0.;\n  /* #83: @23 = zeros(1x2) */\n  casadi_clear(w23, 2);\n  /* #84: @26 = @2[10:12] */\n  wr26 = wr02+10;\n  /* #85: @27 = @4[10:12] */\n  wr27 = wr04+10;\n  /* #86: @26 = (@26-@27) */\n  for (i=0, rr=w26, cr=wr26, cs=wr27; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #87: @26 = @26' */\n  /* #88: @28 = \n  [[5000, 0], \n   [0, 10]] */\n  casadi_copy(casadi_c1, 4, w28);\n  /* #89: @23 = mac(@26,@28,@23) */\n  for (i=0, rr=w23; i<2; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w26+j, ct=w28+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #90: @26 = @2[10:12] */\n  wr26 = wr02+10;\n  /* #91: @27 = @4[10:12] */\n  wr27 = wr04+10;\n  /* #92: @26 = (@26-@27) */\n  for (i=0, rr=w26, cr=wr26, cs=wr27; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #93: @25 = mac(@23,@26,@25) */\n  for (i=0, rr=(&w25); i<1; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w23+j, ct=w26+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #94: @0 = (@0+@25) */\n  w00 += w25;\n  /* #95: output[0][0] = @0 */\n  if (res[0]) res[0][0] = w00;\n  /* #96: @4 = zeros(2x6) */\n  casadi_clear(w04, 12);\n  /* #97: @23 = @23' */\n  /* #98: (@4[10:12] += @23) */\n  for (rr=w04+10, cs=w23; rr!=w04+12; rr+=1) *rr += *cs++;\n  /* #99: @23 = zeros(1x2) */\n  casadi_clear(w23, 2);\n  /* #100: @26 = @26' */\n  /* #101: @29 = @28' */\n  for (i=0, rr=w29, cs=w28; i<2; ++i) for (j=0; j<2; ++j) rr[i+j*2] = *cs++;\n  /* #102: @23 = mac(@26,@29,@23) */\n  for (i=0, rr=w23; i<2; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w26+j, ct=w29+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #103: @23 = @23' */\n  /* #104: (@4[10:12] += @23) */\n  for (rr=w04+10, cs=w23; rr!=w04+12; rr+=1) *rr += *cs++;\n  /* #105: @19 = @19' */\n  /* #106: (@4[8:10] += @19) */\n  for (rr=w04+8, cs=w19; rr!=w04+10; rr+=1) *rr += *cs++;\n  /* #107: @19 = zeros(1x2) */\n  casadi_clear(w19, 2);\n  /* #108: @22 = @22' */\n  /* #109: @29 = @24' */\n  for (i=0, rr=w29, cs=w24; i<2; ++i) for (j=0; j<2; ++j) rr[i+j*2] = *cs++;\n  /* #110: @19 = mac(@22,@29,@19) */\n  for (i=0, rr=w19; i<2; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w22+j, ct=w29+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #111: @19 = @19' */\n  /* #112: (@4[8:10] += @19) */\n  for (rr=w04+8, cs=w19; rr!=w04+10; rr+=1) *rr += *cs++;\n  /* #113: @15 = @15' */\n  /* #114: (@4[6:8] += @15) */\n  for (rr=w04+6, cs=w15; rr!=w04+8; rr+=1) *rr += *cs++;\n  /* #115: @15 = zeros(1x2) */\n  casadi_clear(w15, 2);\n  /* #116: @18 = @18' */\n  /* #117: @29 = @20' */\n  for (i=0, rr=w29, cs=w20; i<2; ++i) for (j=0; j<2; ++j) rr[i+j*2] = *cs++;\n  /* #118: @15 = mac(@18,@29,@15) */\n  for (i=0, rr=w15; i<2; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w18+j, ct=w29+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #119: @15 = @15' */\n  /* #120: (@4[6:8] += @15) */\n  for (rr=w04+6, cs=w15; rr!=w04+8; rr+=1) *rr += *cs++;\n  /* #121: @11 = @11' */\n  /* #122: (@4[4:6] += @11) */\n  for (rr=w04+4, cs=w11; rr!=w04+6; rr+=1) *rr += *cs++;\n  /* #123: @11 = zeros(1x2) */\n  casadi_clear(w11, 2);\n  /* #124: @14 = @14' */\n  /* #125: @29 = @16' */\n  for (i=0, rr=w29, cs=w16; i<2; ++i) for (j=0; j<2; ++j) rr[i+j*2] = *cs++;\n  /* #126: @11 = mac(@14,@29,@11) */\n  for (i=0, rr=w11; i<2; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w14+j, ct=w29+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #127: @11 = @11' */\n  /* #128: (@4[4:6] += @11) */\n  for (rr=w04+4, cs=w11; rr!=w04+6; rr+=1) *rr += *cs++;\n  /* #129: @5 = @5' */\n  /* #130: (@4[2:4] += @5) */\n  for (rr=w04+2, cs=w05; rr!=w04+4; rr+=1) *rr += *cs++;\n  /* #131: @5 = zeros(1x2) */\n  casadi_clear(w05, 2);\n  /* #132: @10 = @10' */\n  /* #133: @29 = @12' */\n  for (i=0, rr=w29, cs=w12; i<2; ++i) for (j=0; j<2; ++j) rr[i+j*2] = *cs++;\n  /* #134: @5 = mac(@10,@29,@5) */\n  for (i=0, rr=w05; i<2; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w10+j, ct=w29+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #135: @5 = @5' */\n  /* #136: (@4[2:4] += @5) */\n  for (rr=w04+2, cs=w05; rr!=w04+4; rr+=1) *rr += *cs++;\n  /* #137: @1 = @1' */\n  /* #138: (@4[:2] += @1) */\n  for (rr=w04+0, cs=w01; rr!=w04+2; rr+=1) *rr += *cs++;\n  /* #139: @1 = zeros(1x2) */\n  casadi_clear(w01, 2);\n  /* #140: @3 = @3' */\n  /* #141: @29 = @6' */\n  for (i=0, rr=w29, cs=w06; i<2; ++i) for (j=0; j<2; ++j) rr[i+j*2] = *cs++;\n  /* #142: @1 = mac(@3,@29,@1) */\n  for (i=0, rr=w01; i<2; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, cs=w03+j, ct=w29+i*2; k<2; ++k) *rr += cs[k*1]**ct++;\n  /* #143: @1 = @1' */\n  /* #144: (@4[:2] += @1) */\n  for (rr=w04+0, cs=w01; rr!=w04+2; rr+=1) *rr += *cs++;\n  /* #145: output[1][0] = @4 */\n  casadi_copy(w04, 12, res[1]);\n  /* #146: @30 = zeros(1x5) */\n  casadi_clear(w30, 5);\n  /* #147: @21 = (2.*@21) */\n  w21 = (2.* w21 );\n  /* #148: (@30[4] += @21) */\n  for (rr=w30+4, cs=(&w21); rr!=w30+5; rr+=1) *rr += *cs++;\n  /* #149: @17 = (2.*@17) */\n  w17 = (2.* w17 );\n  /* #150: (@30[3] += @17) */\n  for (rr=w30+3, cs=(&w17); rr!=w30+4; rr+=1) *rr += *cs++;\n  /* #151: @13 = (2.*@13) */\n  w13 = (2.* w13 );\n  /* #152: (@30[2] += @13) */\n  for (rr=w30+2, cs=(&w13); rr!=w30+3; rr+=1) *rr += *cs++;\n  /* #153: @9 = (2.*@9) */\n  w09 = (2.* w09 );\n  /* #154: (@30[1] += @9) */\n  for (rr=w30+1, cs=(&w09); rr!=w30+2; rr+=1) *rr += *cs++;\n  /* #155: @8 = (2.*@8) */\n  w08 = (2.* w08 );\n  /* #156: (@30[0] += @8) */\n  for (rr=w30+0, cs=(&w08); rr!=w30+1; rr+=1) *rr += *cs++;\n  /* #157: output[1][1] = @30 */\n  if (res[1]) casadi_copy(w30, 5, res[1]+12);\n  /* #158: @1 = @2[:2] */\n  wr01 = wr02+0;\n  /* #159: output[2][0] = @1 */\n  casadi_copy(wr01, 2, res[2]);\n  /* #160: @1 = @2[2:4] */\n  wr01 = wr02+2;\n  /* #161: @3 = zeros(2x1) */\n  casadi_clear(w03, 2);\n  /* #162: @29 = \n  [[1, 0.0181174], \n   [0, 0.817837]] */\n  casadi_copy(casadi_c2, 4, w29);\n  /* #163: @5 = @2[:2] */\n  wr05 = wr02+0;\n  /* #164: @3 = mac(@29,@5,@3) */\n  for (i=0, rr=w03; i<1; ++i) for (j=0; j<2; ++j, ++rr) for (k=0, cs=w29+j, ct=wr05+i*2; k<2; ++k) *rr += cs[k*2]**ct++;\n  /* #165: @5 = [0.0448248, 4.33722] */\n  casadi_copy(casadi_c3, 2, w05);\n  /* #166: @8 = @7[0] */\n  for (rr=(&w08), cs=w07+0; cs!=w07+1; cs+=1) *rr++ = *cs;\n  /* #167: @10 = (@5*@8) */\n  for (i=0, rr=w10, cr=w05; i<2; ++i) (*rr++)  = ((*cr++)*w08);\n  /* #168: @3 = (@3+@10) */\n  for (i=0, rr=w03, cs=w10; i<2; ++i) (*rr++) += (*cs++);\n  /* #169: @1 = (@1-@3) */\n  for (i=0, rr=w01, cr=wr01, cs=w03; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #170: output[2][1] = @1 */\n  if (res[2]) casadi_copy(w01, 2, res[2]+2);\n  /* #171: @8 = @7[0] */\n  for (rr=(&w08), cs=w07+0; cs!=w07+1; cs+=1) *rr++ = *cs;\n  /* #172: output[2][2] = @8 */\n  if (res[2]) res[2][4] = w08;\n  /* #173: @8 = @7[0] */\n  for (rr=(&w08), cs=w07+0; cs!=w07+1; cs+=1) *rr++ = *cs;\n  /* #174: output[2][3] = @8 */\n  if (res[2]) res[2][5] = w08;\n  /* #175: @1 = @2[4:6] */\n  wr01 = wr02+4;\n  /* #176: @3 = zeros(2x1) */\n  casadi_clear(w03, 2);\n  /* #177: @6 = \n  [[1, 0.0181174], \n   [0, 0.817837]] */\n  casadi_copy(casadi_c2, 4, w06);\n  /* #178: @10 = @2[2:4] */\n  wr10 = wr02+2;\n  /* #179: @3 = mac(@6,@10,@3) */\n  for (i=0, rr=w03; i<1; ++i) for (j=0; j<2; ++j, ++rr) for (k=0, cs=w06+j, ct=wr10+i*2; k<2; ++k) *rr += cs[k*2]**ct++;\n  /* #180: @10 = [0.0448248, 4.33722] */\n  casadi_copy(casadi_c3, 2, w10);\n  /* #181: @8 = @7[1] */\n  for (rr=(&w08), cs=w07+1; cs!=w07+2; cs+=1) *rr++ = *cs;\n  /* #182: @11 = (@10*@8) */\n  for (i=0, rr=w11, cr=w10; i<2; ++i) (*rr++)  = ((*cr++)*w08);\n  /* #183: @3 = (@3+@11) */\n  for (i=0, rr=w03, cs=w11; i<2; ++i) (*rr++) += (*cs++);\n  /* #184: @1 = (@1-@3) */\n  for (i=0, rr=w01, cr=wr01, cs=w03; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #185: output[2][4] = @1 */\n  if (res[2]) casadi_copy(w01, 2, res[2]+6);\n  /* #186: @8 = @7[1] */\n  for (rr=(&w08), cs=w07+1; cs!=w07+2; cs+=1) *rr++ = *cs;\n  /* #187: output[2][5] = @8 */\n  if (res[2]) res[2][8] = w08;\n  /* #188: @8 = @7[1] */\n  for (rr=(&w08), cs=w07+1; cs!=w07+2; cs+=1) *rr++ = *cs;\n  /* #189: output[2][6] = @8 */\n  if (res[2]) res[2][9] = w08;\n  /* #190: @1 = @2[6:8] */\n  wr01 = wr02+6;\n  /* #191: @3 = zeros(2x1) */\n  casadi_clear(w03, 2);\n  /* #192: @12 = \n  [[1, 0.0181174], \n   [0, 0.817837]] */\n  casadi_copy(casadi_c2, 4, w12);\n  /* #193: @11 = @2[4:6] */\n  wr11 = wr02+4;\n  /* #194: @3 = mac(@12,@11,@3) */\n  for (i=0, rr=w03; i<1; ++i) for (j=0; j<2; ++j, ++rr) for (k=0, cs=w12+j, ct=wr11+i*2; k<2; ++k) *rr += cs[k*2]**ct++;\n  /* #195: @11 = [0.0448248, 4.33722] */\n  casadi_copy(casadi_c3, 2, w11);\n  /* #196: @8 = @7[2] */\n  for (rr=(&w08), cs=w07+2; cs!=w07+3; cs+=1) *rr++ = *cs;\n  /* #197: @14 = (@11*@8) */\n  for (i=0, rr=w14, cr=w11; i<2; ++i) (*rr++)  = ((*cr++)*w08);\n  /* #198: @3 = (@3+@14) */\n  for (i=0, rr=w03, cs=w14; i<2; ++i) (*rr++) += (*cs++);\n  /* #199: @1 = (@1-@3) */\n  for (i=0, rr=w01, cr=wr01, cs=w03; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #200: output[2][7] = @1 */\n  if (res[2]) casadi_copy(w01, 2, res[2]+10);\n  /* #201: @8 = @7[2] */\n  for (rr=(&w08), cs=w07+2; cs!=w07+3; cs+=1) *rr++ = *cs;\n  /* #202: output[2][8] = @8 */\n  if (res[2]) res[2][12] = w08;\n  /* #203: @8 = @7[2] */\n  for (rr=(&w08), cs=w07+2; cs!=w07+3; cs+=1) *rr++ = *cs;\n  /* #204: output[2][9] = @8 */\n  if (res[2]) res[2][13] = w08;\n  /* #205: @1 = @2[8:10] */\n  wr01 = wr02+8;\n  /* #206: @3 = zeros(2x1) */\n  casadi_clear(w03, 2);\n  /* #207: @16 = \n  [[1, 0.0181174], \n   [0, 0.817837]] */\n  casadi_copy(casadi_c2, 4, w16);\n  /* #208: @14 = @2[6:8] */\n  wr14 = wr02+6;\n  /* #209: @3 = mac(@16,@14,@3) */\n  for (i=0, rr=w03; i<1; ++i) for (j=0; j<2; ++j, ++rr) for (k=0, cs=w16+j, ct=wr14+i*2; k<2; ++k) *rr += cs[k*2]**ct++;\n  /* #210: @14 = [0.0448248, 4.33722] */\n  casadi_copy(casadi_c3, 2, w14);\n  /* #211: @8 = @7[3] */\n  for (rr=(&w08), cs=w07+3; cs!=w07+4; cs+=1) *rr++ = *cs;\n  /* #212: @15 = (@14*@8) */\n  for (i=0, rr=w15, cr=w14; i<2; ++i) (*rr++)  = ((*cr++)*w08);\n  /* #213: @3 = (@3+@15) */\n  for (i=0, rr=w03, cs=w15; i<2; ++i) (*rr++) += (*cs++);\n  /* #214: @1 = (@1-@3) */\n  for (i=0, rr=w01, cr=wr01, cs=w03; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #215: output[2][10] = @1 */\n  if (res[2]) casadi_copy(w01, 2, res[2]+14);\n  /* #216: @8 = @7[3] */\n  for (rr=(&w08), cs=w07+3; cs!=w07+4; cs+=1) *rr++ = *cs;\n  /* #217: output[2][11] = @8 */\n  if (res[2]) res[2][16] = w08;\n  /* #218: @8 = @7[3] */\n  for (rr=(&w08), cs=w07+3; cs!=w07+4; cs+=1) *rr++ = *cs;\n  /* #219: output[2][12] = @8 */\n  if (res[2]) res[2][17] = w08;\n  /* #220: @1 = @2[10:12] */\n  wr01 = wr02+10;\n  /* #221: @3 = zeros(2x1) */\n  casadi_clear(w03, 2);\n  /* #222: @20 = \n  [[1, 0.0181174], \n   [0, 0.817837]] */\n  casadi_copy(casadi_c2, 4, w20);\n  /* #223: @15 = @2[8:10] */\n  wr15 = wr02+8;\n  /* #224: @3 = mac(@20,@15,@3) */\n  for (i=0, rr=w03; i<1; ++i) for (j=0; j<2; ++j, ++rr) for (k=0, cs=w20+j, ct=wr15+i*2; k<2; ++k) *rr += cs[k*2]**ct++;\n  /* #225: @15 = [0.0448248, 4.33722] */\n  casadi_copy(casadi_c3, 2, w15);\n  /* #226: @8 = @7[4] */\n  for (rr=(&w08), cs=w07+4; cs!=w07+5; cs+=1) *rr++ = *cs;\n  /* #227: @18 = (@15*@8) */\n  for (i=0, rr=w18, cr=w15; i<2; ++i) (*rr++)  = ((*cr++)*w08);\n  /* #228: @3 = (@3+@18) */\n  for (i=0, rr=w03, cs=w18; i<2; ++i) (*rr++) += (*cs++);\n  /* #229: @1 = (@1-@3) */\n  for (i=0, rr=w01, cr=wr01, cs=w03; i<2; ++i) (*rr++)  = ((*cr++)-(*cs++));\n  /* #230: output[2][13] = @1 */\n  if (res[2]) casadi_copy(w01, 2, res[2]+18);\n  /* #231: @8 = @7[4] */\n  for (rr=(&w08), cs=w07+4; cs!=w07+5; cs+=1) *rr++ = *cs;\n  /* #232: output[2][14] = @8 */\n  if (res[2]) res[2][20] = w08;\n  /* #233: @8 = @7[4] */\n  for (rr=(&w08), cs=w07+4; cs!=w07+5; cs+=1) *rr++ = *cs;\n  /* #234: output[2][15] = @8 */\n  if (res[2]) res[2][21] = w08;\n  /* #235: @31 = zeros(17x22,52nz) */\n  casadi_clear(w31, 52);\n  /* #236: @32 = ones(17x1,3nz) */\n  casadi_fill(w32, 3, 1.);\n  /* #237: {@33, NULL} = vertsplit(@32) */\n  casadi_copy(w32, 3, w33);\n  /* #238: @33 = reshape(@33) */\n  /* #239: @8 = @33[0] */\n  for (rr=(&w08), cs=w33+0; cs!=w33+1; cs+=1) *rr++ = *cs;\n  /* #240: @1 = zeros(2x1) */\n  casadi_clear(w01, 2);\n  /* #241: @9 = @33[0] */\n  for (rr=(&w09), cs=w33+0; cs!=w33+1; cs+=1) *rr++ = *cs;\n  /* #242: @1 = mac(@29,@9,@1) */\n  casadi_mtimes(w29, casadi_s3, (&w09), casadi_s2, w01, casadi_s1, w, 0);\n  /* #243: @1 = (-@1) */\n  for (i=0, rr=w01, cs=w01; i<2; ++i) *rr++ = (- *cs++ );\n  /* #244: @34 = 00 */\n  /* #245: @35 = 00 */\n  /* #246: @9 = @33[1] */\n  for (rr=(&w09), cs=w33+1; cs!=w33+2; cs+=1) *rr++ = *cs;\n  /* #247: @36 = 00 */\n  /* #248: @37 = 00 */\n  /* #249: @3 = zeros(2x1) */\n  casadi_clear(w03, 2);\n  /* #250: @13 = @33[1] */\n  for (rr=(&w13), cs=w33+1; cs!=w33+2; cs+=1) *rr++ = *cs;\n  /* #251: @3 = mac(@12,@13,@3) */\n  casadi_mtimes(w12, casadi_s3, (&w13), casadi_s2, w03, casadi_s1, w, 0);\n  /* #252: @3 = (-@3) */\n  for (i=0, rr=w03, cs=w03; i<2; ++i) *rr++ = (- *cs++ );\n  /* #253: @38 = 00 */\n  /* #254: @39 = 00 */\n  /* #255: @13 = @33[2] */\n  for (rr=(&w13), cs=w33+2; cs!=w33+3; cs+=1) *rr++ = *cs;\n  /* #256: @40 = 00 */\n  /* #257: @41 = 00 */\n  /* #258: @18 = zeros(2x1) */\n  casadi_clear(w18, 2);\n  /* #259: @17 = @33[2] */\n  for (rr=(&w17), cs=w33+2; cs!=w33+3; cs+=1) *rr++ = *cs;\n  /* #260: @18 = mac(@20,@17,@18) */\n  casadi_mtimes(w20, casadi_s3, (&w17), casadi_s2, w18, casadi_s1, w, 0);\n  /* #261: @18 = (-@18) */\n  for (i=0, rr=w18, cs=w18; i<2; ++i) *rr++ = (- *cs++ );\n  /* #262: @42 = 00 */\n  /* #263: @43 = 00 */\n  /* #264: @44 = vertcat(@8, @1, @34, @35, @9, @36, @37, @3, @38, @39, @13, @40, @41, @18, @42, @43) */\n  rr=w44;\n  *rr++ = w08;\n  for (i=0, cs=w01; i<2; ++i) *rr++ = *cs++;\n  *rr++ = w09;\n  for (i=0, cs=w03; i<2; ++i) *rr++ = *cs++;\n  *rr++ = w13;\n  for (i=0, cs=w18; i<2; ++i) *rr++ = *cs++;\n  /* #265: @45 = @44[:9] */\n  for (rr=w45, cs=w44+0; cs!=w44+9; cs+=1) *rr++ = *cs;\n  /* #266: (@31[0, 2, 6, 14, 22, 26, 34, 42, 46] = @45) */\n  for (cii=casadi_s4, rr=w31, cs=w45; cii!=casadi_s4+9; ++cii, ++cs) rr[*cii] = *cs;\n  /* #267: @33 = ones(17x1,3nz) */\n  casadi_fill(w33, 3, 1.);\n  /* #268: {@32, NULL} = vertsplit(@33) */\n  casadi_copy(w33, 3, w32);\n  /* #269: @32 = reshape(@32) */\n  /* #270: @8 = @32[0] */\n  for (rr=(&w08), cs=w32+0; cs!=w32+1; cs+=1) *rr++ = *cs;\n  /* #271: @1 = zeros(2x1) */\n  casadi_clear(w01, 2);\n  /* #272: @9 = @32[0] */\n  for (rr=(&w09), cs=w32+0; cs!=w32+1; cs+=1) *rr++ = *cs;\n  /* #273: @1 = mac(@29,@9,@1) */\n  casadi_mtimes(w29, casadi_s3, (&w09), casadi_s5, w01, casadi_s1, w, 0);\n  /* #274: @1 = (-@1) */\n  for (i=0, rr=w01, cs=w01; i<2; ++i) *rr++ = (- *cs++ );\n  /* #275: @34 = 00 */\n  /* #276: @35 = 00 */\n  /* #277: @9 = @32[1] */\n  for (rr=(&w09), cs=w32+1; cs!=w32+2; cs+=1) *rr++ = *cs;\n  /* #278: @36 = 00 */\n  /* #279: @37 = 00 */\n  /* #280: @3 = zeros(2x1) */\n  casadi_clear(w03, 2);\n  /* #281: @13 = @32[1] */\n  for (rr=(&w13), cs=w32+1; cs!=w32+2; cs+=1) *rr++ = *cs;\n  /* #282: @3 = mac(@12,@13,@3) */\n  casadi_mtimes(w12, casadi_s3, (&w13), casadi_s5, w03, casadi_s1, w, 0);\n  /* #283: @3 = (-@3) */\n  for (i=0, rr=w03, cs=w03; i<2; ++i) *rr++ = (- *cs++ );\n  /* #284: @38 = 00 */\n  /* #285: @39 = 00 */\n  /* #286: @13 = @32[2] */\n  for (rr=(&w13), cs=w32+2; cs!=w32+3; cs+=1) *rr++ = *cs;\n  /* #287: @40 = 00 */\n  /* #288: @41 = 00 */\n  /* #289: @18 = zeros(2x1) */\n  casadi_clear(w18, 2);\n  /* #290: @17 = @32[2] */\n  for (rr=(&w17), cs=w32+2; cs!=w32+3; cs+=1) *rr++ = *cs;\n  /* #291: @18 = mac(@20,@17,@18) */\n  casadi_mtimes(w20, casadi_s3, (&w17), casadi_s5, w18, casadi_s1, w, 0);\n  /* #292: @18 = (-@18) */\n  for (i=0, rr=w18, cs=w18; i<2; ++i) *rr++ = (- *cs++ );\n  /* #293: @42 = 00 */\n  /* #294: @43 = 00 */\n  /* #295: @45 = vertcat(@8, @1, @34, @35, @9, @36, @37, @3, @38, @39, @13, @40, @41, @18, @42, @43) */\n  rr=w45;\n  *rr++ = w08;\n  for (i=0, cs=w01; i<2; ++i) *rr++ = *cs++;\n  *rr++ = w09;\n  for (i=0, cs=w03; i<2; ++i) *rr++ = *cs++;\n  *rr++ = w13;\n  for (i=0, cs=w18; i<2; ++i) *rr++ = *cs++;\n  /* #296: @44 = @45[:9] */\n  for (rr=w44, cs=w45+0; cs!=w45+9; cs+=1) *rr++ = *cs;\n  /* #297: (@31[1, 3, 7, 18, 23, 27, 38, 43, 47] = @44) */\n  for (cii=casadi_s6, rr=w31, cs=w44; cii!=casadi_s6+9; ++cii, ++cs) rr[*cii] = *cs;\n  /* #298: @34 = zeros(2x1,0nz) */\n  /* #299: @20 = ones(17x1,4nz) */\n  casadi_fill(w20, 4, 1.);\n  /* #300: {@12, NULL} = vertsplit(@20) */\n  casadi_copy(w20, 4, w12);\n  /* #301: @12 = reshape(@12) */\n  /* #302: @8 = @12[0] */\n  for (rr=(&w08), cs=w12+0; cs!=w12+1; cs+=1) *rr++ = *cs;\n  /* #303: @35 = 00 */\n  /* #304: @36 = 00 */\n  /* #305: @1 = zeros(2x1) */\n  casadi_clear(w01, 2);\n  /* #306: @9 = @12[0] */\n  for (rr=(&w09), cs=w12+0; cs!=w12+1; cs+=1) *rr++ = *cs;\n  /* #307: @1 = mac(@6,@9,@1) */\n  casadi_mtimes(w06, casadi_s3, (&w09), casadi_s2, w01, casadi_s1, w, 0);\n  /* #308: @1 = (-@1) */\n  for (i=0, rr=w01, cs=w01; i<2; ++i) *rr++ = (- *cs++ );\n  /* #309: @37 = 00 */\n  /* #310: @38 = 00 */\n  /* #311: @9 = @12[1] */\n  for (rr=(&w09), cs=w12+1; cs!=w12+2; cs+=1) *rr++ = *cs;\n  /* #312: @39 = 00 */\n  /* #313: @40 = 00 */\n  /* #314: @3 = zeros(2x1) */\n  casadi_clear(w03, 2);\n  /* #315: @13 = @12[1] */\n  for (rr=(&w13), cs=w12+1; cs!=w12+2; cs+=1) *rr++ = *cs;\n  /* #316: @3 = mac(@16,@13,@3) */\n  casadi_mtimes(w16, casadi_s3, (&w13), casadi_s2, w03, casadi_s1, w, 0);\n  /* #317: @3 = (-@3) */\n  for (i=0, rr=w03, cs=w03; i<2; ++i) *rr++ = (- *cs++ );\n  /* #318: @41 = 00 */\n  /* #319: @42 = 00 */\n  /* #320: @18 = @12[2:4] */\n  for (rr=w18, cs=w12+2; cs!=w12+4; cs+=1) *rr++ = *cs;\n  /* #321: @43 = 00 */\n  /* #322: @46 = 00 */\n  /* #323: @47 = vertcat(@34, @8, @35, @36, @1, @37, @38, @9, @39, @40, @3, @41, @42, @18, @43, @46) */\n  rr=w47;\n  *rr++ = w08;\n  for (i=0, cs=w01; i<2; ++i) *rr++ = *cs++;\n  *rr++ = w09;\n  for (i=0, cs=w03; i<2; ++i) *rr++ = *cs++;\n  for (i=0, cs=w18; i<2; ++i) *rr++ = *cs++;\n  /* #324: @48 = @47[:8] */\n  for (rr=w48, cs=w47+0; cs!=w47+8; cs+=1) *rr++ = *cs;\n  /* #325: (@31[4, 12, 16, 24, 32, 36, 44, 48] = @48) */\n  for (cii=casadi_s7, rr=w31, cs=w48; cii!=casadi_s7+8; ++cii, ++cs) rr[*cii] = *cs;\n  /* #326: @34 = zeros(2x1,0nz) */\n  /* #327: @32 = ones(17x1,3nz) */\n  casadi_fill(w32, 3, 1.);\n  /* #328: {@1, @8} = vertsplit(@32) */\n  casadi_copy(w32, 2, w01);\n  w08 = w32[2];\n  /* #329: @1 = reshape(@1) */\n  /* #330: @9 = @1[0] */\n  for (rr=(&w09), cs=w01+0; cs!=w01+1; cs+=1) *rr++ = *cs;\n  /* #331: @35 = 00 */\n  /* #332: @36 = 00 */\n  /* #333: @3 = zeros(2x1) */\n  casadi_clear(w03, 2);\n  /* #334: @13 = @1[0] */\n  for (rr=(&w13), cs=w01+0; cs!=w01+1; cs+=1) *rr++ = *cs;\n  /* #335: @3 = mac(@6,@13,@3) */\n  casadi_mtimes(w06, casadi_s3, (&w13), casadi_s5, w03, casadi_s1, w, 0);\n  /* #336: @3 = (-@3) */\n  for (i=0, rr=w03, cs=w03; i<2; ++i) *rr++ = (- *cs++ );\n  /* #337: @37 = 00 */\n  /* #338: @38 = 00 */\n  /* #339: @13 = @1[1] */\n  for (rr=(&w13), cs=w01+1; cs!=w01+2; cs+=1) *rr++ = *cs;\n  /* #340: @39 = 00 */\n  /* #341: @40 = 00 */\n  /* #342: @18 = zeros(2x1) */\n  casadi_clear(w18, 2);\n  /* #343: @17 = @1[1] */\n  for (rr=(&w17), cs=w01+1; cs!=w01+2; cs+=1) *rr++ = *cs;\n  /* #344: @18 = mac(@16,@17,@18) */\n  casadi_mtimes(w16, casadi_s3, (&w17), casadi_s5, w18, casadi_s1, w, 0);\n  /* #345: @18 = (-@18) */\n  for (i=0, rr=w18, cs=w18; i<2; ++i) *rr++ = (- *cs++ );\n  /* #346: @41 = 00 */\n  /* #347: @42 = 00 */\n  /* #348: @8 = @8' */\n  /* #349: @17 = @8[0] */\n  for (rr=(&w17), cs=(&w08)+0; cs!=(&w08)+1; cs+=1) *rr++ = *cs;\n  /* #350: @15 = (@15*@17) */\n  for (i=0, rr=w15; i<2; ++i) (*rr++) *= w17;\n  /* #351: @15 = (-@15) */\n  for (i=0, rr=w15, cs=w15; i<2; ++i) *rr++ = (- *cs++ );\n  /* #352: @17 = @8[0] */\n  for (rr=(&w17), cs=(&w08)+0; cs!=(&w08)+1; cs+=1) *rr++ = *cs;\n  /* #353: @21 = @8[0] */\n  for (rr=(&w21), cs=(&w08)+0; cs!=(&w08)+1; cs+=1) *rr++ = *cs;\n  /* #354: @49 = vertcat(@34, @9, @35, @36, @3, @37, @38, @13, @39, @40, @18, @41, @42, @15, @17, @21) */\n  rr=w49;\n  *rr++ = w09;\n  for (i=0, cs=w03; i<2; ++i) *rr++ = *cs++;\n  *rr++ = w13;\n  for (i=0, cs=w18; i<2; ++i) *rr++ = *cs++;\n  for (i=0, cs=w15; i<2; ++i) *rr++ = *cs++;\n  *rr++ = w17;\n  *rr++ = w21;\n  /* #355: @50 = @49[:10] */\n  for (rr=w50, cs=w49+0; cs!=w49+10; cs+=1) *rr++ = *cs;\n  /* #356: (@31[8, 13, 17, 28, 33, 37, 45, 49, 50, 51] = @50) */\n  for (cii=casadi_s8, rr=w31, cs=w50; cii!=casadi_s8+10; ++cii, ++cs) rr[*cii] = *cs;\n  /* #357: @34 = zeros(2x1,0nz) */\n  /* #358: @16 = ones(17x1,4nz) */\n  casadi_fill(w16, 4, 1.);\n  /* #359: {NULL, @6} = vertsplit(@16) */\n  casadi_copy(w16, 4, w06);\n  /* #360: @6 = @6' */\n  /* #361: @9 = @6[0] */\n  for (rr=(&w09), cs=w06+0; cs!=w06+1; cs+=1) *rr++ = *cs;\n  /* #362: @5 = (@5*@9) */\n  for (i=0, rr=w05; i<2; ++i) (*rr++) *= w09;\n  /* #363: @5 = (-@5) */\n  for (i=0, rr=w05, cs=w05; i<2; ++i) *rr++ = (- *cs++ );\n  /* #364: @9 = @6[0] */\n  for (rr=(&w09), cs=w06+0; cs!=w06+1; cs+=1) *rr++ = *cs;\n  /* #365: @13 = @6[0] */\n  for (rr=(&w13), cs=w06+0; cs!=w06+1; cs+=1) *rr++ = *cs;\n  /* #366: @17 = @6[1] */\n  for (rr=(&w17), cs=w06+1; cs!=w06+2; cs+=1) *rr++ = *cs;\n  /* #367: @10 = (@10*@17) */\n  for (i=0, rr=w10; i<2; ++i) (*rr++) *= w17;\n  /* #368: @10 = (-@10) */\n  for (i=0, rr=w10, cs=w10; i<2; ++i) *rr++ = (- *cs++ );\n  /* #369: @17 = @6[1] */\n  for (rr=(&w17), cs=w06+1; cs!=w06+2; cs+=1) *rr++ = *cs;\n  /* #370: @21 = @6[1] */\n  for (rr=(&w21), cs=w06+1; cs!=w06+2; cs+=1) *rr++ = *cs;\n  /* #371: @8 = @6[2] */\n  for (rr=(&w08), cs=w06+2; cs!=w06+3; cs+=1) *rr++ = *cs;\n  /* #372: @11 = (@11*@8) */\n  for (i=0, rr=w11; i<2; ++i) (*rr++) *= w08;\n  /* #373: @11 = (-@11) */\n  for (i=0, rr=w11, cs=w11; i<2; ++i) *rr++ = (- *cs++ );\n  /* #374: @8 = @6[2] */\n  for (rr=(&w08), cs=w06+2; cs!=w06+3; cs+=1) *rr++ = *cs;\n  /* #375: @0 = @6[2] */\n  for (rr=(&w00), cs=w06+2; cs!=w06+3; cs+=1) *rr++ = *cs;\n  /* #376: @25 = @6[3] */\n  for (rr=(&w25), cs=w06+3; cs!=w06+4; cs+=1) *rr++ = *cs;\n  /* #377: @14 = (@14*@25) */\n  for (i=0, rr=w14; i<2; ++i) (*rr++) *= w25;\n  /* #378: @14 = (-@14) */\n  for (i=0, rr=w14, cs=w14; i<2; ++i) *rr++ = (- *cs++ );\n  /* #379: @25 = @6[3] */\n  for (rr=(&w25), cs=w06+3; cs!=w06+4; cs+=1) *rr++ = *cs;\n  /* #380: @51 = @6[3] */\n  for (rr=(&w51), cs=w06+3; cs!=w06+4; cs+=1) *rr++ = *cs;\n  /* #381: @35 = zeros(2x1,0nz) */\n  /* #382: @36 = 00 */\n  /* #383: @37 = 00 */\n  /* #384: @52 = vertcat(@34, @5, @9, @13, @10, @17, @21, @11, @8, @0, @14, @25, @51, @35, @36, @37) */\n  rr=w52;\n  for (i=0, cs=w05; i<2; ++i) *rr++ = *cs++;\n  *rr++ = w09;\n  *rr++ = w13;\n  for (i=0, cs=w10; i<2; ++i) *rr++ = *cs++;\n  *rr++ = w17;\n  *rr++ = w21;\n  for (i=0, cs=w11; i<2; ++i) *rr++ = *cs++;\n  *rr++ = w08;\n  *rr++ = w00;\n  for (i=0, cs=w14; i<2; ++i) *rr++ = *cs++;\n  *rr++ = w25;\n  *rr++ = w51;\n  /* #385: @53 = @52[:16] */\n  for (rr=w53, cs=w52+0; cs!=w52+16; cs+=1) *rr++ = *cs;\n  /* #386: (@31[5, 9, 10, 11, 15, 19, 20, 21, 25, 29, 30, 31, 35, 39, 40, 41] = @53) */\n  for (cii=casadi_s9, rr=w31, cs=w53; cii!=casadi_s9+16; ++cii, ++cs) rr[*cii] = *cs;\n  /* #387: @54 = @31' */\n  casadi_trans(w31,casadi_s11, w54, casadi_s10, iw);\n  /* #388: output[3][0] = @54 */\n  casadi_copy(w54, 52, res[3]);\n  return 0;\n}\n\n/* nlp_hess_l:(x[17],p[14],lam_f,lam_g[22])->(hess_gamma_x_x[17x17,29nz]) */\nstatic int casadi_f5(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {\n  casadi_int i, j;\n  casadi_real *rr, *tt, *w00=w+1, *w01=w+30, w02, *w03=w+43, *w04=w+45, *w05=w+56, *w06=w+62, w07, *w08=w+68, *w09=w+72;\n  casadi_real *w10=w+76, *w11=w+80, *w12=w+84, *w13=w+88, *w14=w+92, *w15=w+96, *w16=w+100, *w17=w+104, *w18=w+108, *w19=w+112, *w20=w+116, *w21=w+121;\n  casadi_real *w22=w+138, *w23=w+144;\n  const casadi_int *cii;\n  const casadi_real *cs;\n  /* #0: @0 = zeros(17x17,29nz) */\n  casadi_clear(w00, 29);\n  /* #1: @1 = zeros(2x6) */\n  casadi_clear(w01, 12);\n  /* #2: @2 = input[2][0] */\n  w02 = arg[2] ? arg[2][0] : 0;\n  /* #3: @3 = zeros(1x2) */\n  casadi_clear(w03, 2);\n  /* #4: @4 = ones(17x1,11nz) */\n  casadi_fill(w04, 11, 1.);\n  /* #5: {@5, @6} = vertsplit(@4) */\n  casadi_copy(w04, 6, w05);\n  casadi_copy(w04+6, 5, w06);\n  /* #6: @5 = reshape(@5) */\n  /* #7: @7 = @5[5] */\n  for (rr=(&w07), cs=w05+5; cs!=w05+6; cs+=1) *rr++ = *cs;\n  /* #8: @7 = @7' */\n  /* #9: @8 = \n  [[5000, 0], \n   [0, 10]] */\n  casadi_copy(casadi_c1, 4, w08);\n  /* #10: @3 = mac(@7,@8,@3) */\n  casadi_mtimes((&w07), casadi_s13, w08, casadi_s3, w03, casadi_s12, w, 0);\n  /* #11: @3 = @3' */\n  /* #12: @3 = (@2*@3) */\n  for (i=0, rr=w03, cs=w03; i<2; ++i) (*rr++)  = (w02*(*cs++));\n  /* #13: (@1[10:12] += @3) */\n  for (rr=w01+10, cs=w03; rr!=w01+12; rr+=1) *rr += *cs++;\n  /* #14: @3 = zeros(1x2) */\n  casadi_clear(w03, 2);\n  /* #15: @7 = @5[5] */\n  for (rr=(&w07), cs=w05+5; cs!=w05+6; cs+=1) *rr++ = *cs;\n  /* #16: @7 = @7' */\n  /* #17: @7 = (@2*@7) */\n  w07  = (w02*w07);\n  /* #18: @9 = @8' */\n  for (i=0, rr=w09, cs=w08; i<2; ++i) for (j=0; j<2; ++j) rr[i+j*2] = *cs++;\n  /* #19: @3 = mac(@7,@9,@3) */\n  casadi_mtimes((&w07), casadi_s13, w09, casadi_s3, w03, casadi_s12, w, 0);\n  /* #20: @3 = @3' */\n  /* #21: (@1[10:12] += @3) */\n  for (rr=w01+10, cs=w03; rr!=w01+12; rr+=1) *rr += *cs++;\n  /* #22: @3 = zeros(1x2) */\n  casadi_clear(w03, 2);\n  /* #23: @7 = @5[4] */\n  for (rr=(&w07), cs=w05+4; cs!=w05+5; cs+=1) *rr++ = *cs;\n  /* #24: @7 = @7' */\n  /* #25: @10 = \n  [[500, 0], \n   [0, 1]] */\n  casadi_copy(casadi_c0, 4, w10);\n  /* #26: @3 = mac(@7,@10,@3) */\n  casadi_mtimes((&w07), casadi_s13, w10, casadi_s3, w03, casadi_s12, w, 0);\n  /* #27: @3 = @3' */\n  /* #28: @3 = (@2*@3) */\n  for (i=0, rr=w03, cs=w03; i<2; ++i) (*rr++)  = (w02*(*cs++));\n  /* #29: (@1[8:10] += @3) */\n  for (rr=w01+8, cs=w03; rr!=w01+10; rr+=1) *rr += *cs++;\n  /* #30: @3 = zeros(1x2) */\n  casadi_clear(w03, 2);\n  /* #31: @7 = @5[4] */\n  for (rr=(&w07), cs=w05+4; cs!=w05+5; cs+=1) *rr++ = *cs;\n  /* #32: @7 = @7' */\n  /* #33: @7 = (@2*@7) */\n  w07  = (w02*w07);\n  /* #34: @11 = @10' */\n  for (i=0, rr=w11, cs=w10; i<2; ++i) for (j=0; j<2; ++j) rr[i+j*2] = *cs++;\n  /* #35: @3 = mac(@7,@11,@3) */\n  casadi_mtimes((&w07), casadi_s13, w11, casadi_s3, w03, casadi_s12, w, 0);\n  /* #36: @3 = @3' */\n  /* #37: (@1[8:10] += @3) */\n  for (rr=w01+8, cs=w03; rr!=w01+10; rr+=1) *rr += *cs++;\n  /* #38: @3 = zeros(1x2) */\n  casadi_clear(w03, 2);\n  /* #39: @7 = @5[3] */\n  for (rr=(&w07), cs=w05+3; cs!=w05+4; cs+=1) *rr++ = *cs;\n  /* #40: @7 = @7' */\n  /* #41: @12 = \n  [[500, 0], \n   [0, 1]] */\n  casadi_copy(casadi_c0, 4, w12);\n  /* #42: @3 = mac(@7,@12,@3) */\n  casadi_mtimes((&w07), casadi_s13, w12, casadi_s3, w03, casadi_s12, w, 0);\n  /* #43: @3 = @3' */\n  /* #44: @3 = (@2*@3) */\n  for (i=0, rr=w03, cs=w03; i<2; ++i) (*rr++)  = (w02*(*cs++));\n  /* #45: (@1[6:8] += @3) */\n  for (rr=w01+6, cs=w03; rr!=w01+8; rr+=1) *rr += *cs++;\n  /* #46: @3 = zeros(1x2) */\n  casadi_clear(w03, 2);\n  /* #47: @7 = @5[3] */\n  for (rr=(&w07), cs=w05+3; cs!=w05+4; cs+=1) *rr++ = *cs;\n  /* #48: @7 = @7' */\n  /* #49: @7 = (@2*@7) */\n  w07  = (w02*w07);\n  /* #50: @13 = @12' */\n  for (i=0, rr=w13, cs=w12; i<2; ++i) for (j=0; j<2; ++j) rr[i+j*2] = *cs++;\n  /* #51: @3 = mac(@7,@13,@3) */\n  casadi_mtimes((&w07), casadi_s13, w13, casadi_s3, w03, casadi_s12, w, 0);\n  /* #52: @3 = @3' */\n  /* #53: (@1[6:8] += @3) */\n  for (rr=w01+6, cs=w03; rr!=w01+8; rr+=1) *rr += *cs++;\n  /* #54: @3 = zeros(1x2) */\n  casadi_clear(w03, 2);\n  /* #55: @7 = @5[2] */\n  for (rr=(&w07), cs=w05+2; cs!=w05+3; cs+=1) *rr++ = *cs;\n  /* #56: @7 = @7' */\n  /* #57: @14 = \n  [[500, 0], \n   [0, 1]] */\n  casadi_copy(casadi_c0, 4, w14);\n  /* #58: @3 = mac(@7,@14,@3) */\n  casadi_mtimes((&w07), casadi_s13, w14, casadi_s3, w03, casadi_s12, w, 0);\n  /* #59: @3 = @3' */\n  /* #60: @3 = (@2*@3) */\n  for (i=0, rr=w03, cs=w03; i<2; ++i) (*rr++)  = (w02*(*cs++));\n  /* #61: (@1[4:6] += @3) */\n  for (rr=w01+4, cs=w03; rr!=w01+6; rr+=1) *rr += *cs++;\n  /* #62: @3 = zeros(1x2) */\n  casadi_clear(w03, 2);\n  /* #63: @7 = @5[2] */\n  for (rr=(&w07), cs=w05+2; cs!=w05+3; cs+=1) *rr++ = *cs;\n  /* #64: @7 = @7' */\n  /* #65: @7 = (@2*@7) */\n  w07  = (w02*w07);\n  /* #66: @15 = @14' */\n  for (i=0, rr=w15, cs=w14; i<2; ++i) for (j=0; j<2; ++j) rr[i+j*2] = *cs++;\n  /* #67: @3 = mac(@7,@15,@3) */\n  casadi_mtimes((&w07), casadi_s13, w15, casadi_s3, w03, casadi_s12, w, 0);\n  /* #68: @3 = @3' */\n  /* #69: (@1[4:6] += @3) */\n  for (rr=w01+4, cs=w03; rr!=w01+6; rr+=1) *rr += *cs++;\n  /* #70: @3 = zeros(1x2) */\n  casadi_clear(w03, 2);\n  /* #71: @7 = @5[1] */\n  for (rr=(&w07), cs=w05+1; cs!=w05+2; cs+=1) *rr++ = *cs;\n  /* #72: @7 = @7' */\n  /* #73: @16 = \n  [[500, 0], \n   [0, 1]] */\n  casadi_copy(casadi_c0, 4, w16);\n  /* #74: @3 = mac(@7,@16,@3) */\n  casadi_mtimes((&w07), casadi_s13, w16, casadi_s3, w03, casadi_s12, w, 0);\n  /* #75: @3 = @3' */\n  /* #76: @3 = (@2*@3) */\n  for (i=0, rr=w03, cs=w03; i<2; ++i) (*rr++)  = (w02*(*cs++));\n  /* #77: (@1[2:4] += @3) */\n  for (rr=w01+2, cs=w03; rr!=w01+4; rr+=1) *rr += *cs++;\n  /* #78: @3 = zeros(1x2) */\n  casadi_clear(w03, 2);\n  /* #79: @7 = @5[1] */\n  for (rr=(&w07), cs=w05+1; cs!=w05+2; cs+=1) *rr++ = *cs;\n  /* #80: @7 = @7' */\n  /* #81: @7 = (@2*@7) */\n  w07  = (w02*w07);\n  /* #82: @17 = @16' */\n  for (i=0, rr=w17, cs=w16; i<2; ++i) for (j=0; j<2; ++j) rr[i+j*2] = *cs++;\n  /* #83: @3 = mac(@7,@17,@3) */\n  casadi_mtimes((&w07), casadi_s13, w17, casadi_s3, w03, casadi_s12, w, 0);\n  /* #84: @3 = @3' */\n  /* #85: (@1[2:4] += @3) */\n  for (rr=w01+2, cs=w03; rr!=w01+4; rr+=1) *rr += *cs++;\n  /* #86: @3 = zeros(1x2) */\n  casadi_clear(w03, 2);\n  /* #87: @7 = @5[0] */\n  for (rr=(&w07), cs=w05+0; cs!=w05+1; cs+=1) *rr++ = *cs;\n  /* #88: @7 = @7' */\n  /* #89: @18 = \n  [[500, 0], \n   [0, 1]] */\n  casadi_copy(casadi_c0, 4, w18);\n  /* #90: @3 = mac(@7,@18,@3) */\n  casadi_mtimes((&w07), casadi_s13, w18, casadi_s3, w03, casadi_s12, w, 0);\n  /* #91: @3 = @3' */\n  /* #92: @3 = (@2*@3) */\n  for (i=0, rr=w03, cs=w03; i<2; ++i) (*rr++)  = (w02*(*cs++));\n  /* #93: (@1[:2] += @3) */\n  for (rr=w01+0, cs=w03; rr!=w01+2; rr+=1) *rr += *cs++;\n  /* #94: @3 = zeros(1x2) */\n  casadi_clear(w03, 2);\n  /* #95: @7 = @5[0] */\n  for (rr=(&w07), cs=w05+0; cs!=w05+1; cs+=1) *rr++ = *cs;\n  /* #96: @7 = @7' */\n  /* #97: @7 = (@2*@7) */\n  w07  = (w02*w07);\n  /* #98: @19 = @18' */\n  for (i=0, rr=w19, cs=w18; i<2; ++i) for (j=0; j<2; ++j) rr[i+j*2] = *cs++;\n  /* #99: @3 = mac(@7,@19,@3) */\n  casadi_mtimes((&w07), casadi_s13, w19, casadi_s3, w03, casadi_s12, w, 0);\n  /* #100: @3 = @3' */\n  /* #101: (@1[:2] += @3) */\n  for (rr=w01+0, cs=w03; rr!=w01+2; rr+=1) *rr += *cs++;\n  /* #102: @1 = vec(@1) */\n  /* #103: @20 = zeros(1x5) */\n  casadi_clear(w20, 5);\n  /* #104: @6 = @6' */\n  /* #105: @7 = @6[4] */\n  for (rr=(&w07), cs=w06+4; cs!=w06+5; cs+=1) *rr++ = *cs;\n  /* #106: @7 = (2.*@7) */\n  w07 = (2.* w07 );\n  /* #107: @7 = (@2*@7) */\n  w07  = (w02*w07);\n  /* #108: (@20[4] += @7) */\n  for (rr=w20+4, cs=(&w07); rr!=w20+5; rr+=1) *rr += *cs++;\n  /* #109: @7 = @6[3] */\n  for (rr=(&w07), cs=w06+3; cs!=w06+4; cs+=1) *rr++ = *cs;\n  /* #110: @7 = (2.*@7) */\n  w07 = (2.* w07 );\n  /* #111: @7 = (@2*@7) */\n  w07  = (w02*w07);\n  /* #112: (@20[3] += @7) */\n  for (rr=w20+3, cs=(&w07); rr!=w20+4; rr+=1) *rr += *cs++;\n  /* #113: @7 = @6[2] */\n  for (rr=(&w07), cs=w06+2; cs!=w06+3; cs+=1) *rr++ = *cs;\n  /* #114: @7 = (2.*@7) */\n  w07 = (2.* w07 );\n  /* #115: @7 = (@2*@7) */\n  w07  = (w02*w07);\n  /* #116: (@20[2] += @7) */\n  for (rr=w20+2, cs=(&w07); rr!=w20+3; rr+=1) *rr += *cs++;\n  /* #117: @7 = @6[1] */\n  for (rr=(&w07), cs=w06+1; cs!=w06+2; cs+=1) *rr++ = *cs;\n  /* #118: @7 = (2.*@7) */\n  w07 = (2.* w07 );\n  /* #119: @7 = (@2*@7) */\n  w07  = (w02*w07);\n  /* #120: (@20[1] += @7) */\n  for (rr=w20+1, cs=(&w07); rr!=w20+2; rr+=1) *rr += *cs++;\n  /* #121: @7 = @6[0] */\n  for (rr=(&w07), cs=w06+0; cs!=w06+1; cs+=1) *rr++ = *cs;\n  /* #122: @7 = (2.*@7) */\n  w07 = (2.* w07 );\n  /* #123: @7 = (@2*@7) */\n  w07  = (w02*w07);\n  /* #124: (@20[0] += @7) */\n  for (rr=w20+0, cs=(&w07); rr!=w20+1; rr+=1) *rr += *cs++;\n  /* #125: @20 = @20' */\n  /* #126: @21 = vertcat(@1, @20) */\n  rr=w21;\n  for (i=0, cs=w01; i<12; ++i) *rr++ = *cs++;\n  for (i=0, cs=w20; i<5; ++i) *rr++ = *cs++;\n  /* #127: (@0[0, 1, 4, 5, 8, 9, 12, 13, 16, 17, 20, 21, 24, 25, 26, 27, 28] = @21) */\n  for (cii=casadi_s14, rr=w00, cs=w21; cii!=casadi_s14+17; ++cii, ++cs) rr[*cii] = *cs;\n  /* #128: (@0[0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 25, 26, 27, 28] = @21) */\n  for (cii=casadi_s15, rr=w00, cs=w21; cii!=casadi_s15+17; ++cii, ++cs) rr[*cii] = *cs;\n  /* #129: @1 = zeros(2x6) */\n  casadi_clear(w01, 12);\n  /* #130: @3 = zeros(1x2) */\n  casadi_clear(w03, 2);\n  /* #131: @5 = ones(17x1,6nz) */\n  casadi_fill(w05, 6, 1.);\n  /* #132: {@22, NULL} = vertsplit(@5) */\n  casadi_copy(w05, 6, w22);\n  /* #133: @22 = reshape(@22) */\n  /* #134: @7 = @22[5] */\n  for (rr=(&w07), cs=w22+5; cs!=w22+6; cs+=1) *rr++ = *cs;\n  /* #135: @7 = @7' */\n  /* #136: @3 = mac(@7,@8,@3) */\n  casadi_mtimes((&w07), casadi_s16, w08, casadi_s3, w03, casadi_s12, w, 0);\n  /* #137: @3 = @3' */\n  /* #138: @3 = (@2*@3) */\n  for (i=0, rr=w03, cs=w03; i<2; ++i) (*rr++)  = (w02*(*cs++));\n  /* #139: (@1[10:12] += @3) */\n  for (rr=w01+10, cs=w03; rr!=w01+12; rr+=1) *rr += *cs++;\n  /* #140: @3 = zeros(1x2) */\n  casadi_clear(w03, 2);\n  /* #141: @7 = @22[5] */\n  for (rr=(&w07), cs=w22+5; cs!=w22+6; cs+=1) *rr++ = *cs;\n  /* #142: @7 = @7' */\n  /* #143: @7 = (@2*@7) */\n  w07  = (w02*w07);\n  /* #144: @3 = mac(@7,@9,@3) */\n  casadi_mtimes((&w07), casadi_s16, w09, casadi_s3, w03, casadi_s12, w, 0);\n  /* #145: @3 = @3' */\n  /* #146: (@1[10:12] += @3) */\n  for (rr=w01+10, cs=w03; rr!=w01+12; rr+=1) *rr += *cs++;\n  /* #147: @3 = zeros(1x2) */\n  casadi_clear(w03, 2);\n  /* #148: @7 = @22[4] */\n  for (rr=(&w07), cs=w22+4; cs!=w22+5; cs+=1) *rr++ = *cs;\n  /* #149: @7 = @7' */\n  /* #150: @3 = mac(@7,@10,@3) */\n  casadi_mtimes((&w07), casadi_s16, w10, casadi_s3, w03, casadi_s12, w, 0);\n  /* #151: @3 = @3' */\n  /* #152: @3 = (@2*@3) */\n  for (i=0, rr=w03, cs=w03; i<2; ++i) (*rr++)  = (w02*(*cs++));\n  /* #153: (@1[8:10] += @3) */\n  for (rr=w01+8, cs=w03; rr!=w01+10; rr+=1) *rr += *cs++;\n  /* #154: @3 = zeros(1x2) */\n  casadi_clear(w03, 2);\n  /* #155: @7 = @22[4] */\n  for (rr=(&w07), cs=w22+4; cs!=w22+5; cs+=1) *rr++ = *cs;\n  /* #156: @7 = @7' */\n  /* #157: @7 = (@2*@7) */\n  w07  = (w02*w07);\n  /* #158: @3 = mac(@7,@11,@3) */\n  casadi_mtimes((&w07), casadi_s16, w11, casadi_s3, w03, casadi_s12, w, 0);\n  /* #159: @3 = @3' */\n  /* #160: (@1[8:10] += @3) */\n  for (rr=w01+8, cs=w03; rr!=w01+10; rr+=1) *rr += *cs++;\n  /* #161: @3 = zeros(1x2) */\n  casadi_clear(w03, 2);\n  /* #162: @7 = @22[3] */\n  for (rr=(&w07), cs=w22+3; cs!=w22+4; cs+=1) *rr++ = *cs;\n  /* #163: @7 = @7' */\n  /* #164: @3 = mac(@7,@12,@3) */\n  casadi_mtimes((&w07), casadi_s16, w12, casadi_s3, w03, casadi_s12, w, 0);\n  /* #165: @3 = @3' */\n  /* #166: @3 = (@2*@3) */\n  for (i=0, rr=w03, cs=w03; i<2; ++i) (*rr++)  = (w02*(*cs++));\n  /* #167: (@1[6:8] += @3) */\n  for (rr=w01+6, cs=w03; rr!=w01+8; rr+=1) *rr += *cs++;\n  /* #168: @3 = zeros(1x2) */\n  casadi_clear(w03, 2);\n  /* #169: @7 = @22[3] */\n  for (rr=(&w07), cs=w22+3; cs!=w22+4; cs+=1) *rr++ = *cs;\n  /* #170: @7 = @7' */\n  /* #171: @7 = (@2*@7) */\n  w07  = (w02*w07);\n  /* #172: @3 = mac(@7,@13,@3) */\n  casadi_mtimes((&w07), casadi_s16, w13, casadi_s3, w03, casadi_s12, w, 0);\n  /* #173: @3 = @3' */\n  /* #174: (@1[6:8] += @3) */\n  for (rr=w01+6, cs=w03; rr!=w01+8; rr+=1) *rr += *cs++;\n  /* #175: @3 = zeros(1x2) */\n  casadi_clear(w03, 2);\n  /* #176: @7 = @22[2] */\n  for (rr=(&w07), cs=w22+2; cs!=w22+3; cs+=1) *rr++ = *cs;\n  /* #177: @7 = @7' */\n  /* #178: @3 = mac(@7,@14,@3) */\n  casadi_mtimes((&w07), casadi_s16, w14, casadi_s3, w03, casadi_s12, w, 0);\n  /* #179: @3 = @3' */\n  /* #180: @3 = (@2*@3) */\n  for (i=0, rr=w03, cs=w03; i<2; ++i) (*rr++)  = (w02*(*cs++));\n  /* #181: (@1[4:6] += @3) */\n  for (rr=w01+4, cs=w03; rr!=w01+6; rr+=1) *rr += *cs++;\n  /* #182: @3 = zeros(1x2) */\n  casadi_clear(w03, 2);\n  /* #183: @7 = @22[2] */\n  for (rr=(&w07), cs=w22+2; cs!=w22+3; cs+=1) *rr++ = *cs;\n  /* #184: @7 = @7' */\n  /* #185: @7 = (@2*@7) */\n  w07  = (w02*w07);\n  /* #186: @3 = mac(@7,@15,@3) */\n  casadi_mtimes((&w07), casadi_s16, w15, casadi_s3, w03, casadi_s12, w, 0);\n  /* #187: @3 = @3' */\n  /* #188: (@1[4:6] += @3) */\n  for (rr=w01+4, cs=w03; rr!=w01+6; rr+=1) *rr += *cs++;\n  /* #189: @3 = zeros(1x2) */\n  casadi_clear(w03, 2);\n  /* #190: @7 = @22[1] */\n  for (rr=(&w07), cs=w22+1; cs!=w22+2; cs+=1) *rr++ = *cs;\n  /* #191: @7 = @7' */\n  /* #192: @3 = mac(@7,@16,@3) */\n  casadi_mtimes((&w07), casadi_s16, w16, casadi_s3, w03, casadi_s12, w, 0);\n  /* #193: @3 = @3' */\n  /* #194: @3 = (@2*@3) */\n  for (i=0, rr=w03, cs=w03; i<2; ++i) (*rr++)  = (w02*(*cs++));\n  /* #195: (@1[2:4] += @3) */\n  for (rr=w01+2, cs=w03; rr!=w01+4; rr+=1) *rr += *cs++;\n  /* #196: @3 = zeros(1x2) */\n  casadi_clear(w03, 2);\n  /* #197: @7 = @22[1] */\n  for (rr=(&w07), cs=w22+1; cs!=w22+2; cs+=1) *rr++ = *cs;\n  /* #198: @7 = @7' */\n  /* #199: @7 = (@2*@7) */\n  w07  = (w02*w07);\n  /* #200: @3 = mac(@7,@17,@3) */\n  casadi_mtimes((&w07), casadi_s16, w17, casadi_s3, w03, casadi_s12, w, 0);\n  /* #201: @3 = @3' */\n  /* #202: (@1[2:4] += @3) */\n  for (rr=w01+2, cs=w03; rr!=w01+4; rr+=1) *rr += *cs++;\n  /* #203: @3 = zeros(1x2) */\n  casadi_clear(w03, 2);\n  /* #204: @7 = @22[0] */\n  for (rr=(&w07), cs=w22+0; cs!=w22+1; cs+=1) *rr++ = *cs;\n  /* #205: @7 = @7' */\n  /* #206: @3 = mac(@7,@18,@3) */\n  casadi_mtimes((&w07), casadi_s16, w18, casadi_s3, w03, casadi_s12, w, 0);\n  /* #207: @3 = @3' */\n  /* #208: @3 = (@2*@3) */\n  for (i=0, rr=w03, cs=w03; i<2; ++i) (*rr++)  = (w02*(*cs++));\n  /* #209: (@1[:2] += @3) */\n  for (rr=w01+0, cs=w03; rr!=w01+2; rr+=1) *rr += *cs++;\n  /* #210: @3 = zeros(1x2) */\n  casadi_clear(w03, 2);\n  /* #211: @7 = @22[0] */\n  for (rr=(&w07), cs=w22+0; cs!=w22+1; cs+=1) *rr++ = *cs;\n  /* #212: @7 = @7' */\n  /* #213: @2 = (@2*@7) */\n  w02 *= w07;\n  /* #214: @3 = mac(@2,@19,@3) */\n  casadi_mtimes((&w02), casadi_s16, w19, casadi_s3, w03, casadi_s12, w, 0);\n  /* #215: @3 = @3' */\n  /* #216: (@1[:2] += @3) */\n  for (rr=w01+0, cs=w03; rr!=w01+2; rr+=1) *rr += *cs++;\n  /* #217: @1 = vec(@1) */\n  /* #218: (@0[:24:4;2:4] = @1) */\n  for (rr=w00+0, cs=w01; rr!=w00+24; rr+=4) for (tt=rr+2; tt!=rr+4; tt+=1) *tt = *cs++;\n  /* #219: (@0[1:25:2] = @1) */\n  for (rr=w00+1, cs=w01; rr!=w00+25; rr+=2) *rr = *cs++;\n  /* #220: @23 = @0' */\n  casadi_trans(w00,casadi_s17, w23, casadi_s17, iw);\n  /* #221: output[0][0] = @23 */\n  casadi_copy(w23, 29, res[0]);\n  return 0;\n}\n\n/* qpsol:(h[17x17,29nz],g[17],a[22x17,52nz],lba[22],uba[22],lbx[17],ubx[17],x0[17],lam_x0[17],lam_a0[22],q[],p[])->(x[17],cost,lam_a[22],lam_x[17]) */\nstatic int casadi_f6(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {\n  OSQPWorkspace *work=casadi_f6_mem[mem];\n  casadi_int i, n, offset;\n  /* Set objective */\n  if (arg[1]) {\n    casadi_copy(arg[1], 17, w);\n  } else {\n    casadi_clear(w, 17);\n  }\n  if (osqp_update_lin_cost(work, w)) return 1;\n  /* Set bounds */\n  if (arg[5]) {\n    casadi_copy(arg[5], 17, w);\n  } else {\n    casadi_fill(w, 17, -casadi_inf);\n  }\n  if (arg[3]) {\n    casadi_copy(arg[3], 22, w+17);\n  } else {\n    casadi_fill(w+17, 22, -casadi_inf);\n  }\n  if (arg[6]) {\n    casadi_copy(arg[6], 17, w+39);\n  } else {\n    casadi_fill(w+39, 17, casadi_inf);\n  }\n  if (arg[4]) {\n    casadi_copy(arg[4], 22, w+56);\n  } else {\n    casadi_fill(w+56, 22, casadi_inf);\n  }\n  if (osqp_update_bounds(work, w, w+39)) return 1;\n  /* Project Hessian */\n  casadi_tri_project(arg[0], casadi_s17, w, 0);/* Get constraint matrix */\n  offset = 0;\n  for (i=0; i< 17; ++i) {\n    w[23+offset] = 1;\n    offset++;\n    n = casadi_s18[i+1]-casadi_s18[i];\n    casadi_copy(arg[2]+casadi_s18[i], n, w+offset+23);\n    offset+= n;\n  }\n  /* Pass Hessian and constraint matrices */\n  if (osqp_update_P_A(work, w, 0, 23, w+23, 0, 69)) return 1;\n  if (osqp_warm_start_x(work, arg[7])) return 1;\n  if (arg[8]) {\n    casadi_copy(arg[8], 17, w);\n  } else {\n    casadi_clear(w, 17);\n  }\n  if (arg[9]) {\n    casadi_copy(arg[9], 22, w+17);\n  } else {\n    casadi_clear(w+17, 22);\n  }\n  if (osqp_warm_start_y(work, w)) return 1;\n  if (osqp_solve(work)) return 1;\n  if (res[1]) casadi_copy(&work->info->obj_val, 1, res[1]);\n  if (res[0]) casadi_copy(work->solution->x, 17, res[0]);\n  if (res[3]) casadi_copy(work->solution->y, 17, res[3]);\n  if (res[2]) casadi_copy(work->solution->y+17, 22, res[2]);\n  if (work->info->status_val != OSQP_SOLVED) {\n    return -1000;\n  }\n  return 0;\n  return 0;\n}\n\nvoid casadi_f6_incref(void) {\n}\n\nvoid casadi_f6_decref(void) {\n}\n\nint casadi_f6_alloc_mem(void) {\n  return casadi_f6_mem_counter++;\n}\n\nint casadi_f6_init_mem(int mem) {\n  OSQPData data;\n  OSQPSettings settings;\n  c_int A_colind[18], A_row[69], H_colind[18], H_row[23], i;\n  casadi_real dummy[69];\n  csc A, H;\n  casadi_clear(dummy, 69);\n  for (i=0;i<69;++i) A_row[i] = casadi_s19[i];\n  for (i=0;i<18;++i) A_colind[i] = casadi_s20[i];\n  for (i=0;i<23;++i) H_row[i] = casadi_s21[i];\n  for (i=0;i<18;++i) H_colind[i] = casadi_s22[i];\n  A.m = 39;\n  A.n = 17;\n  A.nz = 69;\n  A.nzmax = 69;\n  A.x = dummy;\n  A.i = A_row;\n  A.p = A_colind;\n  H.m = 17;\n  H.n = 17;\n  H.nz = 23;\n  H.nzmax = 23;\n  H.x = dummy;\n  H.i = H_row;\n  H.p = H_colind;\n  data.n = 17;\n  data.m = 39;\n  data.P = &H;\n  data.q = dummy;\n  data.A = &A;\n  data.l = dummy;\n  data.u = dummy;\n  osqp_set_default_settings(&settings);\n  settings.rho = 0.1;\n  settings.sigma = 1e-06;\n  settings.scaling = 10;\n  settings.adaptive_rho = 1;\n  settings.adaptive_rho_interval = 0;\n  settings.adaptive_rho_tolerance = 5;\n  settings.max_iter = 4000;\n  settings.eps_abs = 0.001;\n  settings.eps_rel = 0.001;\n  settings.eps_prim_inf = 0.0001;\n  settings.eps_dual_inf = 0.0001;\n  settings.alpha = 1.6;\n  settings.delta = 1e-06;\n  settings.polish = 0;\n  settings.polish_refine_iter = 3;\n  settings.verbose = 1;\n  settings.scaled_termination = 0;\n  settings.check_termination = 25;\n  settings.warm_start = 0;\n  return osqp_setup(&casadi_f6_mem[mem], &data, &settings)!=0;\n}\n\nvoid casadi_f6_free_mem(int mem) {\n  osqp_cleanup(casadi_f6_mem[mem]);\n}\n\nint casadi_f6_checkout(void) {\n  int mid;\n  if (casadi_f6_unused_stack_counter>=0) {\n    return casadi_f6_unused_stack[casadi_f6_unused_stack_counter--];\n  } else {\n    if (casadi_f6_mem_counter==CASADI_MAX_NUM_THREADS) return -1;\n    mid = casadi_f6_alloc_mem();\n    if (mid<0) return -1;\n    if(casadi_f6_init_mem(mid)) return -1;\n    return mid;\n  }\n}\n\nvoid casadi_f6_release(int mem) {\n  casadi_f6_unused_stack[++casadi_f6_unused_stack_counter] = mem;\n}\n\n/* solver:(x0[17],p[14],lbx[17],ubx[17],lbg[22],ubg[22],lam_x0[17],lam_g0[22])->(x[17],f,g[22],lam_x[17],lam_g[22],lam_p[14]) */\nstatic int casadi_f1(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {\n  casadi_int iter_count=0, ls_iter=0;\n  casadi_real F_sens, du_inf, dx_norminf, fk_cand, l1, l1_cand, l1_infeas, pr_inf, sigma=0.0, t=0.0, tl1;\n  const casadi_real one=1;\n  int flag, mid, ret;\n  struct casadi_nlpsol_data d_nlp;\n  struct casadi_nlpsol_prob p_nlp;\n  struct casadi_oracle_data d_oracle;\n  struct casadi_sqpmethod_data* d=&casadi_f1_mem[mem];\n  struct casadi_sqpmethod_prob p;\n  d_nlp.oracle = &d_oracle;\n  d_nlp.p = arg[1];\n  d_nlp.lbx = arg[2];\n  d_nlp.ubx = arg[3];\n  d_nlp.lbg = arg[4];\n  d_nlp.ubg = arg[5];\n  d_nlp.x0 = arg[0];\n  d_nlp.lam_x0 = arg[6];\n  d_nlp.lam_g0 = arg[7];\n  d_nlp.x = res[0];\n  d_nlp.f = res[1];\n  d_nlp.g = res[2];\n  d_nlp.lam_x = res[3];\n  d_nlp.lam_g = res[4];\n  d_nlp.lam_p = res[5];\n  d_nlp.prob = &p_nlp;\n  p_nlp.nx = 17;\n  p_nlp.ng = 22;\n  p_nlp.np = 14;\n  p_nlp.detect_bounds.ng = 0;\n  casadi_nlpsol_init(&d_nlp, &arg, &res, &iw, &w);\n  if (d_nlp.x0) {\n    casadi_copy(d_nlp.x0, 17, d_nlp.z);\n  } else {\n    casadi_clear(d_nlp.z, 17);\n  }\n  if (d_nlp.lbx) {\n    casadi_copy(d_nlp.lbx, 17, d_nlp.lbz);\n  } else {\n    casadi_fill(d_nlp.lbz, 17, -casadi_inf);\n  }\n  if (d_nlp.ubx) {\n    casadi_copy(d_nlp.ubx, 17, d_nlp.ubz);\n  } else {\n    casadi_fill(d_nlp.ubz, 17, casadi_inf);\n  }\n  if (d_nlp.lam_x0) {\n    casadi_copy(d_nlp.lam_x0, 17, d_nlp.lam);\n  } else {\n    casadi_clear(d_nlp.lam, 17);\n  }\n  if (d_nlp.lbg) {\n    casadi_copy(d_nlp.lbg, 22, d_nlp.lbz+17);\n  } else {\n    casadi_fill(d_nlp.lbz+17, 22, -casadi_inf);\n  }\n  if (d_nlp.ubg) {\n    casadi_copy(d_nlp.ubg, 22, d_nlp.ubz+17);\n  } else {\n    casadi_fill(d_nlp.ubz+17, 22, casadi_inf);\n  }\n  if (d_nlp.lam_g0) {\n    casadi_copy(d_nlp.lam_g0, 22, d_nlp.lam+17);\n  } else {\n    casadi_clear(d_nlp.lam+17, 22);\n  }\n  d->prob = &p;\n  p.sp_h = casadi_s17;\n  p.sp_a = casadi_s10;\n  p.merit_memsize = 4;\n  p.max_iter_ls = 3;\n  p.nlp = &p_nlp;\n  casadi_sqpmethod_init(d, &arg, &res, &iw, &w, 0, 0);\n  casadi_clear(d->dx, 17);\n  /* MAIN OPTIMIZATION LOOP */\n  while (1) {\n    /* Evaluate f, g and first order derivative information */\n    d->arg[0] = d_nlp.z;\n    d->arg[1] = d_nlp.p;\n    d->res[0] = &d_nlp.objective;\n    d->res[1] = d->gf;\n    d->res[2] = d_nlp.z+17;\n    d->res[3] = d->Jk;\n    if (casadi_f4(d->arg, d->res, d->iw, d->w, 0)) return 1;\n    /* Evaluate the gradient of the Lagrangian */\n    casadi_copy(d->gf, 17, d->gLag);\n    casadi_mv(d->Jk, casadi_s10, d_nlp.lam+17, d->gLag, 1);\n    casadi_axpy(17, 1.0, d_nlp.lam, d->gLag);\n    /* Primal infeasability */\n    pr_inf = casadi_max_viol(39, d_nlp.z, d_nlp.lbz, d_nlp.ubz);\n    /* inf-norm of lagrange gradient */\n    du_inf = casadi_norm_inf(17, d->gLag);\n    /* inf-norm of step */\n    dx_norminf = casadi_norm_inf(17, d->dx);\n    /* Checking convergence criteria */\n    if (iter_count >= 0 && pr_inf < 1e-06 && du_inf < 1e-06) break;\n    if (iter_count >= 50) break;\n    if (iter_count >= 1 && iter_count >= 0 && dx_norminf <= 1e-10) break;\n    /* Update/reset exact Hessian */\n    d->arg[0] = d_nlp.z;\n    d->arg[1] = d_nlp.p;\n    d->arg[2] = &one;\n    d->arg[3] = d_nlp.lam+17;\n    d->res[0] = d->Bk;\n    if (casadi_f5(d->arg, d->res, d->iw, d->w, 0)) return 1;\n    /* Formulate the QP */\n    casadi_copy(d_nlp.lbz, 39, d->lbdz);\n    casadi_axpy(39, -1.0, d_nlp.z, d->lbdz);\n    casadi_copy(d_nlp.ubz, 39, d->ubdz);\n    casadi_axpy(39, -1.0, d_nlp.z, d->ubdz);\n    /* Initial guess */\n    casadi_copy(d_nlp.lam, 39, d->dlam);\n    casadi_clear(d->dx, 17);\n    /* Increase counter */\n    iter_count++;\n    /* Solve the QP */\n    d->arg[0] = 0;\n    d->arg[1] = 0;\n    d->arg[2] = 0;\n    d->arg[3] = 0;\n    d->arg[4] = 0;\n    d->arg[5] = 0;\n    d->arg[6] = 0;\n    d->arg[7] = 0;\n    d->arg[8] = 0;\n    d->arg[9] = 0;\n    d->arg[10] = 0;\n    d->arg[11] = 0;\n    d->arg[0] = d->Bk;\n    d->arg[1] = d->gf;\n    d->arg[7] = d->dx;\n    d->arg[8] = d->dlam;\n    d->arg[9] = d->dlam+17;\n    d->arg[5] = d->lbdz;\n    d->arg[6] = d->ubdz;\n    d->arg[2] = d->Jk;\n    d->arg[3] = d->lbdz+17;\n    d->arg[4] = d->ubdz+17;\n    d->res[0] = 0;\n    d->res[1] = 0;\n    d->res[2] = 0;\n    d->res[3] = 0;\n    d->res[0] = d->dx;\n    d->res[3] = d->dlam;\n    d->res[2] = d->dlam+17;\n    mid = casadi_f6_checkout();\n    if (mid<0) return 1;\n    flag = casadi_f6(d->arg, d->res, d->iw, d->w, mid);\n    casadi_f6_release(mid);\n    ret = flag;\n    if (ret == -1000) return -1000;\n    /* Calculate penalty parameter of merit function */\n    sigma = casadi_fmax(sigma, (1.01*casadi_norm_inf(39, d->dlam)));;\n    /* Calculate L1-merit function in the actual iterate */\n    l1_infeas = casadi_sum_viol(39, d_nlp.z, d_nlp.lbz, d_nlp.ubz);\n    l1 = d_nlp.objective + sigma * l1_infeas;\n    /* Detecting indefiniteness */\n    /* Right-hand side of Armijo condition */\n    F_sens = casadi_dot(17, d->dx, d->gf);\n    tl1 = F_sens - sigma * l1_infeas;\n    /* Stepsize */\n    t = 1.0;\n    /* Merit function value in candidate */\n    l1_cand = 0.0;\n    /* Reset line-search counter, success marker */\n    ls_iter = 0;\n    /* Line-search loop */\n    while (1) {\n      /*  Increase counter */\n      ls_iter++;\n      /* Candidate step */\n      casadi_copy(d_nlp.z, 17, d->z_cand);\n      casadi_axpy(17, t, d->dx, d->z_cand);\n      /* Evaluating objective and constraints */\n      d->arg[0] = d->z_cand;\n      d->arg[1] = d_nlp.p;\n      d->res[0] = &fk_cand;\n      d->res[1] = d->z_cand+17;\n      if (casadi_f3(d->arg, d->res, d->iw, d->w, 0)) {\n        /* Avoid infinite recursion */\n        if (ls_iter == 3) {\n          break;\n        }\n        /* line-search failed, skip iteration */\n        t = 0.8* t;\n        continue;\n      }\n      /* Calculating merit-function in candidate */\n      l1_cand = fk_cand + sigma * casadi_sum_viol(39, d->z_cand, d_nlp.lbz, d_nlp.ubz);\n      if (l1_cand <= l1 + t * 0.0001* tl1) {\n        break;\n      }\n      /* Line-search not successful, but we accept it. */\n      if (ls_iter == 3) {\n        break;\n      }\n      /* Backtracking */\n      t = 0.8* t;\n    }\n    /* Candidate accepted, update dual variables */\n    casadi_scal(39, 1-t, d_nlp.lam);\n    casadi_axpy(39, t, d->dlam, d_nlp.lam);\n    casadi_scal(17, t, d->dx);\n    /* Take step */\n    casadi_axpy(17, 1.0, d->dx, d_nlp.z);\n  }\n  d->arg[0] = d_nlp.z;\n  d->arg[1] = d_nlp.p;\n  d->arg[2] = &one;\n  d->arg[3] = d_nlp.lam+17;\n  d->res[0] = 0;\n  d->res[1] = 0;\n  d->res[2] = 0;\n  d->res[3] = d_nlp.lam_p;\n  if (casadi_f2(d->arg, d->res, d->iw, d->w, 0)) return 1;\n  casadi_scal(14, -1.0, d_nlp.lam_p);\n  casadi_copy(d_nlp.z, 17, d_nlp.x);\n  casadi_copy(d_nlp.z + 17, 22, d_nlp.g);\n  casadi_copy(d_nlp.lam, 17, d_nlp.lam_x);\n  casadi_copy(d_nlp.lam + 17, 22, d_nlp.lam_g);\n  if (d_nlp.f) casadi_copy(&d_nlp.objective, 1, d_nlp.f);\n  if (d_nlp.lam_p) casadi_copy(d_nlp.lam_p, 14, d_nlp.lam_p);\n  return 0;\n}\n\nint casadi_f1_alloc_mem(void) {\n  return casadi_f1_mem_counter++;\n}\n\nint casadi_f1_init_mem(int mem) {\n  return 0;\n}\n\nvoid casadi_f1_free_mem(int mem) {\n}\n\nint casadi_f1_checkout(void) {\n  int mid;\n  if (casadi_f1_unused_stack_counter>=0) {\n    return casadi_f1_unused_stack[casadi_f1_unused_stack_counter--];\n  } else {\n    if (casadi_f1_mem_counter==CASADI_MAX_NUM_THREADS) return -1;\n    mid = casadi_f1_alloc_mem();\n    if (mid<0) return -1;\n    if(casadi_f1_init_mem(mid)) return -1;\n    return mid;\n  }\n}\n\nvoid casadi_f1_release(int mem) {\n  casadi_f1_unused_stack[++casadi_f1_unused_stack_counter] = mem;\n}\n\n/* helper:(i0[17],i1[14],i2[22])->(o0) */\nstatic int casadi_f7(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {\n  casadi_real *rr, *w0=w+0, w1;\n  const casadi_real *cs;\n  /* #0: @0 = input[0][1] */\n  casadi_copy(arg[0] ? arg[0]+12 : 0, 5, w0);\n  /* #1: @1 = @0[0] */\n  for (rr=(&w1), cs=w0+0; cs!=w0+1; cs+=1) *rr++ = *cs;\n  /* #2: output[0][0] = @1 */\n  if (res[0]) res[0][0] = w1;\n  return 0;\n}\n\n/* solver_01:(x0[2],xref[2x6])->(u_opt) */\nstatic int casadi_f0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {\n  casadi_int i;\n  casadi_real **res1=res+1, *rr, *w00=w+759, *w01=w+776, *w03=w+790, *w04=w+804, *w05=w+821, *w06=w+838, w07, w08, *w09=w+842, w10;\n  casadi_real w11, *w12=w+846, w13, w14, *w15=w+850, w16, w17, *w18=w+854, w19, w20, *w21=w+858, *w22=w+880;\n  casadi_real *w23=w+902, *w24=w+919, *w25=w+941, *w26=w+958;\n  const casadi_real **arg1=arg+2, *cs, *wr02;\n  int flag, mid;\n  /* #0: @0 = zeros(17x1) */\n  casadi_clear(w00, 17);\n  /* #1: @1 = input[0][0] */\n  casadi_copy(arg[0], 2, w01);\n  /* #2: @2 = input[1][0] */\n  wr02 = arg[1] ? arg[1] : casadi_zeros;\n  /* #3: @2 = vec(@2) */\n  /* #4: @3 = vertcat(@1, @2) */\n  rr=w03;\n  for (i=0, cs=w01; i<2; ++i) *rr++ = *cs++;\n  for (i=0, cs=wr02; i<12; ++i) *rr++ = *cs++;\n  /* #5: @4 = -inf(17x1) */\n  casadi_fill(w04, 17, -casadi_inf);\n  /* #6: @5 = inf(17x1) */\n  casadi_fill(w05, 17, casadi_inf);\n  /* #7: @6 = zeros(2x1) */\n  casadi_clear(w06, 2);\n  /* #8: @7 = -10 */\n  w07 = -10.;\n  /* #9: @8 = -inf */\n  w08 = -casadi_inf;\n  /* #10: @9 = zeros(2x1) */\n  casadi_clear(w09, 2);\n  /* #11: @10 = -10 */\n  w10 = -10.;\n  /* #12: @11 = -inf */\n  w11 = -casadi_inf;\n  /* #13: @12 = zeros(2x1) */\n  casadi_clear(w12, 2);\n  /* #14: @13 = -10 */\n  w13 = -10.;\n  /* #15: @14 = -inf */\n  w14 = -casadi_inf;\n  /* #16: @15 = zeros(2x1) */\n  casadi_clear(w15, 2);\n  /* #17: @16 = -10 */\n  w16 = -10.;\n  /* #18: @17 = -inf */\n  w17 = -casadi_inf;\n  /* #19: @18 = zeros(2x1) */\n  casadi_clear(w18, 2);\n  /* #20: @19 = -10 */\n  w19 = -10.;\n  /* #21: @20 = -inf */\n  w20 = -casadi_inf;\n  /* #22: @21 = vertcat(@1, @6, @7, @8, @9, @10, @11, @12, @13, @14, @15, @16, @17, @18, @19, @20) */\n  rr=w21;\n  for (i=0, cs=w01; i<2; ++i) *rr++ = *cs++;\n  for (i=0, cs=w06; i<2; ++i) *rr++ = *cs++;\n  *rr++ = w07;\n  *rr++ = w08;\n  for (i=0, cs=w09; i<2; ++i) *rr++ = *cs++;\n  *rr++ = w10;\n  *rr++ = w11;\n  for (i=0, cs=w12; i<2; ++i) *rr++ = *cs++;\n  *rr++ = w13;\n  *rr++ = w14;\n  for (i=0, cs=w15; i<2; ++i) *rr++ = *cs++;\n  *rr++ = w16;\n  *rr++ = w17;\n  for (i=0, cs=w18; i<2; ++i) *rr++ = *cs++;\n  *rr++ = w19;\n  *rr++ = w20;\n  /* #23: @6 = zeros(2x1) */\n  casadi_clear(w06, 2);\n  /* #24: @7 = inf */\n  w07 = casadi_inf;\n  /* #25: @8 = 10 */\n  w08 = 10.;\n  /* #26: @9 = zeros(2x1) */\n  casadi_clear(w09, 2);\n  /* #27: @10 = inf */\n  w10 = casadi_inf;\n  /* #28: @11 = 10 */\n  w11 = 10.;\n  /* #29: @12 = zeros(2x1) */\n  casadi_clear(w12, 2);\n  /* #30: @13 = inf */\n  w13 = casadi_inf;\n  /* #31: @14 = 10 */\n  w14 = 10.;\n  /* #32: @15 = zeros(2x1) */\n  casadi_clear(w15, 2);\n  /* #33: @16 = inf */\n  w16 = casadi_inf;\n  /* #34: @17 = 10 */\n  w17 = 10.;\n  /* #35: @18 = zeros(2x1) */\n  casadi_clear(w18, 2);\n  /* #36: @19 = inf */\n  w19 = casadi_inf;\n  /* #37: @20 = 10 */\n  w20 = 10.;\n  /* #38: @22 = vertcat(@1, @6, @7, @8, @9, @10, @11, @12, @13, @14, @15, @16, @17, @18, @19, @20) */\n  rr=w22;\n  for (i=0, cs=w01; i<2; ++i) *rr++ = *cs++;\n  for (i=0, cs=w06; i<2; ++i) *rr++ = *cs++;\n  *rr++ = w07;\n  *rr++ = w08;\n  for (i=0, cs=w09; i<2; ++i) *rr++ = *cs++;\n  *rr++ = w10;\n  *rr++ = w11;\n  for (i=0, cs=w12; i<2; ++i) *rr++ = *cs++;\n  *rr++ = w13;\n  *rr++ = w14;\n  for (i=0, cs=w15; i<2; ++i) *rr++ = *cs++;\n  *rr++ = w16;\n  *rr++ = w17;\n  for (i=0, cs=w18; i<2; ++i) *rr++ = *cs++;\n  *rr++ = w19;\n  *rr++ = w20;\n  /* #39: @23 = zeros(17x1) */\n  casadi_clear(w23, 17);\n  /* #40: @24 = zeros(22x1) */\n  casadi_clear(w24, 22);\n  /* #41: {@25, NULL, NULL, NULL, @26, NULL} = solver(@0, @3, @4, @5, @21, @22, @23, @24) */\n  arg1[0]=w00;\n  arg1[1]=w03;\n  arg1[2]=w04;\n  arg1[3]=w05;\n  arg1[4]=w21;\n  arg1[5]=w22;\n  arg1[6]=w23;\n  arg1[7]=w24;\n  res1[0]=w25;\n  res1[1]=0;\n  res1[2]=0;\n  res1[3]=0;\n  res1[4]=w26;\n  res1[5]=0;\n  mid = casadi_f1_checkout();\n  if (mid<0) return 1;\n  flag = casadi_f1(arg1, res1, iw, w, mid);\n  casadi_f1_release(mid);\n  if (flag) return 1;\n  /* #42: @7 = helper(@25, @3, @26) */\n  arg1[0]=w25;\n  arg1[1]=w03;\n  arg1[2]=w26;\n  res1[0]=(&w07);\n  if (casadi_f7(arg1, res1, iw, w, 0)) return 1;\n  /* #43: output[0][0] = @7 */\n  if (res[0]) res[0][0] = w07;\n  return 0;\n}\n\nCASADI_SYMBOL_EXPORT int solver_01(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem){\n  return casadi_f0(arg, res, iw, w, mem);\n}\n\nCASADI_SYMBOL_EXPORT int solver_01_alloc_mem(void) {\n  return 0;\n}\n\nCASADI_SYMBOL_EXPORT int solver_01_init_mem(int mem) {\n  return 0;\n}\n\nCASADI_SYMBOL_EXPORT void solver_01_free_mem(int mem) {\n}\n\nCASADI_SYMBOL_EXPORT int solver_01_checkout(void) {\n  return 0;\n}\n\nCASADI_SYMBOL_EXPORT void solver_01_release(int mem) {\n}\n\nCASADI_SYMBOL_EXPORT void solver_01_incref(void) {\n}\n\nCASADI_SYMBOL_EXPORT void solver_01_decref(void) {\n}\n\nCASADI_SYMBOL_EXPORT casadi_int solver_01_n_in(void) { return 2;}\n\nCASADI_SYMBOL_EXPORT casadi_int solver_01_n_out(void) { return 1;}\n\nCASADI_SYMBOL_EXPORT casadi_real solver_01_default_in(casadi_int i) {\n  switch (i) {\n    default: return 0;\n  }\n}\n\nCASADI_SYMBOL_EXPORT const char* solver_01_name_in(casadi_int i) {\n  switch (i) {\n    case 0: return \"x0\";\n    case 1: return \"xref\";\n    default: return 0;\n  }\n}\n\nCASADI_SYMBOL_EXPORT const char* solver_01_name_out(casadi_int i) {\n  switch (i) {\n    case 0: return \"u_opt\";\n    default: return 0;\n  }\n}\n\nCASADI_SYMBOL_EXPORT const casadi_int* solver_01_sparsity_in(casadi_int i) {\n  switch (i) {\n    case 0: return casadi_s23;\n    case 1: return casadi_s24;\n    default: return 0;\n  }\n}\n\nCASADI_SYMBOL_EXPORT const casadi_int* solver_01_sparsity_out(casadi_int i) {\n  switch (i) {\n    case 0: return casadi_s25;\n    default: return 0;\n  }\n}\n\nCASADI_SYMBOL_EXPORT int solver_01_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {\n  if (sz_arg) *sz_arg = 28;\n  if (sz_res) *sz_res = 27;\n  if (sz_iw) *sz_iw = 18;\n  if (sz_w) *sz_w = 980;\n  return 0;\n}\n\nCASADI_SYMBOL_EXPORT int solver_01_work_bytes(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {\n  if (sz_arg) *sz_arg = 28*sizeof(const casadi_real*);\n  if (sz_res) *sz_res = 27*sizeof(casadi_real*);\n  if (sz_iw) *sz_iw = 18*sizeof(casadi_int);\n  if (sz_w) *sz_w = 980*sizeof(casadi_real);\n  return 0;\n}\n\n\n#ifdef __cplusplus\n} /* extern \"C\" */\n#endif\n"},{"name":"solver_01_wrapper.c","type":"source","group":"interface","path":"C:\\Users\\khanh\\dev\\python\\projects\\casadi_codegen\\approaches\\01","tag":"","groupDisplay":"Interface files","code":"#define S_FUNCTION_NAME  solver_01_wrapper\r\n#define S_FUNCTION_LEVEL 2\r\n\r\n#include \"simstruc.h\"\r\n#include \"solver_01.h\"\r\n\r\n/*\r\n * Include Files\r\n *\r\n */\r\n#if defined(MATLAB_MEX_FILE)\r\n#include \"tmwtypes.h\"\r\n#include \"simstruc_types.h\"\r\n#else\r\n#define SIMPLIFIED_RTWTYPES_COMPATIBILITY\r\n#include \"rtwtypes.h\"\r\n#undef SIMPLIFIED_RTWTYPES_COMPATIBILITY\r\n#endif\r\n\r\n\r\nstatic void mdlInitializeSizes(SimStruct *S)\r\n{\r\n    ssSetNumSFcnParams(S, 0);\r\n    if (ssGetNumSFcnParams(S) != ssGetSFcnParamsCount(S)) {\r\n        return; /* Parameter mismatch will be reported by Simulink */\r\n    }\r\n\r\n    /* Read in CasADi function dimensions */\r\n    int_T n_in  = solver_01_n_in();\r\n    int_T n_out = solver_01_n_out();\r\n    int_T sz_arg, sz_res, sz_iw, sz_w;\r\n    solver_01_work(&sz_arg, &sz_res, &sz_iw, &sz_w);\r\n    \r\n    /* Set up simulink input/output ports */\r\n    int_T i;\r\n    if (!ssSetNumInputPorts(S, n_in)) return;\r\n    for (i=0;i<n_in;++i) {\r\n      const int_T* sp = solver_01_sparsity_in(i);\r\n      /* Dense inputs assumed here */\r\n      ssSetInputPortDirectFeedThrough(S, i, 1);\r\n      ssSetInputPortMatrixDimensions(S, i, sp[0], sp[1]);\r\n      ssSetInputPortRequiredContiguous(S, i, 1);\r\n    }\r\n\r\n    if (!ssSetNumOutputPorts(S, n_out)) return;\r\n    for (i=0;i<n_out;++i) {\r\n      const int_T* sp = solver_01_sparsity_out(i);\r\n      /* Dense outputs assumed here */\r\n      ssSetOutputPortMatrixDimensions(S, i, sp[0], sp[1]);\r\n    }\r\n\r\n    ssSetNumSampleTimes(S, 1);\r\n    \r\n    /* Set up CasADi function work vector sizes */\r\n    ssSetNumRWork(S, sz_w);\r\n    ssSetNumIWork(S, sz_iw);\r\n    ssSetNumPWork(S, sz_arg+sz_res);\r\n    ssSetNumNonsampledZCs(S, 0);\r\n\r\n    /* specify the sim state compliance to be same as a built-in block */\r\n    ssSetSimStateCompliance(S, USE_DEFAULT_SIM_STATE);\r\n\r\n    // ssSetOptions(S,\r\n    //              SS_OPTION_WORKS_WITH_CODE_REUSE |\r\n    //              SS_OPTION_EXCEPTION_FREE_CODE |\r\n    //              SS_OPTION_USE_TLC_WITH_ACCELERATOR);\r\n\r\n    /* Signal that we want to use the CasADi Function */\r\n    solver_01_incref();\r\n}\r\n\r\nstatic void mdlStart(SimStruct *S) {\r\n  #if defined(MATLAB_MEX_FILE)\r\n  slDataTypeAccess *dta = ssGetDataTypeAccess(S);\r\n  DTypeId solver_stats_bus_id = ssGetDataTypeId(S, \"solver_stats_bus\");\r\n  \r\n  (void)dta; (void)solver_stats_bus_id; // avoid warning unused\r\n  // #else\r\n  // UNUSED_ARG(S);\r\n  #else\r\n  printf(\"[mdlStart] begin\\n\"); fflush(stdout);\r\n  // allocate, create solver, etc.\r\n  printf(\"[mdlStart] after solver create\\n\"); fflush(stdout);\r\n  #endif\r\n}\r\n\r\n\r\n/* Function: mdlInitializeSampleTimes =========================================\r\n * Abstract:\r\n *    Specifiy that we inherit our sample time from the driving block.\r\n */\r\nstatic void mdlInitializeSampleTimes(SimStruct *S)\r\n{\r\n    ssSetSampleTime(S, 0, INHERITED_SAMPLE_TIME);\r\n    ssSetOffsetTime(S, 0, 0.0);\r\n    ssSetModelReferenceSampleTimeDefaultInheritance(S); \r\n}\r\n\r\nstatic void mdlOutputs(SimStruct *S, int_T tid)\r\n{\r\n    \r\n    /* Read in CasADi function dimensions */\r\n    int_T n_in  = solver_01_n_in();\r\n    int_T n_out = solver_01_n_out();\r\n    int_T sz_arg, sz_res, sz_iw, sz_w;\r\n    solver_01_work(&sz_arg, &sz_res, &sz_iw, &sz_w);\r\n    \r\n    /* Set up CasADi function work vectors */\r\n    void** p = ssGetPWork(S);\r\n    const real_T** arg = (const real_T**) p;\r\n    p += sz_arg;\r\n    real_T** res = (real_T**) p;\r\n    real_T* w = ssGetRWork(S);\r\n    int_T* iw = ssGetIWork(S);\r\n    \r\n    \r\n    /* Point to input and output buffers */\r\n    int_T i;   \r\n    for (i=0; i<n_in;++i) {\r\n      arg[i] = ssGetInputPortRealSignal(S,i);\r\n    }\r\n    for (i=0; i<n_out;++i) {\r\n      res[i] = ssGetOutputPortRealSignal(S,i);\r\n    }\r\n\r\n    /* Get a hold on a location to read/write persistant internal memory\r\n    */\r\n\r\n    int mem = solver_01_checkout();\r\n\r\n    /* Run the CasADi function */\r\n    // f(arg,res,iw,w,mem);\r\n    solver_01(arg,res,iw,w,mem);\r\n\r\n    /* Release hold */\r\n    solver_01_release(mem);\r\n}\r\n\r\nstatic void mdlTerminate(SimStruct *S) {\r\n  /* Signal that we no longer want to use the CasADi Function */\r\n  solver_01_decref();\r\n}\r\n\r\n\r\n#ifdef  MATLAB_MEX_FILE    /* Is this file being compiled as a MEX-file? */\r\n#include \"simulink.c\"      /* MEX-file interface mechanism */\r\n#else\r\n#include \"cg_sfun.h\"       /* Code generation registration function */\r\n#endif"},{"name":"test_normal_sim_dt.h","type":"header","group":"interface","path":"C:\\Users\\khanh\\dev\\python\\projects\\casadi_codegen\\approaches\\01\\test_normal_sim_quarc_win64","tag":"","groupDisplay":"Interface files","code":"/*\r\n * test_normal_sim_dt.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"test_normal_sim\".\r\n *\r\n * Model version              : 19.0\r\n * Simulink Coder version : 25.1 (R2025a) 21-Nov-2024\r\n * C source code generated on : Fri Sep 12 15:50:10 2025\r\n *\r\n * Target selection: quarc_win64.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"ext_types.h\"\r\n\r\n/* data type size table */\r\nstatic uint_T rtDataTypeSizes[] = {\r\n  sizeof(real_T),\r\n  sizeof(real32_T),\r\n  sizeof(int8_T),\r\n  sizeof(uint8_T),\r\n  sizeof(int16_T),\r\n  sizeof(uint16_T),\r\n  sizeof(int32_T),\r\n  sizeof(uint32_T),\r\n  sizeof(boolean_T),\r\n  sizeof(fcn_call_T),\r\n  sizeof(int_T),\r\n  sizeof(pointer_T),\r\n  sizeof(action_T),\r\n  2*sizeof(uint32_T),\r\n  sizeof(int32_T),\r\n  sizeof(t_card),\r\n  sizeof(uint_T),\r\n  sizeof(char_T),\r\n  sizeof(uchar_T),\r\n  sizeof(time_T)\r\n};\r\n\r\n/* data type name table */\r\nstatic const char_T * rtDataTypeNames[] = {\r\n  \"real_T\",\r\n  \"real32_T\",\r\n  \"int8_T\",\r\n  \"uint8_T\",\r\n  \"int16_T\",\r\n  \"uint16_T\",\r\n  \"int32_T\",\r\n  \"uint32_T\",\r\n  \"boolean_T\",\r\n  \"fcn_call_T\",\r\n  \"int_T\",\r\n  \"pointer_T\",\r\n  \"action_T\",\r\n  \"timer_uint32_pair_T\",\r\n  \"physical_connection\",\r\n  \"t_card\",\r\n  \"uint_T\",\r\n  \"char_T\",\r\n  \"uchar_T\",\r\n  \"time_T\"\r\n};\r\n\r\n/* data type transitions for block I/O structure */\r\nstatic DataTypeTransition rtBTransitions[] = {\r\n  { (char_T *)(&test_normal_sim_B.TmpSignalConversionAtSFunctionI[0]), 0, 0, 15\r\n  }\r\n  ,\r\n\r\n  { (char_T *)(&test_normal_sim_DW.HILInitialize_FilterFrequency[0]), 0, 0, 2 },\r\n\r\n  { (char_T *)(&test_normal_sim_DW.HILInitialize_Card), 15, 0, 1 },\r\n\r\n  { (char_T *)(&test_normal_sim_DW.SFunction_RWORK[0]), 0, 0, 980 },\r\n\r\n  { (char_T *)(&test_normal_sim_DW.SFunction_PWORK[0]), 11, 0, 55 },\r\n\r\n  { (char_T *)(&test_normal_sim_DW.HILInitialize_ClockModes), 6, 0, 6 },\r\n\r\n  { (char_T *)(&test_normal_sim_DW.SFunction_IWORK[0]), 10, 0, 18 }\r\n};\r\n\r\n/* data type transition table for block I/O structure */\r\nstatic DataTypeTransitionTable rtBTransTable = {\r\n  7U,\r\n  rtBTransitions\r\n};\r\n\r\n/* data type transitions for Parameters structure */\r\nstatic DataTypeTransition rtPTransitions[] = {\r\n  { (char_T *)(&test_normal_sim_P.HILInitialize_OOTerminate), 0, 0, 25 },\r\n\r\n  { (char_T *)(&test_normal_sim_P.HILInitialize_CKChannels), 6, 0, 7 },\r\n\r\n  { (char_T *)(&test_normal_sim_P.HILInitialize_AIChannels), 7, 0, 9 },\r\n\r\n  { (char_T *)(&test_normal_sim_P.HILInitialize_Active), 8, 0, 35 }\r\n};\r\n\r\n/* data type transition table for Parameters structure */\r\nstatic DataTypeTransitionTable rtPTransTable = {\r\n  4U,\r\n  rtPTransitions\r\n};\r\n\r\n/* [EOF] test_normal_sim_dt.h */\r\n"},{"name":"ext_svr.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2025a\\rtw\\c\\src\\ext_mode\\common","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1994-2021 The MathWorks, Inc.\n *\n * File: ext_svr.c     \n *\n * Abstract:\n *  External mode server interface (TCPIP example).  Provides functions\n *  that get called by main routine (model-name.c):\n *    o ExtParseArgsAndInitUD:  parse args and create UserData\n *    o ExtWaitForStartPkt:     return true if waiting for host to start\n *    o rt_ExtModeInit:         external mode initialization\n *    o rt_ExtModeSleep:        pause the process\n *    o rt_PktServerWork:       server for setting/getting packets from host\n *    o rt_PktServer:           server dispatcher - for multi-tasking targets\n *    o rt_UploadServerWork:    server for setting data upload packets on host\n *    o rt_UploadServer:        server dispatcher - for multi-tasking targets\n *    o rt_ExtModeShutdown:     external mode termination\n *\n *  Parameter downloading and data uploading supported for single and\n *  multi-tasking targets.\n */\n\n/*****************\n * Include files *\n *****************/\n\n/*ANSI C headers*/\n#ifndef EXTMODE_DISABLEPRINTF  \n#include <stdio.h>\n#endif\n\n#include <stdlib.h>\n#include <string.h>\n\n#if defined(VXWORKS)\n /*VxWorks headers*/\n# include <selectLib.h>\n# include <sockLib.h>\n# include <inetLib.h>\n# include <ioLib.h>\n# include <taskLib.h>\n#endif\n\n/*Real Time Workshop headers*/\n#include \"rtwtypes.h\"\n#include \"multiword_types.h\"\n#include \"rtw_extmode.h\"\n\n#include \"ext_types.h\"\n#include \"ext_share.h\"\n#include \"ext_test.h\"\n#include \"ext_svr_transport.h\"\n#include \"updown.h\"\n#include \"updown_util.h\"\n#include \"dt_info.h\"\n\n\n/*Uncomment to test 4 byte reals*/\n/*#define real_T float*/\n\n/***********************\n * Logical definitions *\n ***********************/\n#if (!defined(__cplusplus))\n#  ifndef false\n#   define false                       (0U)\n#  endif\n#  ifndef true\n#   define true                        (1U)\n#  endif\n#endif\n\n/**********************\n * External Variables *\n **********************/\nextern int_T           volatile startModel;\nextern TargetSimStatus volatile modelStatus;\n#ifdef VXWORKS\nextern SEM_ID uploadSem;\nextern SEM_ID pktSem;\n#endif\nextern boolean_T host_upstatus_is_uploading;\n\n/********************\n * Global Variables *\n ********************/\n\n/*\n * Flags.\n */\nPRIVATE boolean_T   connected       = false;\nPRIVATE boolean_T   commInitialized = false;\nboolean_T gblSetParamPktReceived = false;\n\n/*\n * Pointer to opaque user data (defined by ext_svr_transport.c).\n */\nPRIVATE ExtUserData *extUD          = NULL;\n\n/*\n * Buffer used to receive packets.\n */\nPRIVATE int_T pktBufSize = 0;\nPRIVATE char  *pktBuf    = NULL;\n\n\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n#ifndef EXTMODE_DISABLEPRINTF \nPRIVATE char ERRMSG_PROCESSSELECTSIGNAL[] = \n            \"\\nError in UploadLogInfoInit(). Most likely a memory\\n\"\n            \"allocation error or an attempt to re-initialize the\\n\"\n            \"signal selection during the data logging process\\n\"\n            \"(i.e., multiple EXT_SELECT_SIGNAL packets were received\\n\"\n            \"before the logging session terminated or an\\n\"\n            \"EXT_CANCEL_LOGGING packet was received)\\n\";\n\nPRIVATE char ERRMSG_PROCESSSELECTTRIGGER[] = \n            \"\\nError in UploadInitTrigger(). Most likely a memory\\n\"\n            \"allocation error or an attempt to re-initialize the\\n\"\n            \"trigger selection during the data logging process\\n\"\n            \"(i.e., multiple EXT_SELECT_TRIGGER packets were received\\n\"\n            \"before the logging session terminated or an\\n\"\n            \"EXT_CANCEL_LOGGING packet was received)\\n\";\n#else\nPRIVATE char ERRMSG_PROCESSSELECTSIGNAL[] = \"\";\nPRIVATE char ERRMSG_PROCESSSELECTTRIGGER[] = \"\";\n#endif\n#endif\n\n/********************\n *  If DAEMON_MODE  *\n ********************/\n#ifdef DAEMON_MODE\n/*\n * This defines the size of each data chunk (in bytes) that the\n * daemon acknowledgment scheme uses for large data\n */\nconst int_T daemonChunkSize = 32;\n#endif\n\nPRIVATE boolean_T SendPktHdrToHost(const ExtModeAction action,\n                                         const int size);\n\n/*******************\n * Local Functions *\n *******************/\n\n/* Function: GrowRecvBufIfNeeded ===============================================\n * Abstract:\n *  Allocate or increase the size of buffer for receiving packets from target.\n */\nPRIVATE boolean_T GrowRecvBufIfNeeded(const int pktSize)\n{\n    if (pktSize > pktBufSize) {\n        if (pktBuf != NULL) {\n            free(pktBuf);\n            pktBufSize = 0;\n        }\n\n        pktBuf = (char *)malloc(pktSize);\n        if (pktBuf == NULL) return(EXT_ERROR);\n\n        pktBufSize = pktSize;\n    }\n    return(EXT_NO_ERROR);\n} /* end GrowRecvBufIfNeeded */\n\n\n/* Function: GetPktHdr =========================================================\n * Abstract:\n *  Attempts to retrieve a packet header from the host.  If a header is in \n *  fact retrieved, the reference arg, 'hdrAvail' will be returned as true.\n *\n *  EXT_NO_ERROR is returned on success, EXT_ERROR is returned on failure.\n *\n * NOTES:\n *  o It is not necessarily an error for 'hdrAvail' to be returned as false.\n *    It typically means that we were polling for packets and none were\n *    available.\n */\nPRIVATE boolean_T GetPktHdr(PktHeader *pktHdr, boolean_T *hdrAvail)\n{\n    int_T     nGot      = 0; /* assume */\n    int_T     nGotTotal = 0;\n    int_T     pktSize   = sizeof(PktHeader);\n    boolean_T error     = EXT_NO_ERROR;\n    \n    /* Get the header. */\n    while(nGotTotal < pktSize) {\n        error = ExtGetHostPkt(extUD,\n            pktSize - nGotTotal, &nGot, (char_T *)((char_T *)pktHdr + nGotTotal));\n        if (error) goto EXIT_POINT;\n\n        nGotTotal += nGot;\n\n        if (nGotTotal == 0) break;\n    }\n    assert((nGot == 0) || (nGotTotal == pktSize));\n\nEXIT_POINT:\n    *hdrAvail = (boolean_T)(nGot > 0);\n    return(error);\n} /* end GetPktHdr */\n\n\n/* Function: ClearPkt ==========================================================\n * Abstract:\n *  Remove the data from the communication line one byte at a time.  This\n *  function is called when there was not enough memory to receive an entire\n *  packet.  Since the data was never received, it must be discarded so that\n *  other packets can be sent.\n */\nPRIVATE void ClearPkt(const int pktSize)\n{\n    int_T     nGot;\n    boolean_T error     = EXT_NO_ERROR;\n    int_T     nGotTotal = 0;\n    char      buffer;\n\n    /* Get and discard the data one char at a time. */\n    while(nGotTotal < pktSize) {\n        error = ExtGetHostPkt(extUD, 1, &nGot, (char_T *)&buffer);\n        if (error) {\n#ifndef EXTMODE_DISABLEPRINTF            \n            fprintf(stderr,\"ExtGetHostPkt() failed.\\n\");\n#endif\n            goto EXIT_POINT;\n        }\n        nGotTotal += nGot;\n    }\n\nEXIT_POINT:\n    return;\n\n} /* end ClearPkt */\n\n#ifdef DAEMON_MODE\n/* Function: ClearPktUsingAck ==================================================\n * Abstract:\n *  Derived from ClearPkt(). For the general behaviour see ClearPkt() above.\n *  This variant is used by DAEMON_MODE to clear data in small chunks.\n *  After receiving each chunk reply with a EXT_DAEMON_ACK.\n */\nPRIVATE void ClearPktUsingAck(const int pktSize)\n{\n    int_T     nGot;\n    boolean_T error     = EXT_NO_ERROR;\n    int_T     nGotTotal = 0;\n    char      buffer;\n    \n    int_T     i;\n    int_T     nChunks   = pktSize/daemonChunkSize;\n    int_T     bytesLeft = pktSize%daemonChunkSize;\n\n    /* Get and discard the data one char at a time.\n\t * Receive chunks here, and reply with ack after receiving each chunk\n\t */\n    for(i=0; i<nChunks; i++){\n        nGotTotal = 0;\n        while(nGotTotal < daemonChunkSize){\n            error = ExtGetHostPkt(extUD,\n                        1,\n                        &nGot,\n                        (char_T *)&buffer);\n            if (error) {\n#ifndef EXTMODE_DISABLEPRINTF                \n                fprintf(stderr,\"ExtGetHostPkt() failed.\\n\");\n#endif\n                goto EXIT_POINT;\n            }\n            nGotTotal += nGot;\n        }\n        SendPktHdrToHost(EXT_DAEMON_ACK, 0);\n    }\n    \n    /*\n\t * Receive the bytes left over and reply with an ack after you receive all\n\t */\n    nGotTotal=0;\n    if(bytesLeft != 0){\n        while(nGotTotal<bytesLeft){\n            error = ExtGetHostPkt(extUD,\n                        1,\n                        &nGot,\n                        (char_T *)&buffer);\n            if (error) {\n#ifndef EXTMODE_DISABLEPRINTF                \n                fprintf(stderr,\"ExtGetHostPkt() failed.\\n\");\n#endif\n                goto EXIT_POINT;\n            }\n        nGotTotal += nGot;\n        }\n        SendPktHdrToHost(EXT_DAEMON_ACK, 0);\n    }\n\nEXIT_POINT:\n    return;\n\n} /* end ClearPktUsingAck */\n#endif\n\n\n/* Function: GetPkt ============================================================\n * Abstract:\n *  Receive nBytes from the host.  Return a buffer containing the bytes or\n *  NULL if an error occurs.  Note that the pointer returned is that of the\n *  global pktBuf.  If the buf needs to be grown to accommodate the package,\n *  it is realloc'd.  This function will try to get the requested number\n *  of bytes indefinitely - it is assumed that the data is either already there,\n *  or will show up in a \"reasonable\" amount of time.\n */\nPRIVATE const char *GetPkt(const int pktSize)\n{\n    int_T     nGot;\n    boolean_T error     = EXT_NO_ERROR;\n    int_T     nGotTotal = 0;\n\n    error = GrowRecvBufIfNeeded(pktSize);\n    if (error != EXT_NO_ERROR) {\n#ifndef EXTMODE_DISABLEPRINTF            \n        fprintf(stderr,\"Previous pkt from host thrown away due to lack of memory.\\n\");\n#endif\n        ClearPkt(pktSize);\n        goto EXIT_POINT;\n    }\n    \n    /* Get the data. */\n    while(nGotTotal < pktSize) {\n        error = ExtGetHostPkt(extUD,\n            pktSize - nGotTotal, &nGot, (char_T *)(pktBuf + nGotTotal));\n        if (error) {\n#ifndef EXTMODE_DISABLEPRINTF                \n            fprintf(stderr,\"ExtGetHostPkt() failed.\\n\");\n#endif\n            goto EXIT_POINT;\n        }\n\n    nGotTotal += nGot;\n    }\n\nEXIT_POINT:\n    return((error == EXT_NO_ERROR) ? pktBuf : NULL);\n} /* end GetPkt */\n\n#ifdef DAEMON_MODE\n/* Function: GetPktUsingAck ============================================================\n * Abstract:\n *  Derived from GetPkt(). For the general behaviour see GetPkt() above.\n *  This variant is used by DAEMON_MODE to fetch data in small chunks.\n *  After receiving each chunk reply with a EXT_DAEMON_ACK.\n */\nPRIVATE const char *GetPktUsingAck(const int pktSize)\n{\n    int_T     nGot;\n    boolean_T error     = EXT_NO_ERROR;\n    int_T     nGotTotal = 0;\n    \n    int_T     i;\n    int_T     nChunks   = pktSize/daemonChunkSize;\n    int_T     bytesLeft = pktSize%daemonChunkSize;\n\n    error = GrowRecvBufIfNeeded(pktSize);\n    if (error != EXT_NO_ERROR) {\n#ifndef EXTMODE_DISABLEPRINTF            \n        fprintf(stderr,\"Previous pkt from host thrown away due to lack of memory.\\n\");\n#endif\n        ClearPktUsingAck(pktSize);\n        goto EXIT_POINT;\n    }\n    \n    /*\n\t * Receive chunks here, and reply with ack after receiving each chunk\n\t */\n    for(i=0; i<nChunks; i++){\n        nGotTotal = 0;\n        while(nGotTotal < daemonChunkSize){\n            error = ExtGetHostPkt(extUD,\n                        daemonChunkSize - nGotTotal,\n                        &nGot,\n                        (char_T *)(pktBuf + i*daemonChunkSize + nGotTotal));\n            if (error) {\n#ifndef EXTMODE_DISABLEPRINTF                \n                fprintf(stderr,\"ExtGetHostPkt() failed.\\n\");\n#endif\n            goto EXIT_POINT;\n            }\n            nGotTotal += nGot;\n        }\n        SendPktHdrToHost(EXT_DAEMON_ACK, 0);\n    }\n    \n    /*\n\t * Receive the bytes left over and reply with an ack after you receive all\n\t */\n    nGotTotal=0;\n    if(bytesLeft != 0){\n        while(nGotTotal<bytesLeft){\n            error = ExtGetHostPkt(extUD,\n                        bytesLeft - nGotTotal,\n                        &nGot,\n                        (char_T *)(pktBuf + i*daemonChunkSize + nGotTotal));\n            if (error) {\n#ifndef EXTMODE_DISABLEPRINTF                \n                fprintf(stderr,\"ExtGetHostPkt() failed.\\n\");\n#endif\n                goto EXIT_POINT;\n            }\n        nGotTotal += nGot;\n        }\n        SendPktHdrToHost(EXT_DAEMON_ACK, 0);\n    }\n\nEXIT_POINT:\n    return((error == EXT_NO_ERROR) ? pktBuf : NULL);\n} /* end GetPktUsingAck */\n#endif\n\n\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n/* Forward declaration */\nvoid UploadServerWork(int32_T, int_T numSampTimes);\n#endif\n\n/* Function: DisconnectFromHost ================================================\n * Abstract:\n *  Disconnect from the host.\n */\nPRIVATE void DisconnectFromHost(int_T numSampTimes)\n{\n    int i;\n    boolean_T upload_signals = host_upstatus_is_uploading;\n\n    for (i=0; i<NUM_UPINFOS; i++) {\n        UploadPrepareForFinalFlush(i);\n\n#if defined(VXWORKS)\n        /*\n         * UploadPrepareForFinalFlush() has already called semGive(uploadSem)\n         * two times.  Now the server thread will wait until the upload thread\n         * has processed all of the data in the buffers for the final upload\n         * and exhausted the uploadSem semaphores.  If the server thread\n         * attempts to call UploadServerWork() while the upload thread is in\n         * the middle of processing the buffers, the target code may crash\n         * with a NULL pointer exception (the buffers are destroyed after\n         * calling UploadLogInfoTerm).\n         */\n        while(semTake(uploadSem, NO_WAIT) != ERROR) {\n            semGive(uploadSem);\n            taskDelay(1000);\n        }\n#else\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n        if (upload_signals) {\n            UploadServerWork(i, numSampTimes);\n        }\n#endif\n#endif\n\n        UploadLogInfoTerm(i, numSampTimes);\n    }\n    \n    connected       = false;\n    commInitialized = false;\n    \n    ExtCloseConnection(extUD);\n} /* end DisconnectFromHost */\n\n\n/* Function: ForceDisconnectFromHost ===========================================\n * Abstract:\n *  Force a disconnect from the host.  This is not a graceful shutdown and\n *  should only be used when the integrity of the external mode connection\n *  is in question.  To shutdown the connection gracefully, use\n *  DisconnectFromHost().\n */\nPRIVATE void ForceDisconnectFromHost(int_T numSampTimes)\n{\n    int i;\n    connected       = false;\n    commInitialized = false;\n\n    for (i=0; i<NUM_UPINFOS; i++) {\n        UploadEndLoggingSession(i, numSampTimes);\n    }\n\n    ExtForceDisconnect(extUD);\n} /* end ForceDisconnectFromHost */\n\n\n/* Function: ProcessConnectPkt =================================================\n * Abstract:\n *  Process the EXT_CONNECT packet and send response to host.\n */\nPRIVATE boolean_T ProcessConnectPkt(RTWExtModeInfo *ei)\n{\n    int_T                   nSet;\n    PktHeader               pktHdr;\n    int_T                   tmpBufSize;\n    uint32_T                *tmpBuf = NULL;\n    boolean_T               error   = EXT_NO_ERROR;\n    \n    const DataTypeTransInfo *dtInfo    = (const DataTypeTransInfo *) rteiGetModelMappingInfo(ei);\n    uint_T                  *dtSizes   = dtGetDataTypeSizes(dtInfo);\n    int_T                   nDataTypes = dtGetNumDataTypes(dtInfo);\n\n    assert(connected);\n    assert(!commInitialized);\n\n    /*\n     * Send the 1st of two EXT_CONNECT_RESPONSE packets to the host. \n     * The packet consists purely of the pktHeader.  In this special\n     * case the pktSize actually contains the number of bits per byte\n     * (not always 8 - see TI compiler for C30 and C40).\n     */\n    pktHdr.type = (uint32_T)EXT_CONNECT_RESPONSE;\n    pktHdr.size = (uint32_T)8; /* 8 bits per byte */\n\n    error = ExtSetHostPkt(extUD,sizeof(pktHdr),(char_T *)&pktHdr,&nSet);\n    if (error || (nSet != sizeof(pktHdr))) {\n#ifndef EXTMODE_DISABLEPRINTF            \n        fprintf(stderr,\n            \"ExtSetHostPkt() failed for 1st EXT_CONNECT_RESPONSE.\\n\");\n#endif\n        goto EXIT_POINT;\n    }\n\n    /* Send 2nd EXT_CONNECT_RESPONSE packet containing the following \n     * fields:\n     *\n     * CS1 - checksum 1 (uint32_T)\n     * CS2 - checksum 2 (uint32_T)\n     * CS3 - checksum 3 (uint32_T)\n     * CS4 - checksum 4 (uint32_T)\n     *\n     * intCodeOnly   - flag indicating if target is integer only (uint32_T)\n     * \n     * MWChunkSize   - multiword data type chunk size on target (uint32_T)\n     * \n     * targetStatus  - the status of the target (uint32_T)\n     *\n     * nDataTypes    - # of data types        (uint32_T)\n     * dataTypeSizes - 1 per nDataTypes       (uint32_T[])\n     */\n\n    {\n        int nPktEls    = 4 +                        /* checkSums       */\n                         1 +                        /* intCodeOnly     */\n                         1 +                        /* MW chunk size   */\n                         1 +                        /* targetStatus    */\n                         1 +                        /* nDataTypes      */\n                         dtGetNumDataTypes(dtInfo); /* data type sizes */\n\n        tmpBufSize = nPktEls * sizeof(uint32_T);\n        tmpBuf     = (uint32_T *)malloc(tmpBufSize);\n        if (tmpBuf == NULL) {\n            error = EXT_ERROR; goto EXIT_POINT;\n        }\n    }\n    \n    /* Send packet header. */\n    pktHdr.type = EXT_CONNECT_RESPONSE;\n    pktHdr.size = tmpBufSize;\n\n    error = ExtSetHostPkt(extUD,sizeof(pktHdr),(char_T *)&pktHdr,&nSet);\n    if (error || (nSet != sizeof(pktHdr))) {\n#ifndef EXTMODE_DISABLEPRINTF            \n        fprintf(stderr,\n            \"ExtSetHostPkt() failed for 2nd EXT_CONNECT_RESPONSE.\\n\");\n#endif\n        goto EXIT_POINT;\n    }\n   \n    /* Checksums, target status & SL_DOUBLESize. */\n    tmpBuf[0] = rteiGetChecksum0(ei);\n    tmpBuf[1] = rteiGetChecksum1(ei);\n    tmpBuf[2] = rteiGetChecksum2(ei);\n    tmpBuf[3] = rteiGetChecksum3(ei);\n\n#if INTEGER_CODE == 0\n    tmpBuf[4] = (uint32_T)0;\n#else\n    tmpBuf[4] = (uint32_T)1;\n#endif\n\n    tmpBuf[5] = (uint32_T)sizeof(uchunk_T);\n    \n    tmpBuf[6] = (uint32_T)modelStatus;\n\n    /* nDataTypes and dataTypeSizes */\n    {        \n        int i;\n        tmpBuf[7] = (uint32_T)nDataTypes;\n        for (i=0; i<nDataTypes; i++) {\n            tmpBuf[8+i] = (uint32_T)dtSizes[i];\n        }\n    }\n    \n    /* Send the packet. */\n    error = ExtSetHostPkt(extUD,tmpBufSize,(char_T *)tmpBuf,&nSet);\n    if (error || (nSet != tmpBufSize)) {\n#ifndef EXTMODE_DISABLEPRINTF            \n        fprintf(stderr,\n            \"ExtSetHostPkt() failed.\\n\");\n#endif\n        goto EXIT_POINT;\n    }\n\n    commInitialized = true;\n\nEXIT_POINT:\n    free(tmpBuf);\n    return(error);\n} /* end ProcessConnectPkt */\n\n\n/* Function: SendPktHdrToHost ==================================================\n * Abstract:\n *  Send a packet header to the host.\n */\nPRIVATE boolean_T SendPktHdrToHost(\n    const ExtModeAction action,\n    const int           size)  /* # of bytes to follow pkt header */\n{\n    int_T     nSet;\n    PktHeader pktHdr;\n    boolean_T error = EXT_NO_ERROR;\n\n    pktHdr.type = (uint32_T)action;\n    pktHdr.size = size;\n\n    error = ExtSetHostPkt(extUD,sizeof(pktHdr),(char_T *)&pktHdr,&nSet);\n    if (error || (nSet != sizeof(pktHdr))) {\n        error = EXT_ERROR;\n#ifndef EXTMODE_DISABLEPRINTF            \n        fprintf(stderr,\"ExtSetHostPkt() failed.\\n\");\n#endif\n        goto EXIT_POINT;\n    }\n\nEXIT_POINT:\n    return(error);\n} /* end SendPktHdrToHost */\n\n\n/* Function: SendPktDataToHost =================================================\n * Abstract:\n *  Send packet data to host. You are responsible for sending a header\n *  prior to sending the header.\n */\nPRIVATE boolean_T SendPktDataToHost(const char *data, const int size)\n{\n    int_T     nSet;\n    boolean_T error = EXT_NO_ERROR;\n\n    error = ExtSetHostPkt(extUD,size,data,&nSet);\n    if (error || (nSet != size)) {\n        error = EXT_ERROR;\n#ifndef EXTMODE_DISABLEPRINTF            \n        fprintf(stderr,\"ExtSetHostPkt() failed.\\n\");\n#endif\n        goto EXIT_POINT;\n    }\n\nEXIT_POINT:\n    return(error);\n} /* end SendPktDataToHost */\n\n\n/* Function: SendPktToHost =====================================================\n * Abstract:\n *  Send a packet to the host.  Packets can be of two forms:\n *      o packet header only\n *          the type is used as a flag to notify Simulink of an event\n *          that has taken place on the target (event == action == type)\n *      o pkt header, followed by data\n */\nPUBLIC boolean_T SendPktToHost(\n    const ExtModeAction action,\n    const int           size,  /* # of bytes to follow pkt header */\n    const char          *data)\n{\n    boolean_T error = EXT_NO_ERROR;\n    \n#ifdef VXWORKS\n    semTake(pktSem, WAIT_FOREVER);\n#endif\n\n    error = SendPktHdrToHost(action,size);\n    if (error != EXT_NO_ERROR) goto EXIT_POINT;\n\n    if (data != NULL) {\n        error = SendPktDataToHost(data, size);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n    } else {\n        assert(size == 0);\n    }\n\nEXIT_POINT:\n#ifdef VXWORKS\n    semGive(pktSem);\n#endif\n    return(error);\n} /* end SendPktToHost */\n\n\n/* Function:  SendResponseStatus ===============================================\n *  \n */\nPRIVATE boolean_T SendResponseStatus(const ExtModeAction  response,\n                                     const ResponseStatus status,\n                                     int32_T upInfoIdx)\n{\n    int32_T   msg[2];\n    boolean_T error = EXT_NO_ERROR;\n\n    msg[0] = (int32_T)status;\n    msg[1] = upInfoIdx;\n\n    error = SendPktToHost(response,2*sizeof(int32_T),(char_T *)&msg);\n    return(error);\n\n} /* end SendResponseStatus */\n\n\n#ifndef EXTMODE_DISABLEPARAMETERTUNING\n/* Function: ProcessSetParamPkt ================================================\n * Receive and process the EXT_SETPARAM packet.\n */\nPRIVATE boolean_T ProcessSetParamPkt(RTWExtModeInfo *ei,\n                                     const int pktSize)\n{\n    int32_T    msg;\n    const char *pkt;\n    boolean_T  error = EXT_NO_ERROR;\n\n    /*\n     * Receive packet and set parameters.\n     */\n    \n#ifdef DAEMON_MODE\n    pkt = GetPktUsingAck(pktSize);\n#else\n    pkt = GetPkt(pktSize);\n#endif\n\n    if (pkt == NULL) {\n        msg = (int32_T)NOT_ENOUGH_MEMORY;\n        SendPktToHost(EXT_SETPARAM_RESPONSE,sizeof(int32_T),(char_T *)&msg);\n        error = EXT_ERROR; \n        goto EXIT_POINT;\n    }\n    SetParam(ei, pkt);\n\n    msg = (int32_T)STATUS_OK;\n    error = SendPktToHost(EXT_SETPARAM_RESPONSE,sizeof(int32_T),(char_T *)&msg);\n    if (error != EXT_NO_ERROR) goto EXIT_POINT;\n\nEXIT_POINT:\n    return(error);\n} /* end ProcessSetParamPkt */\n#endif /* ifndef EXTMODE_DISABLEPARAMETERTUNING */\n\n#ifndef EXTMODE_DISABLEPARAMETERTUNING \n/* Function: ProcessGetParamsPkt ===============================================\n *  Respond to the hosts request for the parameters by gathering up all the\n *  params and sending them to the host.\n */\nPRIVATE boolean_T ProcessGetParamsPkt(RTWExtModeInfo *ei)\n{\n    int_T                         i;\n    int_T                         nBytesTotal;\n    boolean_T                     error    = EXT_NO_ERROR;\n    const DataTypeTransInfo       *dtInfo  = (const DataTypeTransInfo *) rteiGetModelMappingInfo(ei);\n    const DataTypeTransitionTable *dtTable = dtGetParamDataTypeTrans(dtInfo);\n\n    if (dtTable != NULL) {\n        /*\n         * We've got some params in the model.  Send their values to the\n         * host.\n         */\n        int_T        nTrans   = dtGetNumTransitions(dtTable);\n        const uint_T *dtSizes = dtGetDataTypeSizes(dtInfo);\n\n #ifdef VERBOSE\n    #ifndef EXTMODE_DISABLEPRINTF             \n        printf(\"\\nUploading initial parameters....\\n\");\n #endif\n#endif \n\n        /*\n         * Take pass 1 through the transitions to figure out how many\n         * bytes we're going to send.\n         */\n        nBytesTotal = 0;\n        for (i=0; i<nTrans; i++) {\n            int_T dt     = dtTransGetDataType(dtTable, i);\n            int_T dtSize = dtSizes[dt];\n            int_T nEls   = dtTransNEls(dtTable, i); /* complexity accounted for in trans tbl num of els */\n            int_T nBytes = dtSize * nEls;\n\n            nBytesTotal += nBytes;\n        }\n\n        /*\n         * Send the packet header.\n         */\n        error = SendPktHdrToHost(EXT_GETPARAMS_RESPONSE,nBytesTotal);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n\n        /*\n         * Take pass 2 through the transitions and send the parameters.\n         */\n        for (i=0; i<nTrans; i++) {\n            char_T *tranAddress  = dtTransGetAddress(dtTable, i);\n            int_T  dt            = dtTransGetDataType(dtTable, i);\n            int_T  dtSize        = dtSizes[dt];\n            int_T  nEls          = dtTransNEls(dtTable, i); /* complexity accounted for in trans tbl num of els */\n            int_T  nBytes        = dtSize * nEls;\n\n            error = SendPktDataToHost(tranAddress, nBytes);\n            if (error != EXT_NO_ERROR) goto EXIT_POINT;\n        }\n    } else {\n        /*\n         * We've got no params in the model.\n         */\n        error = SendPktHdrToHost(EXT_GETPARAMS_RESPONSE,0);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n    }\n\nEXIT_POINT:\n    return(error);\n} /* end ProcessGetParamsPkt */\n#endif /* ifndef EXTMODE_DISABLEPARAMETERTUNING */\n\n\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n/* Function: ProcessSelectTriggerSignalPkt ===========================================\n * Receive and process the EXT_SELECT_TRIGGER or EXT_SELECT_SIGNALS packet.\n */\nPRIVATE boolean_T ProcessSelectTriggerSignalPkt(const ExtModeAction ACTION_ID, \n                                                RTWExtModeInfo *ei,\n                                                const int pktSize,\n                                                int_T numSampTimes,\n                                                char* errMsg)\n{\n    const char *pkt;\n    int32_T    upInfoIdx;\n    boolean_T  error = EXT_NO_ERROR;\n\n#ifdef DAEMON_MODE\n    pkt = GetPktUsingAck(pktSize);\n#else\n    pkt = GetPkt(pktSize);\n#endif\n\n    if (pkt == NULL) {\n        SendResponseStatus(ACTION_ID, NOT_ENOUGH_MEMORY, -1);\n        return(EXT_ERROR);\n    }\n\n    (void)memcpy(&upInfoIdx, pkt, sizeof(int32_T)); /* Extract upInfoIdx */\n    switch(ACTION_ID) {\n    case EXT_SELECT_TRIGGER_RESPONSE:\n#ifndef EXTMODE_DISABLEPRINTF  \n        PRINT_VERBOSE(\n                    (\"got EXT_SELECT_TRIGGER packet for upInfoIdx : %d\\n\", upInfoIdx));\n#endif\n        error = UploadInitTrigger(ei, pkt+sizeof(int32_T), upInfoIdx);\n        break;\n    case EXT_SELECT_SIGNALS_RESPONSE:\n#ifndef EXTMODE_DISABLEPRINTF  \n        PRINT_VERBOSE(\n                    (\"got EXT_SELECT_SIGNALS packet for upInfoIdx : %d\\n\", upInfoIdx));\n#endif\n        error = UploadLogInfoInit(ei, numSampTimes, pkt+sizeof(int32_T), upInfoIdx);\n        break;\n    default:\n        break;\n    }\n\n    if (error != EXT_NO_ERROR) {\n        SendResponseStatus(ACTION_ID, NOT_ENOUGH_MEMORY, upInfoIdx);\n#ifndef EXTMODE_DISABLEPRINTF            \n        printf(\"%s\\n\", errMsg);\n#endif\n        return(error);\n    }\n\n    error = SendResponseStatus(ACTION_ID, STATUS_OK, upInfoIdx);\n    return(error); /* Can be EXT_NO_ERROR */\n} /* end ProcessSelectTriggerSignalPkt */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n/* Function: ProcessCancelLoggingArmTriggerPkt ===========================================\n * Receive and process the EXT_CANCEL_LOGGING or EXT_ARM_TRIGGER packet.\n */\nPRIVATE boolean_T ProcessCancelLoggingArmTriggerPkt(const ExtModeAction ACTION_ID, \n                        const int pktSize, \n                        int_T numSampTimes)\n{\n    const char *pkt;\n    int32_T    upInfoIdx;\n    boolean_T  error = EXT_NO_ERROR;\n\n#ifdef DAEMON_MODE\n    pkt = GetPktUsingAck(pktSize);\n#else\n    pkt = GetPkt(pktSize);\n#endif\n\n    if (pkt == NULL) {\n        SendResponseStatus(ACTION_ID, NOT_ENOUGH_MEMORY, -1);\n        return(EXT_ERROR);\n    }\n            \n    (void)memcpy(&upInfoIdx, pkt, sizeof(int32_T)); /* Extract upInfoIdx */\n        \n    switch(ACTION_ID) {\n    case EXT_CANCEL_LOGGING_RESPONSE:\n#ifndef EXTMODE_DISABLEPRINTF   \n        PRINT_VERBOSE(\n                (\"got EXT_CANCEL_LOGGING packet for upInfoIdx : %d\\n\", upInfoIdx));\n#endif\n        UploadCancelLogging(upInfoIdx);\n        break;\n    case EXT_ARM_TRIGGER_RESPONSE:\n#ifndef EXTMODE_DISABLEPRINTF\n        PRINT_VERBOSE(\n                (\"got EXT_ARM_TRIGGER packet for upInfoIdx : %d\\n\", upInfoIdx));\n#endif\n        UploadArmTrigger(upInfoIdx, numSampTimes);\n        break;\n    default:\n        break;\n    }\n\n    error = SendResponseStatus(ACTION_ID, STATUS_OK, upInfoIdx);\n    return(error); /* Can be EXT_NO_ERROR */\n} /* end ProcessCancelLoggingArmTriggerPkt */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n\n#ifdef EXTMODE_DISABLEPARAMETERTUNING\nPRIVATE boolean_T AcknowledgeSetParamPkt(const int pktSize)\n{\n    int32_T    msg;\n    const char *pkt;\n    boolean_T  error = EXT_NO_ERROR;\n\n    pkt = GetPkt(pktSize);\n    msg = (int32_T)STATUS_OK;\n    error = SendPktToHost(EXT_SETPARAM_RESPONSE, sizeof(int32_T), (char_T *)&msg);\n    return(error);\n}\n#endif /* ifdef EXTMODE_DISABLEPARAMETERTUNING */\n\n#ifdef EXTMODE_DISABLESIGNALMONITORING\nPRIVATE boolean_T AcknowledgeSignalActionPkt(const int pktSize, const ExtModeAction ACTION_ID)\n{\n    const char *pkt;\n    int32_T    upInfoIdx;\n    boolean_T  error = EXT_NO_ERROR;\n\n    pkt = GetPkt(pktSize);\n    (void)memcpy(&upInfoIdx, pkt, sizeof(int32_T));\n    error = SendResponseStatus(ACTION_ID, STATUS_OK, upInfoIdx);\n    return(error);\n} \n#endif /* ifdef EXTMODE_DISABLESIGNALMONITORING */\n\n/*********************\n * Visible Functions *\n *********************/\n\n\n/* Function: ExtParseArgsAndInitUD =============================================\n * Abstract:\n *  Pass remaining arguments (main program should have NULL'ed out any args\n *  that it processed) to external mode.\n *  \n *  The actual, transport-specific parsing routine (implemented in\n *  ext_svr_transport.c) MUST NULL out all entries of argv that it processes.\n *  The main program depends on this in order to determine if any unhandled\n *  command line options were specified (i.e., if the main program detects\n *  any non-null fields after the parse, it throws an error).\n *\n *  Returns an error string on failure, NULL on success.\n *\n * NOTES:\n *  The external mode UserData is created here so that the specified command-\n *  line options can be stored.\n */\nPUBLIC const char_T *ExtParseArgsAndInitUD(const int_T  argc,\n                                           const char_T *argv[])\n{\n    const char_T *error = NULL;\n    \n    /*\n     * Create the user data.\n     */\n    extUD = ExtUserDataCreate();\n    if (extUD == NULL) {\n        error = \"Could not create external mode user data.  Out of memory.\\n\";\n        goto EXIT_POINT;\n    }\n\n    /*\n     * Parse the transport-specific args.\n     */\n    error = ExtProcessArgs(extUD,argc,argv);\n    if (error != NULL) goto EXIT_POINT;\n        \nEXIT_POINT:\n    if (error != NULL) {\n        ExtUserDataDestroy(extUD);\n        extUD = NULL;\n    }\n    return(error);\n} /* end ExtParseArgsAndInitUD */\n\n\n/* Function: ExtWaitForStartPkt ================================================\n * Abstract:\n *  Return true if waiting for host to tell us when to start.\n */\nPUBLIC boolean_T ExtWaitForStartPkt(void)\n{\n    return(ExtWaitForStartPktFromHost(extUD));\n} /* end ExtWaitForStartPkt */\n\n\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n/* Function: UploadServerWork =================================================\n * Abstract:\n *  Upload model signals to host for a single upInfo.\n */\nvoid UploadServerWork(int32_T upInfoIdx, int_T numSampTimes)\n{\n    int_T         i;\n    ExtBufMemList upList;\n    boolean_T     error = EXT_NO_ERROR;\n\n#ifdef VXWORKS\n    /*\n     * Don't spin the CPU unless we've got data to upload.\n     * The upload.c/UploadBufAddTimePoint function gives the sem\n     * each time that data is added.\n     */\ntaskUnsafe();\n    semTake(uploadSem, WAIT_FOREVER);\ntaskSafe();\n#endif\n\n    if (!connected) goto EXIT_POINT;\n    \n    UploadBufGetData(&upList, upInfoIdx, numSampTimes);\n    while(upList.nActiveBufs > 0) {\n        for (i=0; i<upList.nActiveBufs; i++) {\n            const BufMem *bufMem = &upList.bufs[i];\n\n            /*\n             * We call SendPktDataToHost() instead of SendPktToHost() because\n             * the packet header is combined with packet payload.  We do this\n             * to avoid the overhead of making two calls for each upload\n             * packet - one for the head and one for the payload.\n             */\n            error = SendPktDataToHost(\n                bufMem->section1,\n                bufMem->nBytes1);\n            if (error != EXT_NO_ERROR) {\n#ifndef EXTMODE_DISABLEPRINTF                    \n                fprintf(stderr,\"SendPktDataToHost() failed on data upload.\\n\");\n#endif\n                goto EXIT_POINT;\n            }\n            \n            if (bufMem->nBytes2 > 0) {\n\n                error = SendPktDataToHost(\n                    bufMem->section2,\n                    bufMem->nBytes2);\n                if (error != EXT_NO_ERROR) {\n#ifndef EXTMODE_DISABLEPRINTF                        \n                    fprintf(stderr,\"SendPktDataToHost() failed on data upload.\\n\");\n#endif\n                    goto EXIT_POINT;\n                }\n            }\n            /* confirm that the data was sent */\n            UploadBufDataSent(upList.tids[i], upInfoIdx);\n        }\n        UploadBufGetData(&upList, upInfoIdx, numSampTimes);\n    }\n    \nEXIT_POINT:\n    if (error != EXT_NO_ERROR) {\n        /* An error in this function is caused by a physical failure in the\n         * external mode connection.  We assume this failure caused the host\n         * to disconnect.  The target must be disconnected and returned to a\n         * state where it is running and can be re-connected to by the host.\n         */\n        ForceDisconnectFromHost(numSampTimes);\n    }\n}\n/* end UploadServerWork */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n/* Function: rt_UploadServerWork ===============================================\n * Abstract:\n *  Wrapper function that calls UploadServerWork once for each upInfo\n */\nPUBLIC void rt_UploadServerWork(int_T numSampTimes)\n{\n    int i;\n    \n    for (i=0; i<NUM_UPINFOS; i++) {\n        UploadServerWork(i, numSampTimes);\n    }\n} /* end rt_UploadServerWork */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n/* Function: rt_ExtModeInit ====================================================\n * Abstract:\n *  Called once at program startup to do any initialization related to external\n *  mode. \n */\nPUBLIC boolean_T rt_ExtModeInit(void)\n{\n    int i;\n    boolean_T error = EXT_NO_ERROR;\n\n#ifdef TMW_EXTMODE_TESTING_REQ\n#  ifndef TMW_EXTMODE_TESTING\n#ifndef EXTMODE_DISABLEPRINTF \n    fprintf(stderr,\"Error: External mode tests should use the external mode test harness.\\n\");\n#endif\n    error = EXT_ERROR;\n#  endif\n#endif\n    if (error != EXT_NO_ERROR) goto EXIT_POINT;\n\n    error = ExtInit(extUD);\n    if (error != EXT_NO_ERROR) goto EXIT_POINT;\n\n    for (i=0; i<NUM_UPINFOS; i++) {\n        UploadLogInfoReset(i);\n    }\n\n    rtExtModeTestingInit();\n\nEXIT_POINT:\n    return(error);\n} /* end rt_ExtModeInit */\n\n\n/* Function: rt_ExtModeSleep ===================================================\n * Abstract:\n *  Called by grt_main, ert_main, and grt_malloc_main  to \"pause\".  It attempts\n *  to do this in a way that does not hog the processor.\n */\n#ifndef VXWORKS\nPUBLIC void rt_ExtModeSleep(\n    long sec,  /* number of seconds to wait       */\n    long usec) /* number of micro seconds to wait */\n{\n    ExtModeSleep(extUD,sec,usec);\n} /* end rt_ExtModeSleep */\n#endif\n\n\n/* Function: rt_PktServerWork ==================================================\n * Abstract:\n *  If not connected, establish communication of the packet line and the\n *  data upload line.  If connected, send/receive packets and parameters\n *  on the packet line.\n */\nPUBLIC void rt_PktServerWork(RTWExtModeInfo *ei,\n                             int_T          numSampTimes,\n                             boolean_T      *stopReq)\n{\n    PktHeader  pktHdr;\n    boolean_T  hdrAvail;\n    boolean_T  error             = EXT_NO_ERROR;\n    boolean_T  disconnectOnError = false;\n    \n    /*\n     * If not connected, attempt to make connection to host.\n     */\n    if (!connected) {\n        rtExtModeTestingKillIfOrphaned(false);\n\n        error = ExtOpenConnection(extUD,&connected);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n    }\n\n    /*\n     * If ExtOpenConnection is not blocking and there are no pending\n     * requests to open a connection, we'll still be unconnected.\n     */\n    if (!connected) goto EXIT_POINT; /* nothing to do */\n    \n    /*\n     * Process packets.\n     */\n\n    /* Wait for a packet. */\n    error = GetPktHdr(&pktHdr, &hdrAvail);\n    if (error != EXT_NO_ERROR) {\n#ifndef EXTMODE_DISABLEPRINTF            \n        fprintf(stderr, \"\\nError occurred getting packet header.\\n\");\n#endif\n        disconnectOnError = true;\n        goto EXIT_POINT;\n    }\n    rtExtModeTestingKillIfOrphaned(hdrAvail);\n    \n    if (!hdrAvail) goto EXIT_POINT; /* nothing to do */\n\n    /*\n     * This is the first packet.  Should contain the string:\n     * 'ext-mode'.  Its contents are not important to us.\n     * It is used as a flag to start the handshaking process.\n     */\n    if (!commInitialized) {\n        pktHdr.type = EXT_CONNECT;\n    }\n\n    /* \n     * At this point we know that we have a packet: process it.\n     */\n#ifdef VXWORKS\n    taskSafe();\n#endif\n    switch(pktHdr.type) {\n\n    case EXT_GET_TIME:\n    {\n        /* Skip verbosity print out - we get too many of these */\n        /*PRINT_VERBOSE((\"got EXT_GET_TIME packet.\\n\"));*/\n        time_T t = rteiGetT(ei);\n        \n        error = SendPktToHost(\n            EXT_GET_TIME_RESPONSE,sizeof(time_T),\n            (char_T *)&t);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n        break;\n    }\n\n    case EXT_ARM_TRIGGER:\n    {\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n        error = ProcessCancelLoggingArmTriggerPkt(EXT_ARM_TRIGGER_RESPONSE, pktHdr.size, numSampTimes);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#else\n        error = AcknowledgeSignalActionPkt(pktHdr.size, EXT_ARM_TRIGGER_RESPONSE);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#endif\n        break;\n    }\n\n    case EXT_SELECT_SIGNALS:\n    {\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n        error = ProcessSelectTriggerSignalPkt(EXT_SELECT_SIGNALS_RESPONSE, ei, pktHdr.size, numSampTimes, ERRMSG_PROCESSSELECTSIGNAL);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#else\n        error = AcknowledgeSignalActionPkt(pktHdr.size, EXT_SELECT_SIGNALS_RESPONSE);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#endif\n        break;\n    }\n\n    case EXT_SELECT_TRIGGER: \n    {\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n        error = ProcessSelectTriggerSignalPkt(EXT_SELECT_TRIGGER_RESPONSE, ei, pktHdr.size, -1, ERRMSG_PROCESSSELECTTRIGGER);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#else\n        error = AcknowledgeSignalActionPkt(pktHdr.size, EXT_SELECT_TRIGGER_RESPONSE);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#endif\n        break;\n    }\n\n    case EXT_CONNECT:\n    {\n        PRINT_VERBOSE((\"got EXT_CONNECT packet.\\n\"));\n        error = ProcessConnectPkt(ei);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n        break;\n    }\n\n    case EXT_SETPARAM:\n    {\n#ifndef EXTMODE_DISABLEPARAMETERTUNING\n        PRINT_VERBOSE((\"got EXT_SETPARAM packet.\\n\"));\n        if (pktHdr.size == 0) {\n            gblSetParamPktReceived = true;\n        } else {\n            error = ProcessSetParamPkt(ei, pktHdr.size);\n            if (error != EXT_NO_ERROR) {\n                goto EXIT_POINT;\n            }\n            else {\n                gblSetParamPktReceived = true;\n            }\n        }\n#else\n        PRINT_VERBOSE((\"discard EXT_SETPARAM packet.\\n\"));\n        error = AcknowledgeSetParamPkt(pktHdr.size);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#endif\n        break;\n    }\n\n    case EXT_GETPARAMS:\n    {\n#ifndef EXTMODE_DISABLEPARAMETERTUNING\n        PRINT_VERBOSE((\"got EXT_GETPARAMS packet.\\n\"));\n        error = ProcessGetParamsPkt(ei);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#endif\n        break;\n    }\n\n    case EXT_DISCONNECT_REQUEST:\n    {\n        PRINT_VERBOSE((\"got EXT_DISCONNECT_REQUEST packet.\\n\"));\n        \n        /*\n         * Note that from the target's point of view this is\n         * more a \"notify\" than a \"request\".  The host needs to\n         * have this acknowledged before it can begin closing\n         * the connection.\n         */\n        error = SendPktToHost(EXT_DISCONNECT_REQUEST_RESPONSE, 0, NULL);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n\n        DisconnectFromHost(numSampTimes);\n\n        break;\n    }\n\n    case EXT_DISCONNECT_REQUEST_NO_FINAL_UPLOAD:\n    {\n        PRINT_VERBOSE((\"got EXT_DISCONNECT_REQUEST_NO_FINAL_UPLOAD packet.\\n\"));\n        \n        /*\n         * The target receives this packet when the host is\n         * immediately terminating the extmode communication due\n         * to some error.  The target should not send back a\n         * response or a final upload of data because the host is\n         * expecting neither.  The target must be disconnected and\n         * returned to a state where it is running and can be\n         * re-connected to by the host.\n         */\n        ForceDisconnectFromHost(numSampTimes);\n\n        break;\n    }\n\n    case EXT_MODEL_START:\n        PRINT_VERBOSE((\"got EXT_MODEL_START packet.\\n\"));\n#ifdef VXWORKS\n        {\n            extern SEM_ID startStopSem;\n            semGive(startStopSem);\n        }\n#endif\n        startModel = true;\n        error = SendPktToHost(EXT_MODEL_START_RESPONSE, 0, NULL);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n        break;\n\n    case EXT_MODEL_STOP:\n        PRINT_VERBOSE((\"got EXT_MODEL_STOP packet.\\n\"));\n        *stopReq = true;\n        break;\n#ifndef EXTMODE_DISABLETESTING\n    case EXT_MODEL_PAUSE:\n        PRINT_VERBOSE((\"got EXT_MODEL_PAUSE packet.\\n\"));\n        modelStatus = TARGET_STATUS_PAUSED;\n        startModel  = false;\n\n        error = SendPktToHost(EXT_MODEL_PAUSE_RESPONSE, 0, NULL);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n        break;\n    case EXT_MODEL_STEP:\n        PRINT_VERBOSE((\"got EXT_MODEL_STEP packet.\\n\"));\n        if ((modelStatus == TARGET_STATUS_PAUSED) && !startModel) {\n            startModel = true;\n        }\n        \n        error = SendPktToHost(EXT_MODEL_STEP_RESPONSE, 0, NULL);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n        break;\n    case EXT_MODEL_CONTINUE:\n        PRINT_VERBOSE((\"got EXT_MODEL_CONTINUE packet.\\n\"));\n        if (modelStatus == TARGET_STATUS_PAUSED) {\n            modelStatus = TARGET_STATUS_RUNNING;\n            startModel  = false;\n        }\n        \n        error = SendPktToHost(EXT_MODEL_CONTINUE_RESPONSE, 0, NULL);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#endif\n        break;\n\n    case EXT_CANCEL_LOGGING:\n    {\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n        error = ProcessCancelLoggingArmTriggerPkt(EXT_CANCEL_LOGGING_RESPONSE, pktHdr.size, numSampTimes);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#else\n        error = AcknowledgeSignalActionPkt(pktHdr.size, EXT_CANCEL_LOGGING_RESPONSE);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#endif\n        break;\n    }\n\n    default:\n#ifndef EXTMODE_DISABLEPRINTF            \n        fprintf(stderr,\"received invalid packet.\\n\");\n#endif\n        break;\n    } /* end switch */\n\nEXIT_POINT:\n    if (error != EXT_NO_ERROR) {\n        if (disconnectOnError) {\n#ifndef EXTMODE_DISABLEPRINTF                \n            fprintf(stderr,\n                \"Error occurred in rt_PktServerWork.\\n\"\n                \"Disconnecting from host!\\n\");\n#endif\n            /* An error in this function which causes disconnectOnError to be\n             * set to true is caused by a physical failure in the external mode\n             * connection.  We assume this failure caused the host to disconnect.\n             * The target must be disconnected and returned to a state\n             * where it is running and can be re-connected to by the host.\n             */\n            ForceDisconnectFromHost(numSampTimes);\n        }\n    }\n#ifdef VXWORKS\n    taskUnsafe();\n#endif\n} /* end rt_PktServerWork */\n\n\n/* Function: rt_PktServer ======================================================\n * Abstract:\n *  Call rt_PktServerWork forever.   Used only for RTOS (e.g., Tornado/VxWorks\n *  when running as a low priority task.\n */\n#ifdef VXWORKS\nPUBLIC void rt_PktServer(RTWExtModeInfo *ei,\n                         int_T          numSampTimes,\n                         boolean_T      *stopReq)\n{\n    for(;;) {\n        rt_PktServerWork(ei,numSampTimes,stopReq); \n    }\n}\n#endif\n\n\n/* Function: rt_UploadServer ===================================================\n * Abstract:\n *  Call rt_UploadServerWork forever.   Used only for RTOS (e.g.,\n *  Tornado/VxWorks when running as a low priority task.\n */\n#ifdef VXWORKS\n#ifndef EXTMODE_DISABLESIGNALMONITORING\nPUBLIC void rt_UploadServer(int_T numSampTimes)\n{\n    for(;;) {\n        rt_UploadServerWork(numSampTimes);\n    }\n} /* end rt_UploadServer */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n#endif\n\n\n/* Function: rt_SetPortInExtUD =================================================\n * Abstract:\n *  Set the port in the external mode user data structure.\n */\n#ifdef VXWORKS\nPUBLIC void rt_SetPortInExtUD(const int_T port)\n{\n    ExtUserDataSetPort(extUD, port);\n} /* end rt_SetPortInExtUD */\n#endif\n\n/* Function: ExtModeShutdown ==================================================\n * Abstract:\n *  Called when target program terminates to enable cleanup of external \n *  mode for a given upInfo.\n */\nPRIVATE void ExtModeShutdown(int32_T upInfoIdx, int_T numSampTimes)\n{\n    /*\n     * Make sure buffers are flushed so that the final points get to\n     * host (this is important for the case of the target reaching tfinal\n     * while data uploading is in progress).\n     */\n    UploadPrepareForFinalFlush(upInfoIdx);\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n    UploadServerWork(upInfoIdx, numSampTimes);\n#endif\n\n    UploadLogInfoTerm(upInfoIdx, numSampTimes);\n\n    if (pktBuf != NULL) {\n        free(pktBuf);\n        pktBuf = NULL;\n    }\n\n} /* end ExtModeShutdown */\n\n/* Function: rt_ExtModeShutdown ================================================\n * Abstract:\n *  Called when target program terminates to enable cleanup of external \n *  mode.\n */\nPUBLIC boolean_T rt_ExtModeShutdown(int_T numSampTimes)\n{\n    int i;\n    boolean_T error = EXT_NO_ERROR;\n\n    for (i=0; i<NUM_UPINFOS; i++) {\n        ExtModeShutdown(i, numSampTimes);\n    }\n\n    if (commInitialized) {\n        error = SendPktToHost(EXT_MODEL_SHUTDOWN, 0, NULL);\n        if (error != EXT_NO_ERROR) {\n#ifndef EXTMODE_DISABLEPRINTF                \n            fprintf(stderr,\n                \"\\nError sending EXT_MODEL_SHUTDOWN packet to host.\\n\");\n#endif\n        }\n        commInitialized = false;\n    }\n    if (connected) {\n        connected = false;\n        modelStatus = TARGET_STATUS_WAITING_TO_START;        \n    }\n\n    ExtShutDown(extUD);\n    ExtUserDataDestroy(extUD);\n    \n    rtExtModeTestingRemoveBatMarker();\n    \n    return(error);\n} /* end rt_ExtModeShutdown */\n\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n/* Function: rt_UploadCheckTrigger =============================================\n * Abstract:\n *  Wrapper function that calls UploadCheckTrigger once for each upInfo\n */\nPUBLIC void rt_UploadCheckTrigger(int_T numSampTimes)\n{\n    int i;\n    for (i=0; i<NUM_UPINFOS; i++) {\n        UploadCheckTrigger(i, numSampTimes);\n    }\n} /* end rt_UploadCheckTrigger */\n\n/* Function: rt_UploadCheckEndTrigger ==========================================\n * Abstract:\n *  Wrapper function that calls UploadCheckTrigger once for each upInfo\n */\nPUBLIC void rt_UploadCheckEndTrigger(void)\n{\n    int i;\n    \n    for (i=0; i<NUM_UPINFOS; i++) {\n        UploadCheckEndTrigger(i);\n    }\n} /* end rt_UploadCheckEndTrigger */\n\n/* Function: rt_UploadBufAddTimePoint ==========================================\n * Abstract:\n *  Wrapper function that calls UploadBufAddTimePoint once for each upInfo\n */\nPUBLIC void rt_UploadBufAddTimePoint(int_T tid, real_T taskTime)\n{\n    int i;\n    \n    for (i=0; i<NUM_UPINFOS; i++) {\n        UploadBufAddTimePoint(tid, taskTime, i);\n    }\n} /* end rt_UploadBufAddTimePoint */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n/* [EOF] ext_svr.c */\n"},{"name":"ext_work.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2025a\\rtw\\c\\src\\ext_mode\\common","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1994-2024 The MathWorks, Inc.\n *\n * File: ext_work.c     \n *\n * Abstract:\n *   \n */\n\n#if !defined(EXTMODE_DISABLEPRINTF) || !defined(EXTMODE_DISABLE_ARGS_PROCESSING)\n#include <stdio.h>\n#endif\n\n#include <stdlib.h>        /* for exit() */\n#include <string.h>        /* optional for strcmp */\n\n#include \"rtwtypes.h\"\n#include \"rtw_extmode.h\"\n\n#include \"ext_types.h\"\n#include \"ext_share.h\"\n#include \"updown.h\"\n#include \"ext_svr.h\"\n#include \"ext_svr_transport.h\"\n#include \"ext_work.h\" /* includes all VxWorks headers */\n\n/* Logical definitions */\n#if (!defined(__cplusplus))\n#  ifndef false\n#   define false                       (0U)\n#  endif\n#  ifndef true\n#   define true                        (1U)\n#  endif\n#endif\n\nint_T           volatile startModel  = false;\nTargetSimStatus volatile modelStatus = TARGET_STATUS_WAITING_TO_START;\n\n#ifdef VXWORKS\nSEM_ID volatile uploadSem = NULL;\nSEM_ID volatile commSem   = NULL;\nSEM_ID volatile pktSem    = NULL;\nint_T           extern_pkt_tid;\nint_T           extern_upload_tid;\n\nvoid rtExtModeTornadoStartup(RTWExtModeInfo *ei,\n                             int_T          numSampTimes,\n                             boolean_T      *stopReqPtr,\n                             int_T          priority,\n                             int32_T        stack_size,\n                             SEM_ID         startStopSem)\n{\n    uploadSem = semBCreate(SEM_Q_PRIORITY, SEM_EMPTY);\n    commSem   = semBCreate(SEM_Q_PRIORITY, SEM_FULL);\n    pktSem    = semBCreate(SEM_Q_PRIORITY, SEM_FULL);\n\n    rt_ExtModeInit();\n\n    extern_pkt_tid = taskSpawn(\"tExternPkt\",\n        priority+(numSampTimes), VX_FP_TASK, stack_size, (FUNCPTR)rt_PktServer, \n        (int_T) ei, (int_T) numSampTimes, (int_T) stopReqPtr, 0, 0, 0, 0, 0, 0, 0);\n    if (extern_pkt_tid == ERROR) {\n#ifndef EXTMODE_DISABLEPRINTF\n        printf(\"handle taskpawn error\");\n#endif\n    }\n\n    extern_upload_tid = taskSpawn(\"tExternUpload\",\n        priority+(numSampTimes)+1,VX_FP_TASK, stack_size,(FUNCPTR)rt_UploadServer,\n        (int_T) numSampTimes, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    if (extern_upload_tid == ERROR) {\n#ifndef EXTMODE_DISABLEPRINTF\n        printf(\"handle taskpawn error\");\n#endif\n    }\n\n    /*\n     * Pause until receive model start packet - if external mode.\n     * Make sure the external mode tasks are running so that \n     * we are listening for commands from the host.\n     */\n    if (ExtWaitForStartPkt()) {\n#ifndef EXTMODE_DISABLEPRINTF\n        printf(\"\\nWaiting for start packet from host.\\n\");\n#endif\n        semTake(startStopSem, WAIT_FOREVER);\n    }\n    modelStatus = TARGET_STATUS_RUNNING;\n}\n\nvoid rtExtModeTornadoCleanup(int_T numSampTimes)\n{\n    taskDelete(extern_upload_tid);\n    taskDelete(extern_pkt_tid);\n    rt_ExtModeShutdown(numSampTimes);\n    semDelete(uploadSem);\n    semDelete(commSem);\n    semDelete(pktSem);\n}\n\n/* Function ====================================================================\n *  Used by Tornado/VxWorks to set the port number used by external mode.\n *  Tornado does not parse the port number the same way as the other code\n *  formats.  Instead, the port number is specified as an argument to the\n *  spawn command which passes it into rt_main().  This function is called\n *  by rt_main() to set the port number in the external mode user data\n *  structure.\n */\nvoid rtExtModeTornadoSetPortInExtUD(const int_T port)\n{\n    rt_SetPortInExtUD(port);\n}\n\n#else /* VXWORKS == 0 */\n\n/* Function ====================================================================\n * Pause the process (w/o hogging the cpu) until receive step packet (which\n * means the startModel flag moves to true) or until we are no longer\n * in the paused state.  The packet/upload server must continue to process\n * events (otherwise the host would not be able to communicate with the target).\n */\nvoid rtExtModePauseIfNeeded(RTWExtModeInfo *ei,\n                            int_T          numSampTimes,\n                            boolean_T      *stopReqPtr)\n{\n    while((modelStatus == TARGET_STATUS_PAUSED) && \n          !startModel && !(*stopReqPtr)) {\n        rt_ExtModeSleep(0L, 375000L);\n        rt_PktServerWork(ei,numSampTimes,stopReqPtr);\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n        rt_UploadServerWork(numSampTimes);\n#endif\n    }\n    startModel = false; /* reset to false - if we were stepped we want to\n                         *                  stop again next time we get\n                         *                  back here.\n                         */\n} /* end rtExtModePauseIfNeeded */\n\n/* Function ====================================================================\n * Pause the process (w/o hogging the cpu) until receive start packet\n * from the host.  The packet/upload server must continue to process\n * events (otherwise the host would not be able to communicate with the target).\n */\nvoid rtExtModeWaitForStartPkt(RTWExtModeInfo *ei,\n                              int_T          numSampTimes,\n                              boolean_T      *stopReqPtr)\n{\n    /*\n     * Pause until receive model start packet.\n     */\n    if (ExtWaitForStartPkt()) {\n        while(!startModel && !(*stopReqPtr)) {\n            rt_ExtModeSleep(0L, 375000L);\n            rt_PktServerWork(ei,numSampTimes,stopReqPtr);\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n            rt_UploadServerWork(numSampTimes);\n#endif\n        }\n    }\n    if (modelStatus != TARGET_STATUS_PAUSED) {\n        modelStatus = TARGET_STATUS_RUNNING;\n    } else {\n        /* leave in pause mode */\n    }\n}\n#endif\n\nvoid rtExtModeOneStep(RTWExtModeInfo *ei,\n                      int_T          numSampTimes,\n                      boolean_T      *stopReqPtr)\n{\n    /*\n     * In a multi-tasking environment, this would be removed from the base rate\n     * and called as a \"background\" task.\n     */\n    if (modelStatus != TARGET_STATUS_PAUSED) {\n        rt_PktServerWork(ei,numSampTimes,stopReqPtr);\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n        rt_UploadServerWork(numSampTimes);\n#endif\n    }\n}\n\nvoid rtExtModeUpload(int_T tid, real_T taskTime)\n{\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n    rt_UploadBufAddTimePoint(tid, taskTime);\n#endif\n}\n\nvoid rtExtModeCheckEndTrigger(void)\n{\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n    rt_UploadCheckEndTrigger();\n#endif\n}\n\nvoid rtExtModeUploadCheckTrigger(int_T numSampTimes)\n{\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n    rt_UploadCheckTrigger(numSampTimes);\n#endif\n}\n\nvoid rtExtModeCheckInit(int_T numSampTimes)\n{\n    UNUSED_PARAMETER(numSampTimes);\n    if (rt_ExtModeInit() != EXT_NO_ERROR){\n#ifndef EXTMODE_DISABLEPRINTF            \n            printf(\"Error calling rt_ExtModeInit!\\n\");\n            exit(EXIT_FAILURE);         /*Error out if rt_ExtModeInit() returns EXT_ERROR. */\n#endif\n    }\n}\n\nvoid rtExtModeShutdown(int_T numSampTimes)\n{\n    rt_ExtModeShutdown(numSampTimes);\n}\n\nvoid rtExtModeParseArgs(int_T        argc, \n                        const char_T *argv[],\n                        real_T       *unused)\n{\n    UNUSED_PARAMETER(unused);\n\n#ifdef  EXTMODE_DISABLE_ARGS_PROCESSING\n    /* Some targets do not support command line args, so bypass the args \n     * processing and directly call into ExtParseArgsAndInitUD.\n     */\n\n    /* initialize external mode */\n    ExtParseArgsAndInitUD(0, NULL);\n\n#else   \n\n    /*\n     * Parse the external mode arguments.\n     */\n    {\n        const char_T *extParseErrorPkt = ExtParseArgsAndInitUD(argc, argv);\n        if (extParseErrorPkt != NULL) {\n#ifndef EXTMODE_DISABLEPRINTF            \n            printf(\n                \"\\nError processing External Mode command line arguments:\\n\");\n            printf(\"\\t%s\",extParseErrorPkt);\n#endif\n            exit(EXIT_FAILURE);\n        }\n    }\n#endif  /* EXTMODE_DISABLE_ARGS_PROCESSING */\n}\n\n/* Start of ERT specific functions and data */\n\n#ifndef EXTMODE_DISABLE_ARGS_PROCESSING\nstatic void displayUsage(void)\n{\n#ifndef EXTMODE_DISABLEPRINTF    \n    (void) printf(\"usage: model_name -tf <finaltime> -w -port <TCPport>\\n\");\n    (void) printf(\"arguments:\\n\");\n    (void) printf(\"  -tf <finaltime> - overrides final time specified in \"\n                  \"Simulink (inf for no limit).\\n\");\n    (void) printf(\"  -w              - waits for Simulink to start model \"\n                  \"in External Mode.\\n\");\n    (void) printf(\"  -port <TCPport> - overrides 17725 default port in \"\n                  \"External Mode, valid range 256 to 65535.\\n\");\n#endif    \n}\n#endif\n\nstatic const real_T RUN_FOREVER = (real_T)-1;\n#if INTEGER_CODE == 0\nstatic real_T finaltime = (real_T)-2; /* default to stop time in Sim Params. */\n#else\nstatic real_T finaltime = (real_T)-1; /* default to stop time inf */\n#endif\n\nvoid rtERTExtModeSetTFinal(real_T *rtmTFinal)\n{\n    if (finaltime >= (real_T)0 || finaltime == RUN_FOREVER) {\n        *rtmTFinal = finaltime;\n    }\n}\n\nvoid rtSetTFinalForExtMode(real_T *rtmTFinal)\n{\n    rtERTExtModeSetTFinal(rtmTFinal);\n}\n\nvoid rtParseArgsForExtMode(int_T        argc, \n                           const char_T *argv[])\n{\n\n#ifdef  EXTMODE_DISABLE_ARGS_PROCESSING\n    /* Some targets do not support command line args, so bypass the args \n     * processing and directly call into ExtParseArgsAndInitUD.\n     */\n\n    /* initialize external mode */\n    ExtParseArgsAndInitUD(0, NULL);\n\n#else    \n    /* parse command line args */\n\n    int_T  oldStyle_argc;\n    const char_T *oldStyle_argv[5];\n\n    if ((argc > 1) && (argv[1][0] != '-')) {\n        /* at least one command line argument has been provided without\n           specifying an option with '-', using the old style */\n        if ( argc > 3 ) {\n            displayUsage();\n            exit(EXIT_FAILURE);\n        }\n\n        /* using the old style the first argument is always the final time */\n        oldStyle_argc = 3;\n        oldStyle_argv[0] = argv[0];\n        oldStyle_argv[1] = \"-tf\";\n        oldStyle_argv[2] = argv[1];\n\n        if (argc == 3) {\n            oldStyle_argc = 5;\n\n            oldStyle_argv[3] = \"-port\";\n            oldStyle_argv[4] = argv[2];\n\n        }\n\n        argc = oldStyle_argc;\n        argv = oldStyle_argv;\n\n    }\n\n    {\n        /* new style: */\n        double    tmpDouble;\n        char_T tmpStr2[201];\n        int_T  count      = 1;\n        int_T  parseError = false;\n\n        /*\n         * Parse the standard RTW parameters.  Let all unrecognized parameters\n         * pass through to external mode for parsing.  NULL out all args handled\n         * so that the external mode parsing can ignore them.\n         */\n        while(count < argc) {\n            const char_T *option = argv[count++];\n            \n            /* final time */\n            if ((strcmp(option, \"-tf\") == 0) && (count != argc)) {\n                const char_T *tfStr = argv[count++];\n                \n                if (sscanf(tfStr, \"%200s\", tmpStr2) != 1) {\n                    parseError = true;\n                    break;\n                }\n                if (strcmp(tmpStr2, \"inf\") == 0) {\n                    tmpDouble = RUN_FOREVER;\n                } else {\n                    char_T tmpstr[2];\n\n#if INTEGER_CODE == 0\n                    if ( (sscanf(tmpStr2,\"%lf%1s\", &tmpDouble, tmpstr) != 1) ||\n                         (tmpDouble < (real_T)0) ) {\n    #ifndef EXTMODE_DISABLEPRINTF\n                        (void)printf(\"finaltime must be a positive, real value or inf\\n\");\n    #endif\n                        parseError = true;\n                        break;\n                    }\n#else\n                    if ( (sscanf(tmpStr2,\"%d%1s\", &tmpDouble, tmpstr) != 1) ||\n                         (tmpDouble < (real_T)0) ) {\n    #ifndef EXTMODE_DISABLEPRINTF\n                        (void)printf(\"tmpDouble = %d\\n\", tmpDouble);\n                        (void)printf(\"finaltime must be a positive, integer value or inf\\n\");\n    #endif\n                        parseError = true;\n                        break;\n                    }\n#endif\n                }\n                finaltime = (real_T) tmpDouble;\n\n                argv[count-2] = NULL;\n                argv[count-1] = NULL;\n            }\n        }\n\n        if (parseError) {\n    #ifndef EXTMODE_DISABLEPRINTF        \n            (void)printf(\"\\nUsage: model_name -option1 val1 -option2 val2 -option3 \"\n                         \"...\\n\\n\");\n            (void)printf(\"\\t-tf 20 - sets final time to 20 seconds\\n\");\n    #endif        \n\n            exit(EXIT_FAILURE);\n        }\n\n        /*\n         * Parse the external mode arguments.\n         */\n        {\n            const char_T *extParseErrorPkt = ExtParseArgsAndInitUD(argc, argv);\n            if (extParseErrorPkt != NULL) {\n    #ifndef EXTMODE_DISABLEPRINTF           \n                printf(\n                    \"\\nError processing External Mode command line arguments:\\n\");\n                printf(\"\\t%s\",extParseErrorPkt);\n    #endif\n                exit(EXIT_FAILURE);\n            }\n        }\n\n        /*\n         * Check for unprocessed (\"unhandled\") args.\n         */\n        {\n            int i;\n            for (i=1; i<argc; i++) {\n                if (argv[i] != NULL) {\n    #ifndef EXTMODE_DISABLEPRINTF                \n                    printf(\"Unexpected command line argument: %s\\n\",argv[i]);\n    #endif\n                    exit(EXIT_FAILURE);\n                }\n            }\n        }\n    }\n\n    if (finaltime == RUN_FOREVER) {\n        #ifndef EXTMODE_DISABLEPRINTF\n                printf (\"\\n**warning: the simulation will run with no stop time due \"\n                \"to external mode with '-tf inf' argument.\\n\");\n        #endif\n    }\n\n#endif /* EXTMODE_DISABLE_ARGS_PROCESSING */\n}\n\nvoid rtERTExtModeStartMsg(void)\n{\n#ifndef EXTMODE_DISABLEPRINTF    \n    (void)printf(\"\\n** starting the model **\\n\");\n#endif\n}\n\n/* End of ERT specific functions and data */\n\n/* [EOF] ext_work.c */\n"},{"name":"rt_matrx.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2025a\\rtw\\c\\src","tag":"","groupDisplay":"Other files","code":"/* File    : rt_matrx.c\n * Abstract:\n *      Implements stand alone matrix access and creation routines.\n *\tThere are two types of MATLAB objects which can be \"passed\" to\n *\tthe generated code, a 2D real matrix and a string. Strings are\n *\tpassed as 2D real matrices. The first two elements of an S-function\n *\tparameters are the row and column (m and n) dimensions respectively.\n *\tThese are followed by the matrix data.\n */\n\n\n\n/*\n * Copyright 1994-2024 The MathWorks, Inc.\n */\n\n/*==========*\n * Includes *\n *==========*/\n\n#if defined(MDL_REF_SIM_TGT)\n#undef MATLAB_MEX_FILE\n#endif\n\n#if defined(MATLAB_MEX_FILE)\n# error \"rt_matrix cannot be used within a mex file. It is for codegen only.\"\n#endif\n\n#include <string.h>    /* for strlen */\n#include \"rt_matrx.h\"\n\n#include <stddef.h> /* needed for size_t and NULL */\n#include <float.h>  /* needed for definition of eps */\n\n/*==========*\n * Typedefs *\n *==========*/\n\n#ifndef rt_typedefs_h\n#define rt_typedefs_h\n\n#if !defined(TYPEDEF_MX_ARRAY)\n# define TYPEDEF_MX_ARRAY\n  typedef real_T mxArray;\n#endif\n\ntypedef real_T mxChar;\n\n\ntypedef enum {\n    mxREAL,\n    mxCOMPLEX\n} mxComplexity;\n\n#endif /* rt_typedefs_h */\n\n/*==================*\n * Extern variables *\n *==================*/\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nextern real_T rtInf;\nextern real_T rtMinusInf;\nextern real_T rtNaN;\n\n#ifdef __cplusplus\n}\n#endif\n\n/*=======================================*\n * Defines for mx Routines and constants *\n *=======================================*/\n\n\n#define mxCalloc(n,size) \\\n        calloc(n,size)\n\n#define mxCreateCharArray(ndim, dims) \\\n        mxCreateNumericArray(ndim, dims, mxCHAR_CLASS);\n\n#define mxDestroyArray(pa) \\\n        if (pa) free(pa)\n\n/* NOTE: You cannot mxFree(mxGetPr(pa)) !!! */\n#define mxFree(ptr) \\\n        if(ptr)free(ptr)\n\n#define mxGetClassID(pa) \\\n        mxDOUBLE_CLASS\n\n/* NOTE: mxGetClassName(pa) returns \"double\" even on a character array */\n#define mxGetClassName(pa) \\\n        \"double\"\n\n#define mxGetData(pa) \\\n        ((void *)(&((pa)[2])))\n\n#define mxGetElementSize(pa) \\\n        (sizeof(real_T))\n\n#define mxGetInf() \\\n        rtInf\n\n#define mxGetM(pa) \\\n        ((size_t) ((pa)[0]))\n#define mxGetN(pa) \\\n        ((size_t) ((pa)[1]))\n\n#define mxGetNaN() \\\n        rtNaN\n\n#define mxGetNumberOfDimensions(pa) \\\n        (2)\n#define mxGetNumberOfElements(pa) \\\n        (mxGetM(pa)*mxGetN(pa))\n\n/* NOTE: mxGetPr() of an empty matrix does NOT return NULL */\n#define mxGetPr(pa) \\\n        ( &((pa)[2]) )\n\n/* NOTE: mxGetDoubles() of an empty matrix does NOT return NULL */\n#define mxGetDoubles(pa) \\\n        ( &((pa)[2]) )\n\n#define mxGetScalar(pa) \\\n        ((pa)[2])\n\n#define mxIsComplex(pa) \\\n        false\n\n#define mxIsDouble(pa) \\\n        true\n\n#define mxIsEmpty(pa) \\\n        (mxGetM(pa)==0 || mxGetN(pa)==0)\n\n#define mxIsFinite(r) \\\n        ((r)>rtMinusInf && (r)<rtInf)\n\n#define mxIsInf(r) \\\n        ((r)==rtInf || (r)==rtMinusInf)\n\n#define mxIsInt16(pa) \\\n        false\n\n#define mxIsInt32(pa) \\\n        false\n\n#define mxIsInt8(pa) \\\n        false\n\n#define mxIsLogical(pa) \\\n        false\n\n#define mxIsNumeric(pa) \\\n        true\n\n#define mxIsSingle(pa) \\\n        false\n\n#define mxIsSparse(pa) \\\n        false\n\n#define mxIsStruct(pa) \\\n        false\n\n#define mxIsUint16(pa) \\\n        false\n\n#define mxIsUint32(pa) \\\n        false\n\n#define mxIsUint8(pa) \\\n        false\n\n#define mxMalloc(n) \\\n        malloc(n)\n\n#define mxRealloc(p,n) \\\n        realloc(p,n)\n\n/*==============*\n * Local macros *\n *==============*/\n#define _mxSetM(pa,m) \\\n        (pa)[0] = ((int)(m))\n\n#define _mxSetN(pa,n) \\\n        (pa)[1] = ((int)(n))\n\n\n/*==========================*\n * Visible/extern functions *\n *=========================*/\n\n/* Function: mxCreateCharMatrixFromStrings ====================================\n * Abstract:\n *\tCreate a string array initialized to the strings in str.\n */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nmxArray *rt_mxCreateCharMatrixFromStrings(int_T m, const char_T **str)\n{\n    int_T nchars;\n    int_T i, n;\n    mxArray *pa;\n\n    n = 0;\n    for (i = 0; i < m; ++i) {\n\tnchars = (int_T)strlen(str[i]);\n\tif (nchars > n) {\n\t    n = nchars;\n\t}\n    }\n\n    pa = (mxArray *)malloc((m*n+2)*sizeof(real_T));\n    if(pa!=NULL) {\n\tmxChar *chars;\n\tint_T  j;\n\t_mxSetM(pa, m);\n\t_mxSetN(pa, n);\n\tchars = mxGetPr(pa);\n\tfor (j = 0; j < m; ++j) {\n\t    const char_T *src  = str[j];\n\t    mxChar *dest = chars + j;\n\n\t    nchars = (int_T)strlen(src);\n\t    i = nchars;\n\t    while (i--) {\n\t\t*dest = *src++;\n\t\t dest += m;\n\t    }\n\t    i = n - nchars;\n\t    while (i--) {\n\t\t*dest = 0.0;\n\t\tdest += m;\n\t    }\n\t}\n    }\n    return pa;\n} /* end mxCreateCharMatrixFromStrings */\n\n#ifdef __cplusplus\n}\n#endif\n\n/* Function: mxCreateString ===================================================\n * Abstract:\n *\tCreate a 1-by-n string array initialized to null terminated string\n *\twhere n is the length of the string.\n */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nmxArray *rt_mxCreateString(const char *str)\n{\n    int_T   len = (int_T)strlen(str);\n\n    mxArray *pa = (mxArray *)malloc((len+2)*sizeof(real_T));\n\n    if(pa!=NULL) {\n\treal_T *pr;\n\tconst unsigned char *ustr_ptr = (const unsigned char *) str;\n\n\t_mxSetM(pa, 1);\n\t_mxSetN(pa, len);\n\tpr = mxGetPr(pa);\n\twhile (len--) {\n            *pr++ = (real_T)*ustr_ptr++;\n        }\n    }\n    return(pa);\n\n} /* end mxCreateString */\n\n#ifdef __cplusplus\n}\n#endif\n\n/* Function: mxCreateDoubleMatrix =============================================\n * Abstract:\n *\tCreate a two-dimensional array to hold real_T data,\n *\tinitialize each data element to 0.\n */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nmxArray *rt_mxCreateDoubleMatrix(int m, int n, mxComplexity flag)\n{\n    if (flag == mxREAL) {\n        mxArray *pa = (mxArray *)calloc(m*n+2, sizeof(real_T));\n        if(pa!=NULL) {\n            _mxSetM(pa, m);\n            _mxSetN(pa, n);\n        }\n        return(pa);\n    } else {\n        return(NULL);\n    }\n\n} /* end mxCreateDoubleMatrix */\n\n#ifdef __cplusplus\n}\n#endif\n\n/* Function: mxCreateNumericArray =============================================\n * Abstract:\n *\tCreate a numeric array and initialize all its data elements to 0.\n */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nmxArray *rt_mxCreateNumericArray(int_T ndims, const mwSize *dims, \n                                        mxClassID classid, mxComplexity flag)\n{\n    if (ndims == 2 && classid==mxDOUBLE_CLASS) {\n        return(rt_mxCreateDoubleMatrix((int)(dims[0]), (int)(dims[1]), flag));\n    } else {\n        return(NULL);\n    }\n\n} /* end mxCreateNumericArray */\n\n#ifdef __cplusplus\n}\n#endif\n\n/* Function: mxDuplicateArray =================================================\n * Abstract:\n *\tMake a deep copy of an array, return a pointer to the copy.\n */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nmxArray *rt_mxDuplicateArray(const mxArray *pa)\n{\n\n    size_t   nbytes = (mxGetNumberOfElements(pa)+2)*mxGetElementSize(pa);\n    mxArray *pcopy = (mxArray *)malloc(nbytes);\n\n    if (pcopy!=NULL) {\n\t(void)memcpy(pcopy, pa, nbytes);\n    }\n    return(pcopy);\n\n} /* end mxDuplicateArray */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n/* Function: mxGetDimensions ==================================================\n * Abstract:\n *\tGet pointer to dimension array\n */\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nconst mwSize *rt_mxGetDimensions(const mxArray *pa)\n{\n    static mwSize dims[2];\n    dims[0] = mxGetM(pa);\n    dims[1] = mxGetN(pa);\n    return dims;\n} /* end mxGetDimensions */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n/* Function: mxGetEps =========================================================\n * Abstract:\n *\tReturn eps, the difference between 1.0 and the least value\n *\tgreater than 1.0 that is representable as a real_T.\n */\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nreal_T rt_mxGetEps(void)\n{\n    return (sizeof(double)==sizeof(real_T)) ? DBL_EPSILON : (real_T) FLT_EPSILON;\n}\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n/* Function: mxGetString ======================================================\n * Abstract:\n *\tConverts a string array to a C-style string.\n */\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nint_T rt_mxGetString(const mxArray *pa, char_T *buf, int_T buflen)\n{\n    int_T        nchars;\n    const real_T *pr;\n    char_T       *pc;\n    int_T        truncate = 0;\n\n    nchars = (int_T)mxGetNumberOfElements(pa);\n    if (nchars >= buflen) {\n\t/* leave room for null byte */\n\tnchars = buflen - 1;\n\ttruncate = 1;\n    }\n    pc = buf;\n    pr = mxGetPr(pa);\n    while (nchars--) {\n\t*pc++ = (char) (*pr++ + .5);\n    }\n    *pc = '\\0';\n    return truncate;\n} /* end mxGetString */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n#define mxCreateCharMatrixFromStrings(m, str) \\\n        rt_mxCreateCharMatrixFromStrings(m, str)\n\n#define mxCreateString(str) \\\n        rt_mxCreateString(str) \n\n#define mxCreateDoubleMatrix(m, n, flag) \\\n        rt_mxCreateDoubleMatrix(m, n, flag)\n\n#define mxCreateNumericArray(ndims, dims, classid, flag) \\\n        rt_mxCreateNumericArray(ndims, dims, classid, flag)\n\n#define mxDuplicateArray(pa) \\\n        rt_mxDuplicateArray(pa)\n\n#define mxGetDimensions(pa) \\\n        rt_mxGetDimensions(pa)\n\n#define mxGetEps() \\\n        rt_mxGetEps()\n\n#define mxGetString(pa, buf, buflen) \\\n        rt_mxGetString(pa, buf, buflen)\n\n/*=========================*\n * Unsupported mx Routines *\n *=========================*/\n\n#define mxCalcSingleSubscript(pa,nsubs,subs) \\\n        mxCalcSingleSubscript_is_not_supported_in_Simulink_Coder\n\n#define mxCreateCellArray(ndim,dims) \\\n        mxCreateCellArray_is_not_supported_in_Simulink_Coder\n\n#define mxCreateCellMatrix(m,n) \\\n        mxCreateCellMatrix_is_not_supported_in_Simulink_Coder\n\n#define mxCreateSparse(pm,pn,pnzmax,pcmplx_flg) \\\n        mxCreateSparse_is_not_supported_in_Simulink_Coder\n\n#define mxCreateStructArray(ndim,dims,nfields,fieldnames) \\\n        mxCreateStructArray_is_not_supported_in_Simulink_Coder\n\n#define mxCreateStructMatrix(m,n,nfields,fieldnames) \\\n        mxCreateStructMatrix_is_not_supported_in_Simulink_Coder\n\n#define mxGetCell(pa,i) \\\n        mxGetCell_is_not_supported_in_Simulink_Coder\n\n#define mxGetField(pa,i,fieldname) \\\n        mxGetField_is_not_supported_in_Simulink_Coder\n\n#define mxGetFieldByNumber(s,i,fieldnum) \\\n        mxGetFieldByNumber_is_not_supported_in_Simulink_Coder\n\n#define mxGetFieldNameByNumber(pa,n) \\\n        mxGetFieldNameByNumber_is_not_supported_in_Simulink_Coder\n\n#define mxGetFieldNumber(pa,fieldname) \\\n        mxGetFieldNumber_is_not_supported_in_Simulink_Coder\n\n#define mxGetImagData(pa) \\\n        mxGetImagData_is_not_supported_in_Simulink_Coder\n\n#define mxGetIr(ppa) \\\n        mxGetIr_is_not_supported_in_Simulink_Coder\n\n#define mxGetJc(ppa) \\\n        mxGetJc_is_not_supported_in_Simulink_Coder\n\n#define mxGetNumberOfFields(pa) \\\n        mxGetNumberOfFields_is_not_supported_in_Simulink_Coder\n\n#define mxGetNzmax(pa) \\\n        mxGetNzmax_is_not_supported_in_Simulink_Coder\n\n#define mxGetPi(pa) \\\n        mxGetPi_is_not_supported_in_Simulink_Coder\n\n#define mxIsFromGlobalWS(pa) \\\n        mxIsFromGlobalWS_is_not_supported_in_Simulink_Coder\n\n#define mxIsNaN(r) \\\n        mxIsNaN_is_not_supported_in_Simulink_Coder\n\n#define mxIsChar(pa) \\\n        mxIsChar_is_not_supported_in_Simulink_Coder\n\n#define mxIsClass(pa,class) \\\n        mxIsClass_is_not_supported_in_Simulink_Coder\n\n#define mxIsCell(pa) \\\n        mxIsCell_is_not_supported_in_Simulink_Coder\n\n#define mxSetCell(pa,i,value) \\\n        mxSetCell_is_not_supported_in_Simulink_Coder\n\n#define mxSetClassName(pa,classname) \\\n        mxSetClassName_is_not_supported_in_Simulink_Coder\n\n#define mxSetData(pa,pr) \\\n        mxSetData_is_not_supported_in_Simulink_Coder\n\n#define mxSetDimensions(pa, size, ndims) \\\n        mxSetDimensions_is_not_supported_in_Simulink_Coder\n\n#define mxSetField(pa,i,fieldname,value) \\\n        mxSetField_is_not_supported_in_Simulink_Coder\n\n#define mxSetFieldByNumber(pa, index, fieldnum, value) \\\n        mxSetFieldByNumber_is_not_supported_in_Simulink_Coder\n\n#define mxSetFromGlobalWS(pa,global) \\\n        mxSetFromGlobalWS_is_not_supported_in_Simulink_Coder\n\n#define mxSetImagData(pa,pv) \\\n        mxSetImagData_is_not_supported_in_Simulink_Coder\n\n#define mxSetIr(ppa,ir) \\\n        mxSetIr_is_not_supported_in_Simulink_Coder\n\n#define mxSetJc(ppa,jc) \\\n        mxSetJc_is_not_supported_in_Simulink_Coder\n\n#define mxSetM(pa, m) \\\n        mxSetM_is_not_supported_in_Simulink_Coder\n\n#define mxSetN(pa, m) \\\n        mxSetN_is_not_supported_in_Simulink_Coder\n\n#define mxSetPr(pa,pr) \\\n        mxSetPr_is_not_supported_in_Simulink_Coder\n\n#define mxSetNzmax(pa,nzmax) \\\n        mxSetNzmax_is_not_supported_in_Simulink_Coder\n\n#define mxSetPi(pa,pv) \\\n        mxSetPi_is_not_supported_in_Simulink_Coder\n\n\n\n/*==========================*\n * Unsupported mex routines *\n *==========================*/\n\n#define mexPrintAssertion(test,fname,linenum,message) \\\n        mexPrintAssertion_is_not_supported_by_Simulink_Coder\n\n#define mexEvalString(str) \\\n        mexEvalString_is_not_supported_by_Simulink_Coder\n\n#define mexErrMsgTxt(str) \\\n        mexErrMsgTxt_is_not_supported_by_Simulink_Coder\n\n#define mexWarnMsgTxt(warning_msg) \\\n        mexWarnMsgTxt_is_not_supported_by_Simulink_Coder\n\n#define mexPrintf \\\n        mexPrintf_is_not_supported_by_Simulink_Coder\n\n#define mexMakeArrayPersistent(pa) \\\n        mexMakeArrayPersistent_is_not_supported_by_Simulink_Coder\n\n#define mexMakeMemoryPersistent(ptr) \\\n        mexMakeMemoryPersistent_is_not_supported_by_Simulink_Coder\n\n#define mexLock() \\\n        mexLock_is_not_supported_by_Simulink_Coder\n\n#define mexUnlock() \\\n        mexUnlock_is_not_supported_by_Simulink_Coder\n\n#define mexFunctionName() \\\n        mexFunctionName_is_not_supported_by_Simulink_Coder\n\n#define mexIsLocked() \\\n        mexIsLocked_is_not_supported_by_Simulink_Coder\n\n#define mexGetFunctionHandle() \\\n        mexGetFunctionHandle_is_not_supported_by_Simulink_Coder\n\n#define mexCallMATLABFunction() \\\n        mexCallMATLABFunction_is_not_supported_by_Simulink_Coder\n\n#define mexRegisterFunction() \\\n        mexRegisterFunction_is_not_supported_by_Simulink_Coder\n\n#define mexSet(handle,property,value) \\\n        mexSet_is_not_supported_by_Simulink_Coder\n\n#define mexGet(handle,property) \\\n        mexGet_is_not_supported_by_Simulink_Coder\n\n#define mexCallMATLAB(nlhs,plhs,nrhs,prhs,fcn) \\\n        mexCallMATLAB_is_not_supported_by_Simulink_Coder\n\n#define mexSetTrapFlag(flag) \\\n        mexSetTrapFlag_is_not_supported_by_Simulink_Coder\n\n#define mexUnlink(a) \\\n        mexUnlink_is_not_supported_by_Simulink_Coderw\n\n#define mexSubsAssign(plhs,sub,nsubs,prhs) \\\n        mexSubsAssign_is_not_supported_by_Simulink_Coder\n\n#define mexSubsReference(prhs,subs,nsubs) \\\n        mexSubsReference_is_not_supported_by_Simulink_Coder\n\n#define mexPrintAssertion(test,fname,linenum,message) \\\n        mexPrintAssertion_is_not_supported_by_Simulink_Coder\n\n#define mexAddFlops(count) \\\n        mexAddFlops_is_not_supported_by_Simulink_Coder\n\n#define mexIsGlobal(pa) \\\n        mexIsGlobal_is_not_supported_by_Simulink_Coder\n\n#define mexAtExit(fcn) \\\n        mexAtExit_is_not_supported_by_Simulink_Coder\n\n/* [EOF] rt_matrx.c */\n"},{"name":"rt_printf.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2025a\\rtw\\c\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 1994-2015 The MathWorks, Inc.\n *\n * File: rt_printf.c\n *\n * Abstract:\n *      Stub I/O printf facility for systems which don't have stdio.\n *\n */\n\n\n\n/* Function: rtPrintfNoOp ======================================================\n * Abstract:\n *      Maps ssPrintf to rtPrintfNoOp if HAVESTDIO is not defined (see\n *      simstruct.h\n */\nint rtPrintfNoOp(const char *fmt, ...)\n{\n    /* do nothing */\n    return(fmt == (const char *)0); /* use fmt to quiet unused var warning */\n}\n\n\n/* [eof] rt_printf.c */\n"},{"name":"rt_sim.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2025a\\rtw\\c\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 1994-2012 The MathWorks, Inc.\n *\n * File    : rt_sim.c     \n * Abstract:\n *   Performs one time step of a real-time single tasking or multitasking\n *   system for statically or dynamically allocated timing data.\n *\n *   The tasking mode is controlled by the MULTITASKING #define.\n *\n *   The data allocation type is controlled by the RT_MALLOC #define.\n */\n\n\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n#include <stddef.h>\n#include \"tmwtypes.h\"\n#ifdef USE_RTMODEL\n# include \"simstruc_types.h\"\n#else\n# include \"simstruc.h\"\n#endif\n#include \"rt_sim.h\"\n\n/*==========*\n * Struct's *\n *==========*/\n\n/*\n * TimingData\n */\n\n#ifdef RT_MALLOC\n\n/* dynamically allocate data */\ntypedef struct TimingData_Tag {\n    real_T *period;       /* Task periods in seconds                   */\n    real_T *offset;       /* Task offsets in seconds                   */\n    real_T *clockTick;    /* Flint task time tick counter              */\n    int_T  *taskTick;     /* Counter for determining task hits         */\n    int_T  *nTaskTicks;   /* Number base rate ticks for a task hit     */\n    int_T  firstDiscIdx;  /* First discrete task index                 */\n} TimingData;\n\n#else\n\n/* statically allocate data */\ntypedef struct TimingData_Tag {\n    real_T period[NUMST];       /* Task periods in seconds                   */\n    real_T offset[NUMST];       /* Task offsets in seconds                   */\n    real_T clockTick[NUMST];    /* Flint task time tick counter              */\n    int_T  taskTick[NUMST];     /* Counter for determining task hits         */\n    int_T  nTaskTicks[NUMST];   /* Number base rate ticks for a task hit     */\n    int_T  firstDiscIdx;        /* First discrete task index                 */\n} TimingData;\n\n#endif\n\n/*=========================*\n * Data local to this file *\n *=========================*/\n\n#if defined(RT_MALLOC) || defined(USE_RTMODEL)\n/* \"td\" will be a pointer to a dynamically allocated struct */\n#else\n/* statically allocate the struct. \"td\" will point to this static struct */\nstatic TimingData td_struct;\n#endif\n\n/*==================*\n * Visible routines *\n *==================*/\n\n/* Function: rt_SimInitTimingEngine ============================================\n * Abstract:\n *      This function is for use with single tasking or multitasking\n *      real-time systems.  \n *\n *      Initializes the timing engine for a fixed-step real-time system. \n *      It is assumed that start time is 0.0.\n *\n * Returns:\n *      NULL     - success\n *      non-NULL - error string\n */\nconst char *rt_SimInitTimingEngine(int_T       rtmNumSampTimes,\n                                   real_T      rtmStepSize,\n                                   real_T      *rtmSampleTimePtr,\n                                   real_T      *rtmOffsetTimePtr,\n                                   int_T       *rtmSampleHitPtr,\n                                   int_T       *rtmSampleTimeTaskIDPtr,\n                                   real_T      rtmTStart,\n                                   SimTimeStep *rtmSimTimeStepPtr,\n                                   void        **rtmTimingDataPtr)\n{\n#ifdef USE_RTMODEL\n\n    /* In the USE_RTMODEL case this function does nothing */\n\n    UNUSED_PARAMETER(rtmNumSampTimes);\n    UNUSED_PARAMETER(rtmStepSize); \n    UNUSED_PARAMETER(rtmSampleTimePtr);\n    UNUSED_PARAMETER(rtmOffsetTimePtr);\n    UNUSED_PARAMETER(rtmSampleHitPtr);\n    UNUSED_PARAMETER(rtmSampleTimeTaskIDPtr);\n    UNUSED_PARAMETER(rtmSimTimeStepPtr);\n    UNUSED_PARAMETER(rtmTimingDataPtr);\n\n    if (rtmTStart != 0.0) {\n        return(\"Start time must be zero for real-time systems.  For non-zero start times you must use the Simulink solver module\");\n    } else {\n        return(NULL);\n    }\n\n#else /* must be !USE_RTMODEL */\n\n    int_T     i;\n    int       *tsMap     = rtmSampleTimeTaskIDPtr;\n    real_T    *period    = rtmSampleTimePtr;\n    real_T    *offset    = rtmOffsetTimePtr;\n    int_T     *sampleHit = rtmSampleHitPtr;\n    real_T    stepSize   = rtmStepSize;\n\n#ifdef RT_MALLOC\n\n    int_T numst = rtmNumSampTimes;\n\n    /* In the dynamically allocated case, we allocate the data here */\n    static const char_T *malloc_error;\n    TimingData *td;\n    malloc_error = \"Memory allocation error\";\n    td = (TimingData *) malloc(sizeof(TimingData));\n    if (!td) {\n        return(malloc_error);\n    }\n\n    td->period = (real_T *) malloc(numst * sizeof(real_T));\n    if (!td->period) {\n        return(malloc_error);\n    }\n\n    td->offset = (real_T *) malloc(numst * sizeof(real_T));\n    if (!td->offset) {\n        return(malloc_error);\n    }\n\n    td->clockTick = (real_T *) malloc(numst * sizeof(real_T));\n    if (!td->clockTick) {\n        return(malloc_error);\n    }\n\n    td->taskTick = (int_T *) malloc(numst * sizeof(int_T));\n    if (!td->taskTick) {\n        return(malloc_error);\n    }\n\n    td->nTaskTicks = (int_T *) malloc(numst * sizeof(int_T));\n    if (!td->nTaskTicks) {\n        return(malloc_error);\n    }\n    if (rtmTStart != 0.0) {\n        return(\"Start time must be zero for real-time systems.  For non-zero start times you must use the Simulink solver module\");\n    }\n\n#else /* must be !RT_MALLOC */\n\n    /* In the statically allocated case, we point to the static structure */\n    TimingData *td;\n    td = &td_struct;\n\n    /* Also, we use the constant NUMST instead of what was passed in */\n    rtmNumSampTimes = NUMST; \n\n#endif /* !RT_MALLOC */\n\n    if (rtmTStart != 0.0) {\n        return(\"Start time must be zero for real-time systems.  For non-zero start times you must use the Simulink solver module\");\n    }\n\n    *rtmSimTimeStepPtr = MAJOR_TIME_STEP;\n\n    *rtmTimingDataPtr = (void*)&td;\n\n    for (i = 0; i < rtmNumSampTimes; i++) {\n        tsMap[i]         = i;\n        td->period[i]     = period[i];\n        td->offset[i]     = offset[i];\n        td->nTaskTicks[i] = (int_T)floor(period[i]/stepSize + 0.5);\n        if (td->period[i] == CONTINUOUS_SAMPLE_TIME ||\n            td->offset[i] == 0.0) {\n            td->taskTick[i]  = 0;\n            td->clockTick[i] = 0.0;\n            sampleHit[i]    = 1;\n        } else {\n            td->taskTick[i]  = (int_T)floor((td->period[i]-td->offset[i]) /\n                                            stepSize+0.5);\n            td->clockTick[i] = -1.0;\n            sampleHit[i]    = 0;\n        }\n    }\n\n    /* Correct first sample time if continuous task */\n    td->period[0]     = stepSize;\n    td->nTaskTicks[0] = 1; \n\n    /* Set first discrete task index */\n    if (rtmNumSampTimes == 1)\n        td->firstDiscIdx = (int_T)(period[0] == CONTINUOUS_SAMPLE_TIME);\n    else\n        td->firstDiscIdx = ((int_T)(period[0] == CONTINUOUS_SAMPLE_TIME) + \n                          (int_T)(period[1] == CONTINUOUS_SAMPLE_TIME));\n\n    return(NULL); /* success */\n\n#endif /* ! USE_RTMODEL case */\n\n} /* end rt_SimInitTimingEngine */\n\n/* In the statically-allocated case, rt_SimDestroyTimingEngine is not needed. */\n#ifdef RT_MALLOC\n\n/* Dynamically allocated data */\n/* Function: rt_SimDestroyTimingEngine ===========================================\n * Abstract:\n *      This function frees the timing engine data.\n */\nvoid rt_SimDestroyTimingEngine(void *rtmTimingData)\n{\n#ifdef USE_RTMODEL\n    UNUSED_PARAMETER(rtmTimingData);\n#else /* must be !USE_RTMODEL */\n    TimingData *td;\n    td = (TimingData *)rtmTimingData;\n\n    if (td) {\n        if (td->period) {\n            free(td->period);\n        }\n        \n        if (td->offset) {\n            free(td->offset);\n        }\n        \n        if (td->clockTick) {\n            free(td->clockTick);\n        }\n        \n        if (td->taskTick) {\n            free(td->taskTick);\n        }\n        \n        if (td->nTaskTicks) {\n            free(td->nTaskTicks);\n        }\n        free(td);\n    }\n#endif /* !USE_RTMODEL */\n} /* end rt_SimDestroyTimingEngine */\n\n#endif /* RT_MALLOC */\n\n#if !defined(MULTITASKING)\n\n/*###########################################################################*/\n/*########################### SINGLE TASKING ################################*/\n/*###########################################################################*/\n\n/* Function: rt_SimGetNextSampleHit ============================================\n * Abstract:\n *      For a single tasking real-time system, return time of next sample hit.\n */\n/* This function has a different signature in the RT_MALLOC case */\n#ifdef RT_MALLOC\ntime_T rt_SimGetNextSampleHit(void   *rtmTimingData,\n                              int_T   rtmNumSampTimes)\n#else\ntime_T rt_SimGetNextSampleHit(void)\n#endif\n{\n#ifdef USE_RTMODEL\n\n    /* The USE_RTMODEL version of this function does nothing */\n\n#ifdef RT_MALLOC\n    UNUSED_PARAMETER(rtmTimingData);\n    UNUSED_PARAMETER(rtmNumSampTimes);\n#endif\n    return -1;\n\n#else /* must be !USE_RTMODEL */\n\n    time_T timeOfNextHit;\n#ifdef RT_MALLOC\n    TimingData *td;\n    td = (TimingData *)rtmTimingData;\n#else\n    TimingData *td;\n    int_T rtmNumSampTimes;\n    td = &td_struct;\n    rtmNumSampTimes = NUMST; /* it's not passed in, in this case */\n#endif\n    td->clockTick[0] += 1;\n    timeOfNextHit = td->clockTick[0] * td->period[0];\n\n    if(rtmNumSampTimes > 1) {\n        int i;\n        for (i = 1; i < rtmNumSampTimes; i++) {\n            if (++td->taskTick[i] == td->nTaskTicks[i]) {\n                td->taskTick[i] = 0;\n                td->clockTick[i]++;\n            }\n        }\n    }\n\n    return(timeOfNextHit);\n\n#endif /* !USE_RTMODEL */\n} /* end rt_SimGetNextSampleHit */\n\n\n\n/* Function: rt_SimUpdateDiscreteTaskSampleHits ================================\n * Abstract:\n *      This function is for use with single tasking real-time systems.  \n *      \n *      If the number of sample times is greater than one, then we need to \n *      update the discrete task sample hits for the next time step. Note, \n *      task 0 always has a hit since it's sample time is the fundamental \n *      sample time.\n */\nvoid rt_SimUpdateDiscreteTaskSampleHits(int_T  rtmNumSampTimes,\n                                        void   *rtmTimingData,\n                                        int_T  *rtmSampleHitPtr,\n                                        real_T *rtmTPtr)\n{\n#ifdef USE_RTMODEL\n\n    /* The USE_RTMODEL version of this function does nothing */\n    UNUSED_PARAMETER(rtmNumSampTimes);\n    UNUSED_PARAMETER(rtmTimingData);\n    UNUSED_PARAMETER(rtmSampleHitPtr);\n    UNUSED_PARAMETER(rtmTPtr);\n    return;\n\n#else /* must be !USE_RTMODEL */\n\n    int   i;\n    int_T *sampleHit;\n\n#ifdef RT_MALLOC\n    TimingData *td;\n    td = (TimingData *)rtmTimingData;\n#else\n    TimingData *td;\n    UNUSED_PARAMETER(rtmTimingData);\n    td = &td_struct;\n    rtmNumSampTimes = NUMST;\n#endif\n\n    sampleHit = rtmSampleHitPtr;\n\n    for (i = td->firstDiscIdx; i < rtmNumSampTimes; i++) {\n        int_T hit = (td->taskTick[i] == 0);\n        if (hit) {\n            rttiSetTaskTime(rtmTPtr, i,\n                            td->clockTick[i]*td->period[i] + td->offset[i]);\n        }\n        sampleHit[i] = hit;\n    }\n#endif /* !USE_RTMODEL */\n} /* rt_SimUpdateDiscreteTaskSampleHits */\n\n\n\n#else /* defined(MULTITASKING) */\n\n/*###########################################################################*/\n/*############################## MULTITASKING ###############################*/\n/*###########################################################################*/\n\n\n#ifndef USE_RTMODEL\n/* This function is not defined here if USE_RTMODEL is set */\n\n/* Function: rt_SimUpdateDiscreteEvents ========================================\n * Abstract:\n *      This function is for use with multitasking real-time systems. \n *\n *      This function updates the status of the RT_MODEL sampleHits\n *      flags and the perTaskSampleHits matrix which is used to determine \n *      when special sample hits occur.\n *\n *      The RT_MODEL contains a matrix, called perTaskSampleHits. \n *      This matrix is used by the ssIsSpecialSampleHit macro. The row and \n *      column indices are both task id's (equivalent to the root RT_MODEL \n *      sample time indices). This is a upper triangle matrix. This routine \n *      only updates the slower task hits (kept in column j) for row\n *      i if we have a sample hit in row i.\n *\n *                       column j\n *           tid   0   1   2   3   4   5  \n *               -------------------------\n *             0 |   | X | X | X | X | X |\n *         r     -------------------------\n *         o   1 |   |   | X | X | X | X |      This matrix(i,j) answers:\n *         w     -------------------------      If we are in task i, does\n *             2 |   |   |   | X | X | X |      slower task j have a hit now?\n *         i     -------------------------\n *             3 |   |   |   |   | X | X |\n *               -------------------------\n *             4 |   |   |   |   |   | X |      X = 0 or 1\n *               -------------------------\n *             5 |   |   |   |   |   |   |\n *               -------------------------\n *\n *      How macros index this matrix:\n *\n *          ssSetSampleHitInTask(S, j, i, X)   => matrix(i,j) = X\n *\n *          ssIsSpecialSampleHit(S, my_sti, promoted_sti, tid) => \n *              (tid_for(promoted_sti) == tid && !minor_time_step &&\n *               matrix(tid,tid_for(my_sti)) \n *              )\n *\n *            my_sti       = My (the block's) original sample time index.\n *            promoted_sti = The block's promoted sample time index resulting\n *                           from a transition via a ZOH from a fast to a \n *                           slow block or a transition via a unit delay from \n *                           a slow to a fast block.\n *\n *      The perTaskSampleHits array, of dimension n*n, is accessed using \n *      perTaskSampleHits[j + i*n] where n is the total number of sample\n *      times, 0 <= i < n, and 0 <= j < n.  The C language stores arrays in \n *      row-major order, that is, row 0 followed by row 1, etc.\n * \n */\ntime_T rt_SimUpdateDiscreteEvents(int_T  rtmNumSampTimes,\n                                  void   *rtmTimingData,\n                                  int_T  *rtmSampleHitPtr,\n                                  int_T  *rtmPerTaskSampleHits)\n{\n    int   i, j;\n    int_T *sampleHit;\n#ifdef RT_MALLOC\n    TimingData *td;\n    td = (TimingData *)rtmTimingData;\n    rtmNumSampTimes = NUMST;\n#else    \n    TimingData *td;\n    UNUSED_PARAMETER(rtmTimingData);\n    td = &td_struct;\n#endif\n    sampleHit = rtmSampleHitPtr;\n    \n    /*\n     * Run this loop in reverse so that we do lower priority events first.\n     */\n    i = rtmNumSampTimes;\n    while (--i >= 0) {\n        if (td->taskTick[i] == 0) {\n            /* \n             * Got a sample hit, reset the counter, and update the clock\n             * tick counter.\n             */\n            sampleHit[i] = 1;\n            td->clockTick[i]++;\n\n            /*\n             * Record the state of all \"slower\" events \n             */\n            for (j = i + 1; j < rtmNumSampTimes; j++) {\n                rttiSetSampleHitInTask(rtmPerTaskSampleHits, rtmNumSampTimes,\n                                       j, i, sampleHit[j]);\n            }\n        } else {\n            /*\n             * no sample hit, increment the counter \n             */\n            sampleHit[i] = 0;\n        }\n\n        if (++td->taskTick[i] == td->nTaskTicks[i]) { /* update for next time */\n            td->taskTick[i] = 0;\n        }\n    }\n\n    return(td->clockTick[0]*td->period[0]);\n    \n} /* rt_SimUpdateDiscreteEvents */\n\n#endif /* !USE_RTMODEL */\n\n/* Function: rt_SimUpdateDiscreteTaskTime ======================================\n * Abstract:\n *      This function is for use with multitasking systems. \n *\n *      After a discrete task output and update has been performed, this \n *      function must be called to update the discrete task time for next \n *      time around.\n */\nvoid rt_SimUpdateDiscreteTaskTime(real_T *rtmTPtr,\n                                  void   *rtmTimingData,\n                                  int    tid)\n{\n#ifdef USE_RTMODEL\n    /* This function is a no-op in USE_RTMODEL */\n    UNUSED_PARAMETER(rtmTPtr);\n    UNUSED_PARAMETER(rtmTimingData);\n    UNUSED_PARAMETER(tid);\n    return;\n\n#else /* must be !USE_RTMODEL */\n\n#ifdef RT_MALLOC\n    TimingData *td;\n    td = (TimingData *)rtmTimingData;\n#else\n    TimingData *td;\n    UNUSED_PARAMETER(rtmTimingData);\n    td = &td_struct;\n#endif\n    rttiSetTaskTime(rtmTPtr, tid,\n                    td->clockTick[tid]*td->period[tid] + td->offset[tid]);\n\n#endif /* !USE_RTMODEL */\n}\n\n#endif /* MULTITASKING */\n\n/*\n *******************************************************************************\n * FUNCTIONS MAINTAINED FOR BACKWARDS COMPATIBILITY WITH THE SimStruct\n *******************************************************************************\n */\n#ifndef USE_RTMODEL\nconst char *rt_InitTimingEngine(SimStruct *S)\n{\n    const char_T *retVal = rt_SimInitTimingEngine(\n        ssGetNumSampleTimes(S),\n        ssGetStepSize(S),\n        ssGetSampleTimePtr(S),\n        ssGetOffsetTimePtr(S),\n        ssGetSampleHitPtr(S),\n        ssGetSampleTimeTaskIDPtr(S),\n        ssGetTStart(S),\n        &ssGetSimTimeStep(S),\n        &ssGetTimingData(S));\n    return(retVal);\n}\n\n# if !defined(MULTITASKING)\nvoid rt_UpdateDiscreteTaskSampleHits(SimStruct *S)\n{\n    rt_SimUpdateDiscreteTaskSampleHits(\n        ssGetNumSampleTimes(S),\n        ssGetTimingData(S),\n        ssGetSampleHitPtr(S),\n        ssGetTPtr(S));\n}\n\n#ifdef RT_MALLOC\ntime_T rt_GetNextSampleHit(SimStruct *S)\n{\n    return(rt_SimGetNextSampleHit(\n        ssGetTimingData(S),\n        ssGetNumSampleTimes(S)));\n}\n#else\ntime_T rt_GetNextSampleHit(void)\n{\n    return(rt_SimGetNextSampleHit());\n}\n#endif\n\n# else /* MULTITASKING */\n\ntime_T rt_UpdateDiscreteEvents(SimStruct *S)\n{\n    return(rt_SimUpdateDiscreteEvents(\n               ssGetNumSampleTimes(S),\n               ssGetTimingData(S),\n               ssGetSampleHitPtr(S),\n               ssGetPerTaskSampleHitsPtr(S)));\n}\n\nvoid rt_UpdateDiscreteTaskTime(SimStruct *S, int tid)\n{\n    rt_SimUpdateDiscreteTaskTime(ssGetTPtr(S), ssGetTimingData(S), tid);\n}\n\n#endif /* MULTITASKING */\n#endif /* USE_RTMODEL */\n\n/* EOF: rt_sim.c */\n"},{"name":"rtiostream_utils.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2025a\\toolbox\\coder\\rtiostream\\src\\utils","tag":"","groupDisplay":"Other files","code":"/* Copyright 2012-2013 The MathWorks, Inc. */\n\n#include \"rtiostream_utils.h\"\n\n/* include rtIOStream interface to use */\n#include \"rtiostream.h\" \n\n/* TARGET_CONNECTIVITY_TESTING might be defined by some MathWorks tests for\n * testing purposes only. In this case, we force SIZE_MAX to be 4 so we \n * could test the pointer arithmetic in rtIOStreamBlockingSend and\n * rtIOStreamBlockingRecv.\n */ \n#ifdef TARGET_CONNECTIVITY_TESTING\n    #define SIZE_MAX 4\n#else\n    /* define SIZE_MAX if not already defined (e.g. by a C99 compiler) */\n    #ifndef SIZE_MAX\n        #define SIZE_MAX ((size_t)-1)\n    #endif\n#endif\n\n#ifndef MemUnit_T\n   /* External Mode */\n   typedef unsigned char IOUnit_T; \n#else\n   /* SIL/PIL */\n   #ifdef HOST_WORD_ADDRESSABLE_TESTING\n      /* rtIOStream will handle data in single byte chunks \n       *\n       * uint8_T can be > 8-bits for certain portable word sizes \n       * cases (e.g. C2000) so use native type instead */\n      typedef unsigned char IOUnit_T;\n   #else\n      /* rtIOStream will handle data in MemUnit_T size chunks */\n      typedef MemUnit_T IOUnit_T;\n   #endif\n#endif\n\n/* Blocks until all requested outgoing data is sent */\nint rtIOStreamBlockingSend(const int streamID, \n                           const void * const src, \n                           uint32_T size) {\n\n    size_t transferAmount;\n    size_t sizeSent;\n    int errorCode      = RTIOSTREAM_NO_ERROR;   \n    const IOUnit_T * srcPtr = (const IOUnit_T *) src;\n    \n    /* use a variable to avoid SIZE_MAX being treated as a constant\n     * which leads to compiler warnings for \"MIN\" on platforms where\n     * SIZE_MAX > UINT32_MAX */\n    size_t sizeMax = SIZE_MAX;\n    while (size > 0) {\n        /* support full uint32 size */\n        transferAmount = (size_t) MIN(sizeMax, size);        \n        errorCode = rtIOStreamSend(streamID,\n                                   (const void *) srcPtr,\n                                   transferAmount,\n                                   &sizeSent);\n        if (errorCode == RTIOSTREAM_ERROR) {\n            return errorCode;\n        }\n        else {            \n            size -= (uint32_T) sizeSent;\n            srcPtr += sizeSent;\n        }\n    }\n    return errorCode;\n}\n\n/* Blocks until all requested incoming data is received */\nint rtIOStreamBlockingRecv(const int streamID,\n                           void * const dst,\n                           uint32_T size) {\n\n   size_t transferAmount;\n   size_t sizeRecvd;\n   int errorCode      = RTIOSTREAM_NO_ERROR;\n   IOUnit_T * dstPtr = (IOUnit_T *) dst;\n   \n   /* use a variable to avoid SIZE_MAX being treated as a constant\n    * which leads to compiler warnings for \"MIN\" on platforms where \n    * SIZE_MAX > UINT32_MAX */\n   size_t sizeMax = SIZE_MAX;\n   while (size > 0) {\n      /* support full uint32 size */\n      transferAmount = (size_t) MIN(sizeMax, size);      \n      errorCode = rtIOStreamRecv(streamID, \n                                 (void *) dstPtr, \n                                 transferAmount, \n                                 &sizeRecvd);\n      if (errorCode == RTIOSTREAM_ERROR) {\n            return errorCode;\n      }\n      else {          \n         size -= (uint32_T) sizeRecvd;\n         dstPtr += sizeRecvd;\n      }\n   }\n   return errorCode;\n}\n\n\n"},{"name":"test_normal_sim_main.c","type":"source","group":"legacy","path":"C:\\Users\\khanh\\dev\\python\\projects\\casadi_codegen\\approaches\\01\\test_normal_sim_quarc_win64","tag":"","groupDisplay":"Other files","code":"/****************************************************************************\r\n * test_normal_sim_main.c\r\n *\r\n * This file was generated automatically by QUARC. It serves as the main\r\n * entry point for the real-time code.\r\n *\r\n * Date:           Fri Sep 12 15:50:10 2025\r\n * Model version:  19.0\r\n * Matlab version: 25.1 (R2025a) 21-Nov-2024\r\n ****************************************************************************/\r\n\r\n#include <windows.h>\r\n#include <mmsystem.h>\r\n#include <direct.h>\r\n#include <signal.h>\r\n#include <float.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <errno.h>\r\n#include \"rtwtypes.h\"\r\n#include \"rtmodel.h\"\r\n#include \"rt_sim.h\"\r\n#include \"rt_nonfinite.h\"\r\n#include \"ext_work.h\"\r\n#include \"quanser_timer.h\"\r\n#include \"quanser_semaphore.h\"\r\n#include \"quanser_thread.h\"\r\n#include \"quanser_signal.h\"\r\n#include \"quanser_string.h\"\r\n#include \"quanser_messages.h\"\r\n\r\n/*=========*\r\n * Defines *\r\n *=========*/\r\nstatic const int_T exit_failure = 1;\r\nstatic const int_T exit_success = 0;\r\n\r\n#define STRINGIZE1(name)               #name\r\n#define STRINGIZE(name)                STRINGIZE1(name)          /* need to expand name    */\r\n#ifndef RT\r\n# error \"must define RT\"\r\n#endif\r\n\r\nstatic const real_T RUN_FOREVER = -1.0;\r\ntypedef RT_MODEL_test_normal_sim_T RT_MODEL;\r\n\r\n/*====================*\r\n * External functions *\r\n *====================*/\r\nEXTERN RT_MODEL * test_normal_sim(void);\r\n\r\n/* A global buffer for storing error messages (defined in quanser_common library) */\r\nEXTERN char _rt_error_message[512];\r\nEXTERN void MdlInitializeSizes(void);\r\nEXTERN void MdlInitializeSampleTimes(void);\r\nEXTERN void MdlStart(void);\r\nEXTERN void MdlOutputs(int_T tid);\r\nEXTERN void MdlUpdate(int_T tid);\r\nEXTERN void MdlTerminate(void);\r\nstatic void initialize_sizes(RT_MODEL * S)\r\n{\r\n  MdlInitializeSizes();\r\n}\r\n\r\nstatic void initialize_sample_times(RT_MODEL * S)\r\n{\r\n  MdlInitializeSampleTimes();\r\n}\r\n\r\nstatic void start(RT_MODEL * S)\r\n{\r\n  MdlStart();\r\n}\r\n\r\nstatic void outputs(RT_MODEL * S, int_T tid)\r\n{\r\n  MdlOutputs(tid);\r\n}\r\n\r\nstatic void update(RT_MODEL * S, int_T tid)\r\n{\r\n  MdlUpdate(tid);\r\n}\r\n\r\nstatic void terminate(RT_MODEL * S)\r\n{\r\n  MdlTerminate();\r\n}\r\n\r\nstatic void rt_CreateIntegrationData(RT_MODEL * S)\r\n{\r\n  rtsiSetSolverName(rtmGetRTWSolverInfo(S), \"FixedStepDiscrete\");\r\n}\r\n\r\nstatic void rt_UpdateContinuousStates(RT_MODEL * S)\r\n{\r\n  rtmSetT(S, rtsiGetSolverStopTime(rtmGetRTWSolverInfo(S)));\r\n}\r\n\r\n/*==================================*\r\n * Global data local to this module *\r\n *==================================*/\r\nstatic struct {\r\n  int_T isrOverrun;\r\n  boolean_T stopExecutionFlag;\r\n  boolean_T startedFlag;\r\n  char message[256];\r\n  char submessage[192];\r\n} GBLbuf;\r\n\r\nEXTERN void rtExtModeStart(void);\r\nEXTERN void rtExtModeQuarcCleanup(int_T numSampTimes);\r\nEXTERN boolean_T rtExtModeQuarcStartup(RTWExtModeInfo *ei,\r\n  int_T num_sample_times,\r\n  boolean_T *stopReqPtr,\r\n  int_T priority,\r\n  int32_T stack_size,\r\n  boolean_T enable_printing);\r\nEXTERN void rtExtModeQuarcParseArgs(int_T argc,\r\n  const char_T *argv[],\r\n  const char_T *default_uri);\r\nEXTERN void rtExtSetReturnStatus(const char * message);\r\nstatic void rtExtModeSingleTaskUpload(RT_MODEL * S)\r\n{\r\n  int stIdx;\r\n  rtExtModeUploadCheckTrigger(rtmGetNumSampleTimes(S));\r\n  for (stIdx=0; stIdx < 1; stIdx++) {\r\n    if (rtmIsSampleHit(S, stIdx, 0     /*unused*/\r\n                       )) {\r\n      rtExtModeUpload(stIdx, rtmGetTaskTime(S,stIdx));\r\n    }\r\n  }\r\n}\r\n\r\nEXTERN void\r\n  _do_assertion(const char * expression, const char * file_name, int line_number)\r\n{\r\n  string_format(GBLbuf.message, sizeof(GBLbuf.message),\r\n                \"Assertion in %s at line %d: (%s) is false\",\r\n                file_name, line_number, expression);\r\n  rtmSetErrorStatus(test_normal_sim_M, GBLbuf.message);\r\n}\r\n\r\n/* Function: rtOneStep ========================================================\r\n *\r\n * Abstract:\r\n *      Perform one step of the model.\r\n */\r\nstatic void rt_OneStep(RT_MODEL *S)\r\n{\r\n  real_T tnext;\r\n\r\n  /***********************************************\r\n   * Check and see if error status has been set  *\r\n   ***********************************************/\r\n  if (rtmGetErrorStatus(S) != NULL) {\r\n    GBLbuf.stopExecutionFlag = 1;\r\n    return;\r\n  }\r\n\r\n  /* enable interrupts here */\r\n  tnext = rt_SimGetNextSampleHit();\r\n  rtsiSetSolverStopTime(rtmGetRTWSolverInfo(S),tnext);\r\n  outputs(S, 0);\r\n  rtExtModeSingleTaskUpload(S);\r\n  update(S, 0);\r\n  rt_SimUpdateDiscreteTaskSampleHits(rtmGetNumSampleTimes(S),\r\n    rtmGetTimingData(S),\r\n    rtmGetSampleHitPtr(S),\r\n    rtmGetTPtr(S));\r\n  if (rtmGetSampleTime(S,0) == CONTINUOUS_SAMPLE_TIME) {\r\n    rt_UpdateContinuousStates(S);\r\n  }\r\n\r\n  rtExtModeCheckEndTrigger();\r\n}                                      /* end rtOneStep */\r\n\r\nstatic void\r\n  cleanup_sleep_mode(void * argument)\r\n{\r\n  qsched_set_sleep_mode(SLEEP_MODE_ENABLED);\r\n}\r\n\r\nstatic void\r\n  control_c_handler(int signal_number)\r\n{\r\n  /*\r\n     Set a global flag to stop model execution and\r\n     terminate cleanly. Signal the start semaphore\r\n     to make the model exit if it is waiting for\r\n     a start signal from the host.\r\n   */\r\n  GBLbuf.stopExecutionFlag = 1;\r\n  rtExtModeStart();\r\n}\r\n\r\nint\r\n  main(int argc, char * argv[])\r\n{\r\n  RT_MODEL * S;\r\n  const char * status;\r\n  int_T count;\r\n  int exit_code = exit_success;\r\n  boolean_T parseError = false;\r\n  real_T final_time = -2;              /* Let model select final time */\r\n  real_T delay_time = 0;              /* No delay before model is initialized */\r\n  int scheduling_priority;\r\n  struct qsched_param scheduling;\r\n  t_period timeout;\r\n  t_timer_notify notify;\r\n  t_error result;\r\n\r\n  /*\r\n   * Make controller threads higher priority than external mode threads:\r\n   *   ext_priority = priority of lowest priority external mode thread\r\n   *   min_priority = minimum allowable priority of lowest priority model task\r\n   *   max_priority = maximum allowable priority of lowest priority model task\r\n   */\r\n  int ext_priority = qsched_get_priority_min(QSCHED_FIFO);\r\n  int min_priority = ext_priority + 2;\r\n  int max_priority = qsched_get_priority_max(QSCHED_FIFO) - 0;\r\n  qsigset_t signal_set;\r\n  qsigaction_t action;\r\n  int_T stack_size = 0;                /* default stack size */\r\n  (void) ssPrintf(\"Entered main(argc=%d, argv=%p)\\n\", argc, argv);\r\n  for (count = 0; count < argc; count++) {\r\n    (void) ssPrintf(\"  argv[%d] = %s\\n\", count, argv[count]);\r\n  }\r\n\r\n  scheduling_priority = 2;             /* default priority */\r\n  if (scheduling_priority < min_priority) {\r\n    scheduling_priority = min_priority;\r\n  } else if (scheduling_priority > max_priority) {\r\n    scheduling_priority = max_priority;\r\n  }\r\n\r\n  /*\r\n   * Parse the standard RTW parameters.  Let all unrecognized parameters\r\n   * pass through to external mode for parsing.  NULL out all args handled\r\n   * so that the external mode parsing can ignore them.\r\n   */\r\n  for (count = 1; count < argc; ) {\r\n    const char *option = argv[count++];\r\n    char extraneous_characters[2];\r\n    if ((strcmp(option, \"-tf\") == 0) && (count != argc)) {/* final time */\r\n      const char * tf_argument = argv[count++];\r\n      double time_value;\r\n      /* use a double for the sscanf since real_T may be a float or a double depending on the platform */\r\n      argv[count-2] = NULL;\r\n      argv[count-1] = NULL;\r\n      if (strcmp(tf_argument, \"inf\") == 0) {\r\n        time_value = RUN_FOREVER;\r\n      } else {\r\n        int items = sscanf(tf_argument, \"%lf%1s\", &time_value,\r\n                           extraneous_characters);\r\n        if ((items != 1) || (time_value < 0.0) ) {\r\n          (void) fprintf(stderr,\r\n                         \"Final time must be a positive, real value or inf.\\n\");\r\n          parseError = true;\r\n          break;\r\n        }\r\n      }\r\n\r\n      final_time = (real_T) time_value;\r\n    } else if ((strcmp(option, \"-td\") == 0) && (count != argc)) {\r\n                               /* delay time (delays initialization of model) */\r\n      const char * td_argument = argv[count++];\r\n      double time_value;\r\n      /* use a double for the sscanf since real_T may be a float or a double depending on the platform */\r\n      int items;\r\n      argv[count-2] = NULL;\r\n      argv[count-1] = NULL;\r\n      items = sscanf(td_argument, \"%lf%1s\", &time_value, extraneous_characters);\r\n      if ((items != 1) || (time_value < 0.0) ) {\r\n        (void) fprintf(stderr, \"Delay time must be a positive, real value.\\n\");\r\n        parseError = true;\r\n        break;\r\n      }\r\n\r\n      delay_time = (real_T) time_value;\r\n    } else if ((strcmp(option, \"-pri\") == 0) && (count != argc)) {/* base priority */\r\n      const char * pri_argument = argv[count++];\r\n      int priority;\r\n      /* use an int for the sscanf since int_T may be the wrong size depending on the platform */\r\n      int items;\r\n      argv[count-2] = NULL;\r\n      argv[count-1] = NULL;\r\n      items = sscanf(pri_argument, \"%d%1s\", &priority, extraneous_characters);\r\n      if ((items != 1) || (priority < min_priority) ) {\r\n        (void) fprintf(stderr,\r\n                       \"Priority must be a greater than or equal to %d.\\n\",\r\n                       min_priority);\r\n        parseError = true;\r\n        break;\r\n      }\r\n\r\n      if (priority > max_priority) {\r\n        (void) fprintf(stderr, \"Priority must be less than or equal to %d.\\n\",\r\n                       max_priority);\r\n        parseError = true;\r\n        break;\r\n      }\r\n\r\n      scheduling_priority = priority;\r\n    } else if ((strcmp(option, \"-ss\") == 0) && (count != argc)) {/* stack size */\r\n      const char * stack_argument = argv[count++];\r\n      int stack;\r\n      /* use an int for the sscanf since int_T may be the wrong size depending on the platform */\r\n      int items;\r\n      argv[count-2] = NULL;\r\n      argv[count-1] = NULL;\r\n      items = sscanf(stack_argument, \"%d%1s\", &stack, extraneous_characters);\r\n      if ((items != 1) || (stack < QTHREAD_STACK_MIN) ) {\r\n        (void) fprintf(stderr,\r\n                       \"Stack size must be a integral value greater than or equal to %d.\\n\",\r\n                       QTHREAD_STACK_MIN);\r\n        parseError = true;\r\n        break;\r\n      }\r\n\r\n      stack_size = (int_T)stack;\r\n    } else if ((strcmp(option, \"-d\") == 0) && (count != argc)) {/* current directory */\r\n      const char * path_name = argv[count++];\r\n      _chdir(path_name);\r\n      argv[count-2] = NULL;\r\n      argv[count-1] = NULL;\r\n    }\r\n  }\r\n\r\n  rtExtModeQuarcParseArgs(argc, (const char **) argv,\r\n    \"shmem://test_normal_sim:1\");\r\n\r\n  /*\r\n   * Check for unprocessed (\"unhandled\") args.\r\n   */\r\n  for (count = 1; count < argc; count++) {\r\n    if (argv[count] != NULL) {\r\n      (void) fprintf(stderr, \"Unexpected command line argument: \\\"%s\\\".\\n\",\r\n                     argv[count]);\r\n      parseError = true;\r\n    }\r\n  }\r\n\r\n  if (parseError) {\r\n    (void) fprintf(stderr,\r\n                   \"\\nUsage: test_normal_sim -option1 val1 -option2 val2 -option3 ...\\n\\n\");\r\n    (void) fprintf(stderr,\r\n                   \"\\t-tf  20               - sets final time to 20 seconds\\n\");\r\n    (void) fprintf(stderr,\r\n                   \"\\t-td  5                - sets delay time to 5 seconds\\n\");\r\n    (void) fprintf(stderr,\r\n                   \"\\t-d   C:\\\\data          - sets current directory to C:\\\\data\\n\");\r\n    (void) fprintf(stderr,\r\n                   \"\\t-pri 5                - sets the minimum thread priority\\n\");\r\n    (void) fprintf(stderr,\r\n                   \"\\t-ss  65536            - sets the stack size for model threads\\n\");\r\n    (void) fprintf(stderr,\r\n                   \"\\t-w                    - wait for host to connect before starting\\n\");\r\n    (void) fprintf(stderr,\r\n                   \"\\t-uri shmem://mymodel  - set external mode URL to \\\"shmem://mymodel\\\"\\n\");\r\n    (void) fprintf(stderr, \"\\n\");\r\n    return (exit_failure);\r\n  }\r\n\r\n  /****************************\r\n   * Initialize global memory *\r\n   ****************************/\r\n  (void)memset(&GBLbuf, 0, sizeof(GBLbuf));\r\n\r\n  /* Implement a delay before starting the model */\r\n  if (delay_time > 0) {\r\n    t_timeout sleep_interval;\r\n    sleep_interval.seconds = (t_long) delay_time;\r\n    sleep_interval.nanoseconds = (t_int) (delay_time - sleep_interval.seconds) *\r\n      1000000000L;\r\n    sleep_interval.is_absolute = false;\r\n    qtimer_sleep(&sleep_interval);\r\n  }\r\n\r\n  /************************\r\n   * Initialize the model *\r\n   ************************/\r\n  S = test_normal_sim();\r\n  if (rtmGetErrorStatus(S) != NULL) {\r\n    (void) fprintf(stderr, \"Error during model registration: %s\\n\",\r\n                   rtmGetErrorStatus(S));\r\n    return (exit_failure);\r\n  }\r\n\r\n  if (final_time >= 0.0 || final_time == RUN_FOREVER) {\r\n    rtmSetTFinal(S,final_time);\r\n  } else {\r\n    rtmSetTFinal(S,INFINITY);\r\n  }\r\n\r\n  action.sa_handler = control_c_handler;\r\n  action.sa_flags = 0;\r\n  qsigemptyset(&action.sa_mask);\r\n  qsigaction(SIGINT, &action, NULL);\r\n  qsigaction(SIGBREAK, &action, NULL);\r\n  qsigemptyset(&signal_set);\r\n  qsigaddset(&signal_set, SIGINT);\r\n  qsigaddset(&signal_set, SIGBREAK);\r\n  qthread_sigmask(QSIG_UNBLOCK, &signal_set, NULL);\r\n  initialize_sizes(S);\r\n  initialize_sample_times(S);\r\n  status = rt_SimInitTimingEngine(rtmGetNumSampleTimes(S),\r\n    rtmGetStepSize(S),\r\n    rtmGetSampleTimePtr(S),\r\n    rtmGetOffsetTimePtr(S),\r\n    rtmGetSampleHitPtr(S),\r\n    rtmGetSampleTimeTaskIDPtr(S),\r\n    rtmGetTStart(S),\r\n    &rtmGetSimTimeStep(S),\r\n    &rtmGetTimingData(S));\r\n  if (status != NULL) {\r\n    (void) fprintf(stderr, \"Failed to initialize sample time engine: %s\\n\",\r\n                   status);\r\n    return (exit_failure);\r\n  }\r\n\r\n  qsched_set_sleep_mode(SLEEP_MODE_DISABLED);\r\n  qthread_cleanup_push(cleanup_sleep_mode, NULL);\r\n  rt_CreateIntegrationData(S);\r\n  fflush(stdout);\r\n  if (rtExtModeQuarcStartup(rtmGetRTWExtModeInfo(S),\r\n       rtmGetNumSampleTimes(S),\r\n       &rtmGetStopRequested(S),\r\n       ext_priority,                   /* external mode thread priority */\r\n       stack_size,\r\n       SS_HAVESTDIO)) {\r\n    (void) ssPrintf(\"\\n** starting the model **\\n\");\r\n    start(S);\r\n    if (rtmGetErrorStatus(S) == NULL) {\r\n      /*************************************************************************\r\n       * Execute the model.\r\n       *************************************************************************/\r\n      if (rtmGetTFinal(S) == RUN_FOREVER) {\r\n        (void) ssPrintf(\"\\n**May run forever. Model stop time set to infinity.**\\n\");\r\n      }\r\n\r\n      /* Perform task-specific initialization */\r\n      timeout.seconds = (t_long) (rtmGetStepSize(S));\r\n      timeout.nanoseconds = (t_int) ((rtmGetStepSize(S) - timeout.seconds) *\r\n        1000000000L);\r\n      result = qtimer_semaphore_create(&notify.notify_value.semaphore);\r\n      if (result == 0) {\r\n        t_timer timer;\r\n        scheduling.sched_priority = scheduling_priority;\r\n        qthread_setschedparam(qthread_self(), QSCHED_FIFO, &scheduling);\r\n        notify.notify_type = TIMER_NOTIFY_SEMAPHORE;\r\n        notify.flags = 0;\r\n        result = qtimer_create(&notify, &timer);\r\n        if (result == 0) {\r\n          result = qtimer_begin_resolution(timer, &timeout);\r\n          if (result == 0) {\r\n            t_period actual_timeout;\r\n            (void) ssPrintf(\"Creating main thread with priority %d and period %g...\\n\",\r\n                            scheduling_priority, rtmGetStepSize(S));\r\n            result = qtimer_get_actual_period(timer, &timeout, &actual_timeout);\r\n            if (result == 0 && (timeout.nanoseconds !=\r\n                                actual_timeout.nanoseconds || timeout.seconds !=\r\n                                actual_timeout.seconds))\r\n              (void) ssPrintf(\"*** Actual period will be %g ***\\n\",\r\n                              actual_timeout.seconds + 1e-9 *\r\n                              actual_timeout.nanoseconds);\r\n            fflush(stdout);\r\n            result = qtimer_set_time(timer, &timeout, true);\r\n            if (result == 0) {\r\n              /* Enter the periodic loop */\r\n              while (result == 0) {\r\n                if (GBLbuf.stopExecutionFlag || rtmGetStopRequested(S)) {\r\n                  break;\r\n                }\r\n\r\n                if (rtmGetTFinal(S) != RUN_FOREVER && rtmGetTFinal(S) - rtmGetT\r\n                    (S) <= rtmGetT(S)*DBL_EPSILON) {\r\n                  break;\r\n                }\r\n\r\n                if (qtimer_get_overrun(timer) > 0) {\r\n                  (void) fprintf(stderr,\r\n                                 \"Sampling rate is too fast for base rate\\n\");\r\n                  fflush(stderr);\r\n                }\r\n\r\n                rt_OneStep(S);\r\n                result = qtimer_semaphore_wait(notify.notify_value.semaphore);\r\n              }\r\n\r\n              /* disarm the timer */\r\n              qtimer_cancel(timer);\r\n              if (rtmGetStopRequested(S) == false && rtmGetErrorStatus(S) ==\r\n                  NULL) {\r\n                /* Execute model last time step if final time expired */\r\n                rt_OneStep(S);\r\n              }\r\n\r\n              (void) ssPrintf(\"Main thread exited\\n\");\r\n            } else {\r\n              msg_get_error_messageA(NULL, result, GBLbuf.submessage, sizeof\r\n                (GBLbuf.submessage));\r\n              string_format(GBLbuf.message, sizeof(GBLbuf.message),\r\n                            \"Unable to set base rate. %s\", GBLbuf.submessage);\r\n              rtmSetErrorStatus(S, GBLbuf.message);\r\n            }\r\n\r\n            qtimer_end_resolution(timer);\r\n          } else {\r\n            msg_get_error_messageA(NULL, result, GBLbuf.submessage, sizeof\r\n              (GBLbuf.submessage));\r\n            string_format(GBLbuf.message, sizeof(GBLbuf.message),\r\n                          \"Sampling period of %lg is too fast for the system clock. %s\",\r\n                          rtmGetStepSize(S), GBLbuf.submessage);\r\n            rtmSetErrorStatus(S, GBLbuf.message);\r\n          }\r\n\r\n          qtimer_delete(timer);\r\n        } else {\r\n          msg_get_error_messageA(NULL, result, GBLbuf.submessage, sizeof\r\n            (GBLbuf.submessage));\r\n          string_format(GBLbuf.message, sizeof(GBLbuf.message),\r\n                        \"Unable to create timer for base rate. %s\",\r\n                        GBLbuf.submessage);\r\n          rtmSetErrorStatus(S, GBLbuf.message);\r\n        }\r\n\r\n        qtimer_semaphore_delete(notify.notify_value.semaphore);\r\n      } else {\r\n        msg_get_error_messageA(NULL, result, GBLbuf.submessage, sizeof\r\n          (GBLbuf.submessage));\r\n        string_format(GBLbuf.message, sizeof(GBLbuf.message),\r\n                      \"Unable to create timer semaphore for base rate. %s\",\r\n                      GBLbuf.submessage);\r\n        rtmSetErrorStatus(S, GBLbuf.message);\r\n      }\r\n\r\n      GBLbuf.stopExecutionFlag = 1;\r\n\r\n      /* Perform task-specific cleanup */\r\n    }\r\n  } else {\r\n    rtmSetErrorStatus(S, \"Unable to initialize external mode.\");\r\n  }\r\n\r\n  rtExtSetReturnStatus(rtmGetErrorStatus(S));\r\n  rtExtModeQuarcCleanup(rtmGetNumSampleTimes(S));\r\n\r\n  /********************\r\n   * Cleanup and exit *\r\n   ********************/\r\n  if (rtmGetErrorStatus(S) != NULL) {\r\n    (void) fprintf(stderr, \"%s\\n\", rtmGetErrorStatus(S));\r\n    exit_code = exit_failure;\r\n  }\r\n\r\n  (void) ssPrintf(\"Invoking model termination function...\\n\");\r\n  terminate(S);\r\n  qthread_cleanup_pop(1);\r\n  (void) ssPrintf(\"Exiting real-time code\\n\");\r\n  return (exit_code);\r\n}\r\n"},{"name":"updown.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2025a\\rtw\\c\\src\\ext_mode\\common","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1994-2020 The MathWorks, Inc.\n */\n#include <stdlib.h>\n#include <string.h>\n\n/*Real Time Workshop headers*/\n#include \"rtwtypes.h\"\n#include \"rtw_extmode.h\"\n#include \"sysran_types.h\"\n\n/* \n * String is dynamic in the following cases\n * - Rapid Accelerator mode\n */\n#ifdef IS_RAPID_ACCEL\n#define MW_DYNAMIC_STRING_SUPPORT\n#endif\n\n#ifdef MW_DYNAMIC_STRING_SUPPORT\n#include \"mwstringutil.h\"\n/* \"assert\" is defined in updown_util.h below */ \n#undef assert\n#endif\n\n/* \n * Note: Local headers should be after external headers\n *       Otherwise, some macros may be re-defined\n *       One example is \"assert\" in updown_util.h\n *       mwstringutil.h inderectly re-define it\n */\n#include \"ext_types.h\"\n#include \"ext_share.h\"\n#include \"ext_svr.h\"\n#include \"ext_work.h\"\n#include \"updown_util.h\"\n#include \"dt_info.h\"\n\n/* DUMP_PKT is defined to be (0) below - why? See g2176068. */\n#if defined(VERBOSE) || (defined(DUMP_PKT) && DUMP_PKT)\n#include <stdio.h>\n#endif\n\n/* \n * Depending on the target's native word size and pointer size, interrupts\n * might need to be disabled around critical regions when accessing the \n * the external mode circular buffer. If, for example, reading a pointer \n * is not guaranteed to be an atomic operation on your target, then you  \n * need to define the preprocessor defines below to prevent interrupts  \n * around the critical regions.\n * \n * Here is a description of each of these preprocessor defines:\n * EXTMODE_PROTECT_CRITICAL_REGIONS: this should be defined if interrupts \n *      should be disabled around critical regions\n * EXTMODE_INTERRUPT_INC_HDR: this defines the include header file \n *      containing the declarations for the enabled/disable interrupts \n *      functions\n * EXTMODE_ENABLE_INTERRUPTS:  this defines the enable interrupts function\n * EXTMODE_DISABLE_INTERRUPTS: this defines the disable interrupts function\n *\n * If you define EXTMODE_PROTECT_CRITICAL_REGIONS, you need to define the \n * other above preprocessor defines, otherwise they are not required.\n */\n#ifdef EXTMODE_PROTECT_CRITICAL_REGIONS\n    #if !defined (EXTMODE_INTERRUPT_INC_HDR) || \\\n        !defined (EXTMODE_ENABLE_INTERRUPTS) || \\\n        !defined (EXTMODE_DISABLE_INTERRUPTS)\n        #error EXTMODE_INTERRUPT_INC_HDR, EXTMODE_ENABLE_INTERRUPTS and \\\n               EXTMODE_DISABLE_INTERRUPTS should be defined\n    #endif\n    /* \n     * include header file containing declarations for interrupt \n     * enable/disable functions \n     */    \n    #include EXTMODE_INTERRUPT_INC_HDR\n#endif\n\n/**********************\n * External Variables *\n **********************/\n#ifdef VXWORKS\n# include <sockLib.h>\n# include <inetLib.h>\n# include <selectLib.h>\nextern SEM_ID uploadSem;\n\n#endif\n\n/* Logical definitions */\n#if (!defined(__cplusplus))\n#  ifndef false\n#   define false                       (0U)\n#  endif\n#  ifndef true\n#   define true                        (1U)\n#  endif\n#endif\n\nboolean_T host_upstatus_is_uploading = false;\n\n/******************************************************************************\n * Parameter Download                                                         *\n ******************************************************************************/\n\n#ifdef VERBOSE\n/* Function: DType2Real_T ======================================================\n * Convert a built-in data type to a real_T value.  Return the real_T value\n * as well as a string (by reference) corresponding to the original data type.\n * If the data type is not recognized as a Simulink built-in data type, then\n * NULL is returned for the dTypeName and 0 is returned for the dTypeValue.\n */\nPRIVATE double DType2Double(\n    const char              *vPtr,\n    const int               dTypeIdx,\n    const DataTypeTransInfo *dtInfo,\n    const char              **dTypeName)\n{\n    real_T     outVal;\n    char * const *dTypeNames = (char * const *)dtGetDataTypeNames(dtInfo);\n    const char *thisName     = dTypeNames[dTypeIdx];\n\n    *dTypeName = thisName;\n\n    if (strcmp(thisName, \"real_T\") == 0) {\n        outVal = (real_T) (((const real_T*)vPtr)[0]);\n    } else if (strcmp(thisName, \"real32_T\") == 0) {\n        outVal = (real_T) (((const real32_T*)vPtr)[0]);\n    } else if (strcmp(thisName, \"int8_T\") == 0) {\n        outVal = (real_T) (((const int8_T*)vPtr)[0]);\n    } else if (strcmp(thisName, \"uint8_T\") == 0) {\n        outVal = (real_T) (((const uint8_T*)vPtr)[0]);\n    } else if (strcmp(thisName, \"int16_T\") == 0) {\n        outVal = (real_T) (((const int16_T*)vPtr)[0]);\n    } else if (strcmp(thisName, \"uint16_T\") == 0) {\n        outVal = (real_T) (((const uint16_T*)vPtr)[0]);\n    } else if (strcmp(thisName, \"int32_T\") == 0) {\n        outVal = (real_T) (((const int32_T*)vPtr)[0]);\n    } else if (strcmp(thisName, \"uint32_T\") == 0) {\n        outVal = (real_T) (((const uint32_T*)vPtr)[0]);\n    } else if (strcmp(thisName, \"boolean_T\") == 0) {\n        outVal = (real_T) (((const boolean_T*)vPtr)[0]);\n    } else {\n        outVal    = 0;\n        dTypeName = NULL;\n    }\n    return(outVal);\n} /* end DType2Double */\n#endif\n\n\n/* Function: SetParam ==========================================================\n * Install new parameters.\n *\n * NOTE: pbuf looks like:\n *  [NPARAMS\n *   B S W DI DATA   % pVal 0\n *   B S W DI DATA   % pVal 1\n *   B S W DI DATA   % pVal N\n *  ]\n *\n *  No assumptions about the alignment of pbuf may be made.\n *\n *  where,\n *      B   : Data type transition index.  Note that on the target the data\n *            type transition index provides both the base address (B)\n *              of the transition as well as whether or not\n *              that section of the array contains complex elements.\n *      S   : starting offset of the data from the DT_TRANS_IDX\n *      W   : number of elements for this param\n *      DI  : index into rtw data type table (inUse idx)\n *      DATA: the param values (in target format).\n *\n *  and,\n *      All values, excluding DATA, are int32_T.\n */\n#ifndef EXTMODE_DISABLEPARAMETERTUNING\nPUBLIC void SetParam(RTWExtModeInfo  *ei, const char *pbuf)\n{\n    int        i;\n    int32_T    nParams;\n    const char *bufPtr    = pbuf;\n    const int  B          = 0; /* index into dtype tran table (base address)  */\n    const int  SI         = 1; /* starting index - wrt to base address        */\n    const int  W          = 2; /* width of section (number of elements)       */\n    const int  DI         = 3; /* index into data type tables                 */\n    const int  tmpBufSize = sizeof(int32_T) * 4;\n    int32_T    tmpBuf[4];\n\n    const DataTypeTransInfo *dtInfo = (const DataTypeTransInfo *) rteiGetModelMappingInfo(ei);\n    const DataTypeTransitionTable *dtTable = dtGetParamDataTypeTrans(dtInfo);\n    const uint_T *dtSizes = dtGetDataTypeSizes(dtInfo);\n    \n#ifdef MW_DYNAMIC_STRING_SUPPORT\n    const char_T* *dtNames = dtGetDataTypeNames(dtInfo);\n#endif\n\n    /* unpack NPARAMS */\n    (void)memcpy(&nParams, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n    \n#ifdef VERBOSE\n    printf(\"\\nUpdating %d parameters....\\n\", nParams);\n#endif\n\n    /*\n     * Unpack the data and install the new parameters.\n     */\n    for (i=0; i<nParams; i++) {\n        int_T   elSize;\n        int_T   nBytes;\n        char_T  *start;\n        char_T  *tranAddress;\n        int_T   tranIsComplex;\n\n        /* unpack B SI W DI */\n        (void)memcpy(tmpBuf, bufPtr, tmpBufSize);\n        bufPtr += tmpBufSize;\n\n        /* \n         * Find starting address and size (nBytes) for this parameters \n         * section of memory.\n         */\n        tranAddress   = dtTransGetAddress(dtTable, tmpBuf[B]);\n        tranIsComplex = dtTransGetComplexFlag(dtTable, tmpBuf[B]);\n\n        elSize = dtSizes[tmpBuf[DI]] * (tranIsComplex ? 2 : 1);\n        nBytes = tmpBuf[W] * elSize;\n\n        /*\n         * String in rapid accelerator is:\n         *   - transferred as character stream, element size is sizeof(char_T)\n         *   - stored/operated as void *, element size is sizeof(void*)\n         * We need to use the later one to calculate \"start\" address\n         */\n#ifdef MW_DYNAMIC_STRING_SUPPORT\n        if (strcmp(dtNames[tmpBuf[DI]], \"string\") == 0) {\n            elSize = sizeof(void*);\n        }\n#endif\n        start = tranAddress + (tmpBuf[SI] * elSize);\n\n        /* Install the params. */\n#ifdef MW_DYNAMIC_STRING_SUPPORT\n        if (strcmp(dtNames[tmpBuf[DI]], \"string\") == 0) {\n            suInitializeString(start, bufPtr);\n            bufPtr += nBytes;\n        } else\n#endif\n        {\n            (void)memcpy(start, bufPtr, nBytes);\n            bufPtr += nBytes;\n        }\n\n#ifdef VERBOSE\n        /*\n         * It is safe to assume that once the params are installed into\n         * the param vector that they are properly aligned.  So we\n         * do our verbosity print-out here.\n         */\n        {\n            double     val;\n            const char *dTypeName;\n            const char *vPtr = (const char *)start;\n\n            val = DType2Double(start, tmpBuf[DI], dtInfo, &dTypeName);\n            printf(\"\\n\\tParam| \"\n                   \"DT_Trans: %d, index: %d, nEls: %d, data type: [%s, %d]\\n\",\n                   tmpBuf[B], tmpBuf[SI], tmpBuf[W],\n                   (dTypeName != NULL) ? dTypeName : \"\",tmpBuf[DI]);\n\n            if (!tranIsComplex) {\n                int j;\n                for (j=0; j<tmpBuf[W]; j++) {\n                    val = DType2Double(vPtr, tmpBuf[DI], dtInfo, &dTypeName);\n                    printf(\"\\t\\t%f\\n\", val);\n                    vPtr += dtSizes[tmpBuf[DI]];\n                }\n            } else {\n                int j;\n                for (j=0; j<tmpBuf[W]; j++) {\n                    val = DType2Double(vPtr, tmpBuf[DI], dtInfo, &dTypeName);\n                    printf(\"\\t\\t%f + \", val);\n                    vPtr += dtSizes[tmpBuf[DI]];\n\n                    val = DType2Double(vPtr, tmpBuf[DI], dtInfo, &dTypeName);\n                    printf(\"\\t\\t%fi\\n\", val);\n                    vPtr += dtSizes[tmpBuf[DI]];\n                }\n            }\n        }\n#endif\n    }\n} /* end SetParam */\n#endif /* ifndef EXTMODE_DISABLEPARAMETERTUNING */\n\n\n/******************************************************************************\n * Parameter Upload                                                           *\n ******************************************************************************/\n#include \"upsup_public.h\"\n#define DUMP_PKT (0)\n\n\n/*=============================================================================\n * Circular buffer stuff.\n *============================================================================*/\ntypedef struct BufMemList_tag {\n\n#if ASSERTS_ON\n    int_T  maxBufs;     /* for debugging                       */\n#endif\n    int_T  nActiveBufs; /* num non-empty bufs                  */\n    int_T  *tids;       /* tid associated with each active buf */\n    BufMem *bufs;       /* sections of each buffer to upload   */\n} BufMemList;\n\n\ntypedef struct CircularBuf_tag {\n    volatile int_T    empty;\n\n    int_T    bufSize;\n    char_T   *buf;\n    \n    char_T* volatile head;\n    char_T* volatile tail;\n\n    char_T   *newTail;\n\n    struct {\n        int_T count;\n    } preTrig;\n} CircularBuf;\n\n\n/*==============================================================================\n * Trigger stuff.\n *============================================================================*/\ntypedef enum {\n    TRIGGER_UNARMED,\n    TRIGGER_HOLDING_OFF,\n    TRIGGER_ARMED,\n    TRIGGER_DELAYED,\n    TRIGGER_FIRED,\n    TRIGGER_TERMINATING\n} TriggerState;\n\n\n/*==============================================================================\n * General stuff.\n *============================================================================*/\n\n/*\n * An UploadSection defines a contiguous section of the blockio or dwork\n * structure.  Each section consists of elements of the same data type and same\n * complexity.\n * 'start' should be a const pointer\n */\ntypedef struct UploadSection_tag {\n    void   *start;\n    int_T  nBytes;\n#ifdef MW_DYNAMIC_STRING_SUPPORT\n    boolean_T isString;\n#endif\n} UploadSection;\n\n/*\n * An UploadMap is an array of UploadSections.  Typically a map consists of all\n * of the sections of the blockio or dwork structure that are relevant to a\n * given task.\n */\ntypedef struct UploadMap_tag {\n    int32_T    nSections;\n    UploadSection *sections;\n\n    int_T nBytes;  /* total number of bytes in this map */\n} UploadMap;\n\n\n/*\n * Each system contains a table of UploadMap's (one for each tid).  If no data\n * uploading is being done for a given tid, the uploadMap pointer is NULL.\n * The enableState field indicates whether the system in question is active.\n *\n * For a model with 5 total tids, the table looks like:\n *\n *               tid 0    tid 1    tid 2   tid 3   tid 4\n * uploadMap   -------------------------------------------\n *             |  ptr  |  NULL  |  NULL  |  ptr  |  NULL |\n *             ----|-------------------------|------------\n *                 |                         |\n *                 v                         v\n *              UploadMap                 UploadMap\n *              for tid 0                 for tid 3\n */\ntypedef struct SysUploadTable_tag {\n    int8_T    *enableState;\n    UploadMap **uploadMap;\n} SysUploadTable;\n\n\ntypedef struct TriggerInfo_tag {\n    TriggerState            state;\n    int_T                   tid;\n    int32_T                 duration;\n    int32_T                 holdOff;\n    int32_T                 delay;\n    int_T                   lookForRising;\n    int_T                   lookForFalling;\n    real_T                  level;\n    int_T                   count;\n    int_T                   overFlow;\n\n    UploadMap               trigSignals;\n    real_T                  *oldTrigSigVals;\n    int_T                   haveOldTrigSigVal;\n\n    struct {\n        int32_T    duration;\n        int32_T    count;\n\n        int_T      checkUnderFlow; /* ??? */\n    } preTrig;\n} TriggerInfo;\n\n\n/*\n * The BdUploadInfo contains all information regarding data logging.\n */\nstruct BdUploadInfo_tag {\n    int32_T        upInfoIdx;  /* index of upInfo in the array                 */\n    int32_T        nSys;       /* # of sys's for which data logging is active  */\n    SysUploadTable *sysTables; /* array of SysUploadTables                     */\n    CircularBuf    *circBufs;  /* circular buffers to store upload data        */\n    BufMemList     bufMemList; /* list of buffer memory holding data to upload */\n\n    TriggerInfo  trigInfo;\n};\n\n\n/*==============================================================================\n * Global upload data.\n */\n\n/*\n * Definitions that must match Simulink definitions.\n */\n\n#define UPLOAD_RISING_TRIGGER                   ((int32_T)  0)\n#define UPLOAD_FALLING_TRIGGER                  ((int32_T)  1)\n#define UPLOAD_EITHER_RISING_OR_FALLING_TRIGGER ((int32_T)  2)\n\n/*\n * Definitions.\n */\n#define TRIGMODE_ONESHOT (-1)\n\n#define NUM_UPINFOS   2\nstatic  BdUploadInfo  uploadInfoArray[NUM_UPINFOS];\n\n\n/* Function ====================================================================\n * Dump the signal selection packet (EXT_SELECT_SIGNALS).  The packet looks\n * like:\n *\n * upInfoIdx - Index of the UploadInfo. \n *\n * nSys - the number of systems that contain upload blocks (length of the\n *        (BdUploadInfo list)\n *\n * enableIdx - the index into the \"mode vector\" that tells whether or not\n *             a given system is active\n *\n * nTids - the number of tids in a system that contain upload blocks (number\n *         of non NULL entries in a SysUploadTable)\n *\n * nSections - the number of contiguous blockio or dwork sections that\n *             correspond to all blocks within a tid (number of sections in\n *             an UploadMap)\n *\n * B  - Index into data type transition table       - gives base address\n * S  - the starting index of a blockio section     - with respect to B\n * W  - the number of elements in a blockio section\n * DI - data type index - index into the rtw data type table\n *\n * target buf size - size of the upload buffer (to be allocated by target) for\n *                   a given tid\n *\n * Here's the packet format:\n *\n * [upInfoIdx\n *  \n *  nSys\n *\n *  enableIdx                           ---\n *  nTids                                 |\n *  tid nSections B S W DI B S W DI ...   | system\n *  tid nSections B S W DI B S W DI ...   |\n *                                      ---\n *  enableIdx                           ---\n *  nTids                                 |\n *  tid nSections B S W DI B S W DI ...   | system\n *  tid nSections B S W DI B S W DI ...   |\n *                                      ---\n *  target buf size for tid 0\n *  target buf size for tid 1\n *            .\n *            .\n *  target buf size for tid n\n * ]\n *\n * All elements are int32_T.\n */\n#if DUMP_PKT\nPRIVATE void DumpSelectSignalPkt(const char *pkt, int nRootTids)\n{\n    int32_T    i,j,k;\n    int32_T    upInfoIdx;\n    int32_T    nSys;\n    const char *bufPtr = pkt;\n\n    printf(\"Signal Select Pkt-----------\\n\");\n\n    /* upInfoIdx */\n    (void)memcpy(&upInfoIdx, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    printf(\"\\nupInfoIdx: %d\\n\",upInfoIdx);\n\n    /* nSys */\n    (void)memcpy(&nSys, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    printf(\"\\nnSys: %d\\n\",nSys);\n\n    for (i=0; i<nSys; i++) {\n        int32_T enableIdx, nTids;\n        \n        /* [enableIdx, nTids] */\n        (void)memcpy(&enableIdx, bufPtr, sizeof(int32_T));\n        bufPtr += sizeof(int32_T);\n\n        (void)memcpy(&nTids, bufPtr, sizeof(int32_T));\n        bufPtr += sizeof(int32_T);\n\n        printf(\"[enableIdx, nTids]: %d %d\\n\", enableIdx, nTids);\n\n        for (j=0; j<nTids; j++) {\n            int32_T tid;\n            int32_T nSections;\n\n            /* [tid nSections] */\n            (void)memcpy(&tid, bufPtr, sizeof(int32_T));\n            bufPtr += sizeof(int32_T);\n\n            (void)memcpy(&nSections, bufPtr, sizeof(int32_T));\n            bufPtr += sizeof(int32_T);\n\n            printf(\"[tid nSects]: %d %d\\n\", tid, nSections);\n\n            for (k=0; k<nSections; k++) {\n                const int B  = 0;\n                const int S  = 1;\n                const int W  = 2;\n                const int DI = 3;\n                int32_T   tmpBuf[4];\n\n                /* [B S W DI] */\n                (void)memcpy(&tmpBuf, bufPtr, sizeof(int32_T)*4);\n                bufPtr += (sizeof(int32_T) * 4);\n                \n                printf(\"%d %d %d %d\\n\",\n                    tmpBuf[B], tmpBuf[S], tmpBuf[W], tmpBuf[DI]);\n            }\n            printf(\"\\n\");\n        }\n        printf(\"\\n\");\n    }\n\n    /*\n     * Now the buffer sizes.\n     */\n    printf(\"bufSizes: \");\n    for (i=0; i<nRootTids; i++) {\n        int32_T bufSize;\n\n        printf(\"\\nbufSize[%d] of %d: \",i, nRootTids);\n\n        (void)memcpy(&bufSize, bufPtr, sizeof(int32_T));\n        bufPtr += sizeof(int32_T);\n\n        printf(\"%d\", bufSize);\n    }\n    printf(\"\\nEnd of select sigs pkt----\\n\");\n} /* end DumpSelectSignalPkt */\n#else\n#define DumpSelectSignalPkt(buf, nRootTids) /* do nothing */\n#endif\n\n\n/* Function ====================================================================\n * Dump the trigger selection packet (EXT_SELECT_TRIGGER).  The packet looks\n * like:\n *\n * upInfoIdx - Index of the UploadInfo. \n *\n * tid       - tid of the trigger signal\n *\n * duration  - The number of base rate steps for which the data logging event\n *             occurs.\n *\n * holdOff   - (-1), signifies that this trigger event is a one_shot, else we \n *             are in normal mode.  For normal mode the value indicates\n *             the number of base rate steps to wait between the end a data\n *             logging event and the re-arming of the trigger for the next data\n *             logging event.  The end of a data logging event is defined as\n *             when the last bit of data has been sent to the host (i.e.,\n *             immediately after the termination flag has been sent).\n *\n * delay     - The number of base rate steps to wait after the trigger event\n *             occurs and the before starting the data collection.  This can\n *             be either positive or negative (pre-trigger).  This field is\n *             ignored if the trigger source is manual.\n *\n * nsections - The sections of the blockio array to monitor for a trigger event.\n *             If the trigger event is not based on a signal, this is set to\n *             0 (e.g., the signal source is manual).\n *\n * sections  - \"B, S, W, DI\" description of a signal (see Signal Selection Pkt).\n *             These are the elements of the blockio vector that are monitored\n *             for trigger events when the trigger is based on a signal.  It is\n *             ignored if the trigger event is not based on a signal\n *             (nsections == 0).\n *\n * direction - If the triggering source is a signal, then this specifies the\n *             direction of the crossing (rising, falling or either).  If we\n *             are not triggering on a signal (nsections == 0), then this field\n *             is ignored.\n *\n * level     - If the triggering source is a signal, then this field specifies\n *             the level (value) of the crossing (0 by default).  If we are not\n *             triggering on a signal (nsections == 0), then this field is\n *             ignored.\n *\n * The packet looks like:\n * [tid duration holdOff delay nsections B S W DI B S W DI ... direction level]\n *\n * All fields are int32_T except for level, which is an SL_DOUBLE (real_T\n * on target).\n */\n#if DUMP_PKT\nPRIVATE void DumpSelectTriggerPkt(const char *pkt)\n{\n    int32_T    i;\n    int32_T    upInfoIdx, tid, duration, holdOff, delay, nSections;\n    int32_T    direction;\n    real_T     level;\n    const char *bufPtr = pkt;\n\n    printf(\"Trigger Select Pkt-----------\\n\");\n\n    /* upInfoIdx */\n    (void)memcpy(&upInfoIdx, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    printf(\"\\nupInfoIdx: %d\\n\",upInfoIdx);\n    \n    /* tid */\n    (void)memcpy(&tid, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    printf(\"\\ntid: %d\\n\",tid);\n    \n    /* duration */\n    (void)memcpy(&duration, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    printf(\"\\nduration: %d\\n\",duration);\n\n    /* holdOff */\n    (void)memcpy(&holdOff, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    printf(\"\\nholdOff: %d\\n\",holdOff);\n\n    /* delay */\n    (void)memcpy(&delay, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    printf(\"\\ndelay: %d\\n\",delay);\n\n    /* nsections */\n    (void)memcpy(&nSections, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    printf(\"nSects: %d\\n\", nSections);\n\n    /* each section */\n    for (i=0; i<nSections; i++) {\n        const int B  = 0;\n        const int S  = 1;\n        const int W  = 2;\n        const int DI = 3;\n        int32_T   tmpBuf[4];\n\n        (void)memcpy(&tmpBuf, bufPtr, sizeof(int32_T)*4);\n        bufPtr += (sizeof(int32_T) * 4);\n        \n        printf(\"%d %d %d %d\\n\", tmpBuf[B], tmpBuf[S], tmpBuf[W], tmpBuf[DI]);\n    }\n    printf(\"\\n\");\n\n    /* direction */\n    (void)memcpy(&direction, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    printf(\"direction: %d\\n\",direction);\n\n    /* level */\n    (void)memcpy(&level, bufPtr, sizeof(real_T));\n    bufPtr += sizeof(real_T);\n\n    printf(\"level: %f\\n\",level);\n} /* end DumpSelectTriggerPkt */\n#else\n#define DumpSelectTriggerPkt(buf) /* do nothing */\n#endif\n\n\n/* Function ====================================================================\n * Initialize a UploadSection.\n */\n#ifndef EXTMODE_DISABLESIGNALMONITORING\nPRIVATE void InitUploadSection(\n    RTWExtModeInfo *ei,\n    const int32_T  *buf,\n    UploadSection  *section)   /* out */\n{\n    int_T                         elSize;\n    int_T                         offset;\n    int_T                         nBytes;\n    char_T                        *tranAddress;\n    int_T                         tranIsComplex;\n    \n    const DataTypeTransInfo       *dtInfo  = (const DataTypeTransInfo *) rteiGetModelMappingInfo(ei);\n    const DataTypeTransitionTable *dtTable = dtGetBIODataTypeTrans(dtInfo);\n    const uint_T *dtSizes = dtGetDataTypeSizes(dtInfo);\n\n    const int BI = 0;  /* index into dtype tran table (base address)  */\n    const int SI = 1;  /* starting index - wrt to base address        */\n    const int W  = 2;  /* width of section (number of elements)       */\n    const int DI = 3;  /* index into data type tables                 */\n\n#ifdef MW_DYNAMIC_STRING_SUPPORT\n    const char_T* *dtNames;\n#endif\n    \n    tranAddress   = dtTransGetAddress(dtTable, buf[BI]);\n    tranIsComplex = dtTransGetComplexFlag(dtTable, buf[BI]);\n\n    elSize = dtSizes[buf[DI]] * (tranIsComplex ? 2 : 1);\n    nBytes = buf[W] * elSize;\n    offset = buf[SI] * elSize;\n\n    section->start  = tranAddress + offset;\n    section->nBytes = nBytes;\n    \n#ifdef MW_DYNAMIC_STRING_SUPPORT\n    dtNames = dtGetDataTypeNames(dtInfo);\n    section->isString = strcmp(dtNames[buf[DI]], \"string\") == 0;\n#endif\n    \n} /* end InitUploadSection */\n\n\n/* Function ====================================================================\n * Initialize a SysUploadTable.  The callerBufPtr points to the current place in\n * the EXT_SELECT_SIGNALS pkt which should be the enableIdx field.  This\n * function moves the callerBufPtr to the next unread field of the packet.\n */\nPRIVATE boolean_T InitSysUploadTable(\n    RTWExtModeInfo *ei,\n    int_T          numSampTimes,\n    SysUploadTable *sysTable,\n    const char     **callerBufPtr) /* in/out */\n{\n    int_T        i;\n    int32_T      nTids;\n    const char_T *bufPtr = *callerBufPtr;\n    boolean_T    error   = EXT_NO_ERROR;\n\n    /*\n     * Set pointer to enable mode.\n     */\n    {\n        int32_T sysIdx;\n\n        /* read sysIdx */\n        (void)memcpy(&sysIdx, bufPtr, sizeof(int32_T));\n        bufPtr += sizeof(int32_T);\n\n        sysTable->enableState = rteiGetAddrOfSubSystemActiveVector(ei,sysIdx);\n    }\n\n    /*\n     * Allocate/initialize each tid's uploadMap.\n     */\n\n    /* ...read [nTids] */\n    (void)memcpy(&nTids, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    /* Allocate the array of pointers to UploadMaps. */\n    sysTable->uploadMap = (UploadMap **)calloc(numSampTimes, sizeof(UploadMap *));\n    if (sysTable->uploadMap == NULL) {\n        error = EXT_ERROR; goto EXIT_POINT;       \n    }\n\n    for (i=0; i<nTids; i++) {\n        int32_T   tid;\n        int32_T   section;\n        UploadMap *map;\n        \n        /* read tid */\n        (void)memcpy(&tid, bufPtr, sizeof(int32_T));\n        bufPtr += sizeof(int32_T);\n        \n        /* allocate UploadMap */\n        assert(sysTable->uploadMap[tid] == NULL);\n        sysTable->uploadMap[tid] = (UploadMap *)calloc(1, sizeof(UploadMap));\n        if (sysTable->uploadMap[tid] == NULL) {\n            error = EXT_ERROR; goto EXIT_POINT;       \n        }\n        map = sysTable->uploadMap[tid];\n        \n        /* read nSections */\n        (void)memcpy(&map->nSections, bufPtr, sizeof(int32_T));\n        bufPtr += sizeof(int32_T);\n\n        /* Allocate the blockio sections. */\n        assert(map->sections == NULL);\n        if (map->nSections > 0) {\n           map->sections = (UploadSection *)calloc(map->nSections,sizeof(UploadSection));\n           if (map->sections == NULL) {\n               error = EXT_ERROR; goto EXIT_POINT;\n           }\n        }\n\n        /*\n         * Init the UploadSections.\n         */\n        for (section=0; section<map->nSections; section++) {\n            int32_T    tmpBuf[4];\n            UploadSection *uploadSection = &map->sections[section];\n\n            /* read [B S W DI] */\n            (void)memcpy(&tmpBuf, bufPtr, sizeof(int32_T)*4);\n            bufPtr += (sizeof(int32_T) * 4);\n\n            InitUploadSection(ei, tmpBuf, uploadSection);\n\n            /* keep track of total number of bytes in this map */\n            map->nBytes += uploadSection->nBytes;\n        }\n    }\n    \nEXIT_POINT:\n    *callerBufPtr = bufPtr;\n    return(error);\n} /* end InitSysUploadTable */\n\n/* Function ====================================================================\n * Initialize circular buffer fields and allocate required memory.\n */\nPRIVATE boolean_T UploadBufInit(CircularBuf *circBuf, int32_T size)\n{\n    boolean_T error = NO_ERR;\n\n    assert(circBuf->buf == NULL);\n\n    /*\n     * Size will be negative to indicate an error if host determines too much\n     * memory is needed (i.e. the size will not fit in an int32).\n     */\n    if (size < 0) {\n        error = EXT_ERROR; goto EXIT_POINT;\n    }\n\n    circBuf->empty = true;\n    if (size > 0) {\n        assert(circBuf->buf == NULL);\n        circBuf->buf = (char_T *)malloc(size);\n        if (circBuf->buf == NULL) {\n            error = EXT_ERROR; goto EXIT_POINT;\n        }\n    } else {\n        circBuf->buf = NULL;\n    }\n    circBuf->bufSize = size;\n    \n    circBuf->head = circBuf->buf;\n    circBuf->tail = circBuf->buf;\n\n    circBuf->newTail = NULL;\n\nEXIT_POINT:\n    return(error);\n} /* end UploadBufInit */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n\n/* Function ====================================================================\n * Free all dynamically allocated fields of the trigInfo structure.\n */\nPRIVATE void UploadDestroyTrigger(int32_T upInfoIdx)\n{\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n    TriggerInfo *trigInfo    = &uploadInfo->trigInfo;\n    UploadMap   *map         = &trigInfo->trigSignals;\n\n    if (map->sections != NULL) {\n        free(map->sections);\n        map->sections = NULL;\n    }\n\n    if (trigInfo->oldTrigSigVals != NULL) {\n        free(trigInfo->oldTrigSigVals);\n        trigInfo->oldTrigSigVals = NULL;\n    }\n\n    /*\n     * Reset trigger info.\n     */\n    trigInfo->state          = TRIGGER_UNARMED;\n    trigInfo->duration       = 0;\n    trigInfo->holdOff        = 0;\n    trigInfo->delay          = 0;\n    trigInfo->lookForRising  = true;\n    trigInfo->lookForFalling = false;\n    trigInfo->level          = (real_T)0;\n    trigInfo->count          = 0;\n    trigInfo->overFlow       = false;\n\n    trigInfo->trigSignals.nSections = 0;\n    trigInfo->trigSignals.sections  = NULL;\n    trigInfo->trigSignals.nBytes    = 0;\n\n    trigInfo->oldTrigSigVals    = NULL;\n    trigInfo->haveOldTrigSigVal = false;\n\n    trigInfo->preTrig.duration       = 0;\n    trigInfo->preTrig.count          = 0;\n    trigInfo->preTrig.checkUnderFlow = false;\n} /* end UploadDestroyTrigger */\n\n\n/* Function ====================================================================\n * Reset fields of the uploadinfo struct.\n */\nPUBLIC void UploadLogInfoReset(int32_T upInfoIdx)\n{\n    static boolean_T firstTime[NUM_UPINFOS] = {true, true};\n    BdUploadInfo     *uploadInfo = &uploadInfoArray[upInfoIdx];\n    \n    /*\n     * uploadInfoArray is declared as global static, so most compilers will\n     * initialize the memory to zero.  However, the tic6000 assigns this\n     * variable into uninitialized memory.  When this function is called for\n     * the first time, we attempt to free garbage pointers and crash.  By\n     * clearing unloadInfoArray explicitly the first time this function is\n     * called, we can ensure that this function will work for all compilers.\n     */\n    if (firstTime[upInfoIdx]) {\n        memset(uploadInfo, 0, sizeof(BdUploadInfo));\n        firstTime[upInfoIdx] = false;\n    }\n   \n    /* sysUploadTable */\n    uploadInfo->nSys      = 0;\n    uploadInfo->sysTables = NULL;\n\n    uploadInfo->circBufs = NULL;\n\n    uploadInfo->bufMemList.bufs = NULL;\n    uploadInfo->bufMemList.tids = NULL;\n\n    /* Reset trigger info */\n    UploadDestroyTrigger(upInfoIdx);\n\n} /* end UploadLogInfoReset */\n\n\n/* Function ====================================================================\n * Destroy all data associated with data logging.  Fields are re-initialized\n * and pointers NULL'ed out by UploadLogInfoReset().\n */\nPUBLIC void UploadLogInfoTerm(int32_T upInfoIdx, int_T numSampTimes)\n{\n    int_T i;\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n\n    if (uploadInfo->nSys == 0) return; /* Nothing to terminate */\n\n    /*\n     * Free fields of the sysUpload tables and then the table itself.\n     */\n    for (i=0; i<uploadInfo->nSys; i++) {\n        int_T     tid;\n        UploadMap **uploadMap = uploadInfo->sysTables[i].uploadMap;\n        \n        for (tid=0; tid<numSampTimes; tid++) {\n            if (uploadMap[tid] != NULL) {\n                /* Free fields of uploadMap. */\n                free(uploadMap[tid]->sections);\n\n                /* Free the uploadMap. */\n                free(uploadMap[tid]);\n            }\n        }\n\n        free(uploadMap);\n    }\n\n    free(uploadInfo->sysTables);\n\n    /* Free circular buf fields and bufMemLists. */\n    if (uploadInfo->circBufs) {\n        for (i=0; i<numSampTimes; i++) {\n            free(uploadInfo->circBufs[i].buf);\n        }\n        free(uploadInfo->circBufs);\n    }\n\n    free(uploadInfo->bufMemList.bufs);\n    free(uploadInfo->bufMemList.tids);\n    \n    /*\n     * Free trigger info.\n     */\n    UploadDestroyTrigger(upInfoIdx);\n\n    /*\n     * Reset all vals to initial value and NULL out pointers.\n     */\n    UploadLogInfoReset(upInfoIdx);\n} /* end UploadLogInfoTerm */\n\n\n/* Function ====================================================================\n * Prepare for final flush of buffers.  This involves setting the trigger\n * state to appropriate values.\n */\nPUBLIC void UploadPrepareForFinalFlush(int32_T upInfoIdx)\n{\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n\n    switch(uploadInfo->trigInfo.state) {\n    case TRIGGER_FIRED:\n    case TRIGGER_TERMINATING:\n        /*\n         * 1) set trig state to \"terminating\" so that the eventual call to\n         *    UploadBufGetData knows to add the terminator flag to\n         *    the data stream.\n         * 2) set trig state to \"oneshot\" to prevent re-arming\n         */\n        uploadInfo->trigInfo.state   = TRIGGER_TERMINATING; /* 1 */\n        uploadInfo->trigInfo.holdOff = TRIGMODE_ONESHOT;    /* 2 */\n        break;\n\n    case TRIGGER_UNARMED:\n    case TRIGGER_HOLDING_OFF:\n    case TRIGGER_ARMED:\n    case TRIGGER_DELAYED:\n        /* do nothing */\n        break;\n    }\n\n#ifdef VXWORKS\n    /* Let upload server run to ensure that term pkt is sent to host. One\n       semGive() is for the background task and the other is for the explicit\n       call to rt_UploadServerWork() in DisconnectFromHost(). */\n    semGive(uploadSem);\n    semGive(uploadSem);\n#endif\n\t\n} /* end UploadPrepareForFinalFlush */\n\n\n/* Function ====================================================================\n * Initialize data uploading by processing the EXT_SELECT_SIGNALS packet\n * (which is passed in).  Return the error status.  See DumpSelectSignalPkt()\n * for a detailed description of the packet.\n */\n#ifndef EXTMODE_DISABLESIGNALMONITORING\nPUBLIC boolean_T UploadLogInfoInit(RTWExtModeInfo *ei,\n                                   int_T          numSampTimes,\n                                   const char     *pkt,\n                                   int32_T        upInfoIdx)\n{\n    int          nActiveTids;\n    int_T        i;\n    boolean_T    error   = EXT_NO_ERROR;\n    const char   *bufPtr = pkt;\n    BdUploadInfo *uploadInfo;\n\n    DumpSelectSignalPkt(pkt, numSampTimes);\n\n    /* Point to the correct uploadInfo */\n    uploadInfo           = &uploadInfoArray[upInfoIdx];\n    uploadInfo->upInfoIdx = upInfoIdx;\n\n    /* Free upInfo if fields are already allocated */\n    UploadLogInfoTerm(upInfoIdx, numSampTimes);\n\n    /* nSys */\n    (void)memcpy(&uploadInfo->nSys, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n    assert(uploadInfo->sysTables == NULL);\n    uploadInfo->sysTables = (SysUploadTable *)\n        calloc(uploadInfo->nSys, sizeof(SysUploadTable));\n    if (uploadInfo->sysTables == NULL) {\n        error = EXT_ERROR; goto EXIT_POINT;\n    }\n\n    /*\n     * Init each system table.\n     */\n    for (i=0; i<uploadInfo->nSys; i++) {\n        error = InitSysUploadTable(ei, numSampTimes,\n                                   &uploadInfo->sysTables[i], &bufPtr);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n    }\n\n    assert(uploadInfo->circBufs == NULL);\n    uploadInfo->circBufs = (CircularBuf *) calloc(numSampTimes,\n                                                  sizeof(CircularBuf));\n\n    /*\n     * Allocate the circular buffers.\n     */\n    nActiveTids = 0;\n    for (i=0; i<numSampTimes; i++) {\n        int32_T size;\n        \n        (void)memcpy(&size, bufPtr, sizeof(int32_T));\n        bufPtr += sizeof(int32_T);\n        \n        error = UploadBufInit(&uploadInfo->circBufs[i], size);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n\n        nActiveTids += (size != 0);\n    }\n\n    /*\n     * Initialize/Allocate the bufMemLists - these are used by\n     * ext_svr to pull the appropriate data out of the buffers and send it\n     * to the host.\n     */\n#if ASSERTS_ON\n    uploadInfo->bufMemList.maxBufs = nActiveTids;\n#endif\n    uploadInfo->bufMemList.nActiveBufs = 0;\n\n    assert(uploadInfo->bufMemList.bufs == NULL);\n    uploadInfo->bufMemList.bufs = (BufMem *)malloc(nActiveTids*sizeof(BufMem));\n    if (uploadInfo->bufMemList.bufs == NULL) {\n        error = EXT_ERROR; goto EXIT_POINT;\n    }\n\n    assert(uploadInfo->bufMemList.tids == NULL);\n    uploadInfo->bufMemList.tids = (int_T *)malloc(nActiveTids*sizeof(int_T));\n    if (uploadInfo->bufMemList.tids == NULL) {\n        error = EXT_ERROR; goto EXIT_POINT;\n    }\n\nEXIT_POINT:\n    if (error != EXT_NO_ERROR) {\n        UploadLogInfoTerm(upInfoIdx, numSampTimes);\n    }\n    return(error);\n} /* end UploadLogInfoInit */\n\n\n/* Function ====================================================================\n * Initialize and configure the trigger attributes.  See DumpSelectTriggerPkt()\n * for a detailed description of the packet.\n */\nPUBLIC boolean_T UploadInitTrigger(RTWExtModeInfo *ei,\n                                   const char     *pkt,\n                                   int32_T         upInfoIdx)\n{\n    int_T       nSections;\n    int32_T     i32_tid;\n    int32_T     direction;\n    TriggerInfo *trigInfo;\n    boolean_T   error     = EXT_NO_ERROR;\n    const char  *bufPtr   = pkt;\n    \n    DumpSelectTriggerPkt(pkt);\n    \n    /* Select the trig Info */\n    trigInfo = &uploadInfoArray[upInfoIdx].trigInfo;\n\n    /* tid, duration, holdOff, delay and nsections */\n    (void)memcpy(&i32_tid, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n    trigInfo->tid = (int_T)i32_tid;\n\n    (void)memcpy(&trigInfo->duration, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    (void)memcpy(&trigInfo->holdOff, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    (void)memcpy(&trigInfo->delay, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    (void)memcpy(&trigInfo->trigSignals.nSections, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n    \n    nSections = trigInfo->trigSignals.nSections;\n\n    /*\n     * Init the UploadSections - if the trigger is signal based.\n     */\n    if (nSections > 0) {\n        /* trigger is signal based */\n        int       section;\n        UploadMap *map = &trigInfo->trigSignals;\n\n        assert(map->nBytes == 0);\n        assert(map->sections == NULL);\n        map->sections = (UploadSection *)malloc(nSections * sizeof(UploadSection));\n        if (map->sections == NULL) {\n            error = EXT_ERROR; goto EXIT_POINT;\n        }\n            \n        for (section=0; section<map->nSections; section++) {\n            int32_T       tmpBuf[4];\n            UploadSection *uploadSection = &map->sections[section];\n\n            /* read [B S W DI] */\n            (void)memcpy(&tmpBuf, bufPtr, sizeof(int32_T)*4);\n            bufPtr += (sizeof(int32_T) * 4);\n            \n            InitUploadSection(ei, tmpBuf, uploadSection);\n\n            /* keep track of total number of bytes in this map */\n            map->nBytes += uploadSection->nBytes;\n        }\n\n        /*\n         * Allocate space to hold the old values of the trigger signals.  Note\n         * that trigger signals are guaranteed to be of type SL_DOUBLE (real_T)\n         * and non-complex.\n         */\n        assert(trigInfo->oldTrigSigVals == NULL);\n        assert(trigInfo->oldTrigSigVals == NULL);\n        trigInfo->oldTrigSigVals = (real_T *)malloc(map->nBytes);\n        if (trigInfo->oldTrigSigVals == NULL) {\n            error = EXT_ERROR; goto EXIT_POINT;\n        }\n    }\n            \n    /* Direction. */\n    (void)memcpy(&direction, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    trigInfo->lookForRising  = \n        ((direction == UPLOAD_RISING_TRIGGER)  || \n         (direction == UPLOAD_EITHER_RISING_OR_FALLING_TRIGGER));\n\n    trigInfo->lookForFalling = \n        ((direction == UPLOAD_FALLING_TRIGGER) || \n         (direction == UPLOAD_EITHER_RISING_OR_FALLING_TRIGGER));\n    \n    /* level */\n    (void)memcpy(&trigInfo->level, bufPtr, sizeof(real_T));\n    bufPtr += sizeof(real_T);\n\n    /*\n     * Convert delay to pre-trigger duration.\n     */\n    if (trigInfo->delay < 0) {\n        trigInfo->preTrig.duration = -trigInfo->delay;\n        trigInfo->delay            = 0;\n    } else {\n        trigInfo->preTrig.duration = 0;\n    }\n\nEXIT_POINT:\n    if (error != EXT_NO_ERROR) {\n        UploadDestroyTrigger(upInfoIdx);\n    }\n    return(error);\n} /* end UploadInitTrigger */\n\n\n/* Function ====================================================================\n * Arm the trigger.\n */\nPUBLIC void UploadArmTrigger(int32_T upInfoIdx, int_T numSampTimes)\n{\n    int_T   tid;\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n\n    assert((uploadInfo->trigInfo.state == TRIGGER_UNARMED) ||\n           (uploadInfo->trigInfo.state == TRIGGER_HOLDING_OFF));\n\n    host_upstatus_is_uploading = false;\n\n    /*\n     * Re-initialize.\n     */\n    uploadInfo->trigInfo.overFlow = false;\n    for (tid=0; tid<numSampTimes; tid++) {\n        CircularBuf *circBuf = &uploadInfo->circBufs[tid];\n        if (circBuf->bufSize > 0) {\n            circBuf->head = circBuf->buf;\n            circBuf->tail = circBuf->buf;\n\n            circBuf->newTail = NULL;\n            circBuf->empty   = true;\n        }\n    }\n\n    /* \n     * Re-initialize trigger fields.\n     */\n    uploadInfo->trigInfo.count             = 0;\n    uploadInfo->trigInfo.haveOldTrigSigVal = false;\n\n    /* \n     * Reset pre-trig counts for normal mode.\n     */\n    uploadInfo->trigInfo.preTrig.count = 0;\n\n    /* \n     * Re-arm after all initialization.  Make sure that trigInfo.state is\n     * set last since this routine may be interrupted.\n     */\n    uploadInfo->trigInfo.state = TRIGGER_ARMED;\n\n} /* end UploadArmTrigger */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n/* Function ====================================================================\n * Terminate this data logging session by destroying the uploadInfo and\n * setting the trigger backed to the unarmed state.\n */\nPUBLIC void UploadEndLoggingSession(int32_T upInfoIdx, int_T numSampTimes)\n{\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n\n    uploadInfo->trigInfo.state = TRIGGER_UNARMED;\n    UploadLogInfoTerm(upInfoIdx, numSampTimes);\n} /* end UploadEndLoggingSession */\n\n\n/* Function ====================================================================\n * Cancel this data logging session.\n */\nPUBLIC void UploadCancelLogging(int32_T upInfoIdx)\n{\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n\n    switch(uploadInfo->trigInfo.state) {\n\n    case TRIGGER_UNARMED:\n        break;\n\n    case TRIGGER_HOLDING_OFF:\n    case TRIGGER_ARMED:\n    case TRIGGER_DELAYED:\n    case TRIGGER_FIRED:\n        /*\n         * Move to TRIGGER_TERMINATING and ensure that we are no longer in\n         * \"normal\" mode (TRIGMODE_NORMAL) so that the trigger does not get\n         * re-armed.\n         */\n        uploadInfo->trigInfo.holdOff = TRIGMODE_ONESHOT;\n        uploadInfo->trigInfo.state   = TRIGGER_TERMINATING;\n#ifdef VXWORKS\n        /*\n         * Let upload server run to ensure that term pkt is sent to host (needed\n         * for all but the TRIGGERED_FIRED case since the upload server is\n         * inactive).\n         */\n        semGive(uploadSem);\n#endif\n        break;\n    \n    case TRIGGER_TERMINATING:\n        /*\n         * Ensure that we are no longer in \"normal\" mode (TRIGMODE_NORMAL) so\n         * that the trigger does not get re-armed.\n         */\n        uploadInfo->trigInfo.holdOff = TRIGMODE_ONESHOT;\n        break;\n    }\n} /* end UploadCancelLogEvent */\n\n\n/* Function ====================================================================\n * Called by ext_svr (background task), in order to perform tasks that need\n * to be done after each time that data has been sent to the host.  This\n * includes:\n *\n * o move the tail for the specified buffer forward\n * o detect the end of a data logging event so that the trigger state can\n *   be either set to unarmed (for one shot) or backed to armed (for normal\n *   mode).\n * \n * NOTE:  UploadBufGetData and UploadBufMoveTail must be called in pairs where the\n *        UploadBufGetData call precedes the UploadBufMoveTail call.\n */\n#ifndef EXTMODE_DISABLESIGNALMONITORING\nPUBLIC void UploadBufDataSent(const int_T tid, int32_T upInfoIdx)\n{   \n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n    CircularBuf  *circBuf    = &uploadInfo->circBufs[tid];            \n\n    host_upstatus_is_uploading = true;\n    \n    /* Move the tail forward. */\n    circBuf->tail = circBuf->newTail;\n        \n#ifdef EXTMODE_PROTECT_CRITICAL_REGIONS\n    /* \n     * disable interrupts around this critical region. We need to \n     * guarantee that reading the head pointer is an atomic \n     * operation.\n     */\n    EXTMODE_DISABLE_INTERRUPTS;\n#endif\n    \n    /* \n     * Since we are moving the tail forward, we know that head == tail\n     * represents an empty buffer and not a full buffer.\n     */\n    circBuf->empty = (circBuf->tail == circBuf->head);\n    \n#ifdef EXTMODE_PROTECT_CRITICAL_REGIONS\n    /* re-enable interrupts */\n    EXTMODE_ENABLE_INTERRUPTS;\n#endif\n\n} /* end UploadBufDataSent */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n/*\n * Macro =======================================================================\n * Move the tail of a circular buffer forward by one time step - accounting for\n * wrapping.\n */\n#define MOVE_TAIL_ONESTEP(circBuf, end)                            \\\n{                                                                  \\\n    int     nBytesPassedEnd;                                       \\\n    int     nBytesInStep;                                          \\\n    int32_T *nBytesPtr = (int32_T *)((circBuf)->tail)+1;           \\\n                                                                   \\\n    (void)memcpy(&nBytesInStep, nBytesPtr, sizeof(int32_T));       \\\n    nBytesInStep += (2*sizeof(int32_T));                           \\\n    assert(nBytesInStep > 0);                                      \\\n    (circBuf)->tail += (nBytesInStep);                             \\\n    nBytesPassedEnd = (int)((circBuf)->tail - (end));              \\\n    if (nBytesPassedEnd >= 0) {                                    \\\n        (circBuf)->tail = (circBuf)->buf + nBytesPassedEnd;        \\\n    }                                                              \\\n} /* end MOVE_TAIL_ONESTEP */\n\n\n/*\n * Macro =======================================================================\n * Copy data into the circular buffer.\n */\n#define CIRCBUF_COPY_DATA(bufMem, data)                         \\\n{                                                               \\\n    (void)memcpy((bufMem).section1, (data), (bufMem).nBytes1);  \\\n    if ((bufMem).section2 != NULL) {                            \\\n        char *tmp = ((char *)(data)) + (bufMem).nBytes1;        \\\n        (void)memcpy((bufMem).section2, tmp, (bufMem).nBytes2); \\\n    }                                                           \\\n} /* end CIRCBUF_COPY_DATA */\n\n\n/* Function ====================================================================\n * Assign sections in the circular buffer for the requested number of bytes\n * (i.e., fill in the bufMem struct).  If there is no room in the circular\n * buffer return an overflow error.\n *\n * NOTE: Do not move the CircularBuffers head forward in this function!  \n *       Only move the tmpHead forward.  The actual head is not advanced\n *       until the entire time point is successfully copied into the buffer.\n *\n *       This function modifies tmpHead to point at the next available \n *       location.\n *\n *       It is possible for tmpHead to equal the tail upon entry to this\n *       function.  This does not necessarily mean that the buffer is\n *       empty (unwrapped).  It could also mean that the buffer is exactly\n *       full (this is considered as wrapped).\n */\n#ifndef EXTMODE_DISABLESIGNALMONITORING\nPRIVATE boolean_T UploadBufAssignMem(\n    CircularBuf  *circBuf,\n    int_T        nBytesToAdd,\n    char         **tmpHead,   /* in-out */\n    BufMem       *bufMem)     /* out */\n{\n    int_T       nBytesLeft;\n    boolean_T   overFlow  = false;\n    char        *end      = circBuf->buf + circBuf->bufSize; /* 1 passed end */\n\n    if ((*tmpHead > circBuf->tail) || circBuf->empty) {\n        /* buffer not wrapped */\n        nBytesLeft = (int_T)((end - *tmpHead) + (circBuf->tail - circBuf->buf));\n\n        if (nBytesLeft < nBytesToAdd) {\n            overFlow = true;\n            goto EXIT_POINT;\n        }\n\n        if ((*tmpHead + nBytesToAdd) < end) {\n            /* still not wrapped */\n            bufMem->nBytes1  = nBytesToAdd;\n            bufMem->section1 = *tmpHead;\n\n            bufMem->nBytes2  = 0;\n            bufMem->section2 = NULL;\n\n            *tmpHead += nBytesToAdd;\n        } else {\n            /* now we're wrapped */\n            bufMem->nBytes1  = (int_T)(end - *tmpHead);\n            bufMem->section1 = *tmpHead;\n\n            bufMem->nBytes2  = nBytesToAdd - bufMem->nBytes1;\n            bufMem->section2 = (bufMem->nBytes2 > 0) ? circBuf->buf : NULL;\n\n            *tmpHead = circBuf->buf + bufMem->nBytes2;\n        }  \n    } else {\n        /* wrapped */\n        nBytesLeft = (int_T)(circBuf->tail - *tmpHead);\n        if (nBytesLeft < nBytesToAdd) {\n            overFlow = true;\n            goto EXIT_POINT;\n        }\n\n        bufMem->nBytes1  = nBytesToAdd;\n        bufMem->section1 = *tmpHead;\n\n        bufMem->nBytes2  = 0;\n        bufMem->section2 = NULL;\n\n        *tmpHead += nBytesToAdd;\n    }\n    \nEXIT_POINT:\n    return(overFlow);\n} /* end UploadBufAssignMem */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n/* Function ====================================================================\n * Check the trigger signals for crossings.  Return true if a trigger event is\n * encountered.  It is assumed that the trigger signals are real_T.\n */\n#ifndef EXTMODE_DISABLESIGNALMONITORING\nPRIVATE boolean_T UploadCheckTriggerSignals(int32_T upInfoIdx)\n{\n    int          i;\n    BdUploadInfo *uploadInfo      = &uploadInfoArray[upInfoIdx];\n    TriggerInfo  *trigInfo        = &uploadInfo->trigInfo;\n    real_T       *oldTrigSigVals  = trigInfo->oldTrigSigVals;\n    real_T       *oldSigPtr       = oldTrigSigVals;\n       \n    for (i=0; i<trigInfo->trigSignals.nSections; i++) {\n        UploadSection *section = &trigInfo->trigSignals.sections[i];\n        int_T         nEls     = section->nBytes / sizeof(real_T);\n\n        /*\n         * If we have a previous signal value to check, then see if we had\n         * a crossing.\n         */\n        if (trigInfo->haveOldTrigSigVal) {\n            int_T   j;\n            real_T  level   = trigInfo->level;\n            real_T  *rStart = (real_T *)section->start; /* guaranteed by host */\n            \n            for (j=0; j<nEls; j++) {\n                if (trigInfo->lookForRising && \n                    (((rStart[j] >= level) && (oldSigPtr[j] <  level)) ||\n                     ((rStart[j] >  level) && (oldSigPtr[j] == level)))) {\n                    return(true);\n                }\n                if (trigInfo->lookForFalling &&\n                    (((rStart[j] < level)  && (oldSigPtr[j] >= level)) ||\n                     ((rStart[j] == level) && (oldSigPtr[j] >  level)))) {\n                    return(true);\n                }\n            }\n        }\n\n        /*\n         * Update old signal values.\n         */\n        (void)memcpy(oldSigPtr, section->start, section->nBytes);\n        oldSigPtr += nEls;\n    }\n    assert(((unsigned char *)oldTrigSigVals) + trigInfo->trigSignals.nBytes == oldSigPtr);\n    trigInfo->haveOldTrigSigVal = true;\n    return(false);\n} /* end UploadCheckTriggerSignals */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n\n/* Function ====================================================================\n * If the trigger is in the TRIGGER_FIRED state or we are collecting data for\n * pre-triggering, add data, for each tid with a hit, to the upload buffers.  \n * This function is called from within the appropriate task, once per sample\n * hit.\n *\n * The format of the packet that is sent to the host is as follows:\n *\n * definitions:\n *      pktType - A qualifier indicating any special action that needs to be\n *                taken (e.g., a termination flag following the last data point,\n *                or a flag indicating that it is the first data point after\n *                a trigger event).\n *\n *      nBytes - total number of target bytes for this packet (including the\n *               nBytes field).  nBytes worth of data represents 1 full time\n *               step of the target simulation.\n *\n *      nSys - The number of systems for which this packet contains data.\n *\n *      tid - The tid with which this data is associated.\n *\n *      upInfoIdx - upInfo index\n *\n *      t - simulation time\n *\n *      sysId - The index into the BdUploadInfo.sysTables array so that we can\n *              map the target data back to the appropriate system.  This is\n *              NOT the descendant system index!\n *\n *      data - the target simulation data (in target format)\n *\n * The packet looks like:\n * [nBytes pktType nSys tid upInfoIdx t sysId [data] sysId [data]...]\n *     |                            | |         | |          |\n *     ----------------------------- ----------- ------------\n *          pkt header          sys data     sys data\n *\n * Ints are int32_T.\n */\n#ifndef EXTMODE_DISABLESIGNALMONITORING\nPUBLIC void UploadBufAddTimePoint(int_T tid, real_T taskTime,\n                                  int32_T upInfoIdx)\n{\n    int_T        preTrig;\n    int_T        overFlow;\n    TriggerInfo  *trigInfo;\n    CircularBuf  *circBuf;\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n\n    overFlow   = false;\n    trigInfo   = &uploadInfo->trigInfo;\n    circBuf    = &uploadInfo->circBufs[tid];\n    \n    /*\n     * Check for transitions from the TRIGGER_ARMED state to either the\n     * TRIGGER_FIRED_STATE or the TRIGGER_DELAYED state.  We only do this\n     * if it is a sample hit for the trigger signal.  Note that this\n     * is the only place in the whole world that the trigger state can\n     * move from TRIGGER_ARMED_STATE to TRIGGER_DELAYED or TRIGGER_FIRED.\n     */\n    if (trigInfo->state == TRIGGER_ARMED) {\n        if (trigInfo->trigSignals.nSections == 0) {\n            /* short-circuit for manual trigger */\n            trigInfo->state = TRIGGER_FIRED;\n        } else\n            if ((tid == trigInfo->tid) &&\n                (UploadCheckTriggerSignals(upInfoIdx))) {\n                /* trig signal crossing */\n                if (trigInfo->delay == 0) {\n                    trigInfo->state = TRIGGER_FIRED;\n                    /* 0 unless pre-trig */\n                    trigInfo->count = trigInfo->preTrig.count;\n                } else {\n                    trigInfo->state = TRIGGER_DELAYED;\n                    assert(trigInfo->count == 0);\n                    \n                    /* We will be skipping this step, so the delay count is 1. */\n                    trigInfo->count = 1;\n                }\n            }\n    }\n    \n    preTrig = (trigInfo->state == TRIGGER_ARMED) &&\n        (trigInfo->preTrig.duration > 0);\n    \n    /*\n     * Handle adding data to the collection buffers - if needed.\n     */\n    if (((trigInfo->state == TRIGGER_FIRED) || preTrig) &&\n        /* bufSize == 0 means no signals in this tid */\n        circBuf->bufSize != 0) {\n        \n        int32_T     i;\n        BufMem      bufMem;\n        BufMem      pktStart;\n        int_T       size;\n        char_T *tmpHead    = circBuf->head;\n        const int_T PKT_TYPE_IDX = 0;\n        const int_T NBYTES_IDX   = 1;\n        const int_T NSYS_IDX     = 2;\n        const int_T TID_IDX      = 3;\n        const int_T UPINFO_IDX   = 4;\n\n        int32_T intHdr[5] = {0, 0, 0, 0, 0};\n        intHdr[UPINFO_IDX] = upInfoIdx;\n        \n        if (preTrig && (trigInfo->preTrig.count==trigInfo->preTrig.duration)) {\n            /* Advance the tail (we don't need the oldest point anymore). */\n            char *end = circBuf->buf + circBuf->bufSize;\n            MOVE_TAIL_ONESTEP(circBuf, end);\n            trigInfo->preTrig.count--;\n        }\n        \n        /*\n         * Save some space for the 5 integer values that make up the packet\n         * header: [pktType nBytes nSys tid upInfoIdx].\n         * The values are filled in later.\n         */\n        size = 5*sizeof(int32_T);\n        overFlow = UploadBufAssignMem(circBuf, size, &tmpHead, &pktStart);\n        if (overFlow) goto EXIT_POINT;\n\n        /*\n         * We do not want to include the packet type and number of bytes\n         * in the size calculation.  Size should represent the payload of\n         * this packet.  The packet type and number of bytes represent the\n         * packet header and are not included in the payload size.\n         */\n        size -= 2*sizeof(int32_T);\n        intHdr[NBYTES_IDX] += size;\n        \n        /* time */\n        overFlow =\n            UploadBufAssignMem(circBuf, sizeof(real_T), &tmpHead, &bufMem);\n        if (overFlow) goto EXIT_POINT;\n        intHdr[NBYTES_IDX] += sizeof(real_T);\n        \n        CIRCBUF_COPY_DATA(bufMem, &taskTime);\n\n        /*\n         * Check each system for an UploadMap. \n         */\n        for (i=0; i<uploadInfo->nSys; i++) {\n            const SysUploadTable *sysTable =\n                (const SysUploadTable *)&uploadInfo->sysTables[i];\n            \n            if ( (*sysTable->enableState != SUBSYS_RAN_BC_DISABLE) && \n                 (*sysTable->enableState != SUBSYS_RAN_BC_ENABLE_TO_DISABLE) ) {\n                UploadMap *map = sysTable->uploadMap[tid];\n\n                if (map != NULL) {\n                    int_T section;\n                    intHdr[NSYS_IDX]++;\n                    \n                    /* Add system index */\n                    size = sizeof(int32_T);\n                    overFlow =\n                        UploadBufAssignMem(circBuf, size, &tmpHead, &bufMem);\n                    if (overFlow) goto EXIT_POINT;\n                    intHdr[NBYTES_IDX] += size;\n                    \n                    CIRCBUF_COPY_DATA(bufMem, &i);\n                    \n                    /* Add data values */\n                    for (section=0; section<map->nSections; section++) {\n                        UploadSection *sect = &map->sections[section];\n                        \n#ifdef MW_DYNAMIC_STRING_SUPPORT\n                        if (sect->isString) {\n                            /* String data is [nBytes \"abc...\\0\"] */\n                            const void* strPtr = *(void**)sect->start;\n                            /* Add number of bytes of the string, including null-terminator */\n                            int32_T strNBytes = suStrlen(strPtr) + 1;\n                            char *tmpStr;\n                            \n                            overFlow = UploadBufAssignMem(circBuf, size, &tmpHead, &bufMem);\n                            if (overFlow) goto EXIT_POINT;\n                            intHdr[NBYTES_IDX] += size;\n                            CIRCBUF_COPY_DATA(bufMem, &strNBytes);\n\n                            /* Add character bytes */\n                            overFlow = UploadBufAssignMem(circBuf, strNBytes, &tmpHead, &bufMem);\n                            if (overFlow) goto EXIT_POINT;\n                            intHdr[NBYTES_IDX] += strNBytes;\n                            \n                            tmpStr = suToCStr(strPtr);\n                            CIRCBUF_COPY_DATA(bufMem, tmpStr);\n                            suFreeCStr(tmpStr);\n                        } else\n#endif\n                        \n                        {\n                            /* Regular cases */\n                            overFlow = UploadBufAssignMem(\n                                circBuf, sect->nBytes, &tmpHead, &bufMem);\n                            if (overFlow) goto EXIT_POINT;\n                            intHdr[NBYTES_IDX] += sect->nBytes;\n                            \n                            CIRCBUF_COPY_DATA(bufMem, sect->start);\n                        }\n                    }\n                }\n            }\n        }\n\n        /* If no systems were active then, do nothing. */\n        if (intHdr[NSYS_IDX] == 0) goto EXIT_POINT;\n        \n        /*\n         * Go back and finish the header: [nBytes pktType nSys tid]\n         */\n        \n        /* ...pktType */\n        intHdr[PKT_TYPE_IDX] = EXT_UPLOAD_LOGGING_DATA;\n\n        /* ...tid */\n        intHdr[TID_IDX] = tid;\n        CIRCBUF_COPY_DATA(pktStart, intHdr);\n\n        /*\n         * Time point successfully added to queue.\n         */\n        circBuf->head  = tmpHead;\n        circBuf->empty = false;\n        \n        if (preTrig) {\n            trigInfo->preTrig.count++;\n        }\n    }\n\nEXIT_POINT:\n    if (!preTrig) {\n        if (overFlow) {\n            trigInfo->overFlow = true;\n            trigInfo->state    = TRIGGER_TERMINATING;\n        }\n#ifdef VXWORKS\n        else if (trigInfo->state == TRIGGER_FIRED) {\n            /* allow upload server to run - if data needs to be uploaded */\n            semGive(uploadSem);\n        }\n#endif\n    } \n} /* end UploadBufAddTimePoint */\n\n\n/* Function ====================================================================\n * Called at the base rate, controls the state of data logging including:\n *   - monitoring the trigger signal for a trigger event\n *   - managing transition of most trigger states\n *      o a separate function (UploadCheckEndTrigger manages the duration\n *        count and the transition from fired to terminating at the end\n *        of the data collection event).\n *\n * NOTE:\n *  o This function should be called after mdlOutputs for the base rate\n */\nPUBLIC void UploadCheckTrigger(int32_T upInfoIdx, int_T numSampTimes)\n{\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n    TriggerInfo  *trigInfo   = &uploadInfo->trigInfo;\n\n    if (trigInfo->state == TRIGGER_UNARMED) return;\n\n    if (trigInfo->state == TRIGGER_HOLDING_OFF) {\n        if (trigInfo->count++ == trigInfo->holdOff) {\n            UploadArmTrigger(upInfoIdx, numSampTimes);\n        } else {\n            return;\n        }\n    }\n\n    /*\n     * Transitions from the TRIGGER_ARMED_STATE to the TRIGGER_DELAYED\n     * state or to the TRIGGER_FIRED_STATE are checked for and realized\n     * within the task (tid) associated with the trigger signal.\n     * See UploadBufAddTimePoint().\n     */ \n    \n    /*\n     * Look for transitions from the TRIGGER_DELAYED state.  The TRIGGER_FIRED\n     * state always follows the TRIGGER_DELAYED state.\n     *\n     * NOTE: the trigInfo count field is first used to count the trigger delay\n     *       and then used to count the trigger duration\n     */\n    if (trigInfo->state == TRIGGER_DELAYED) {\n        if (trigInfo->count++ >= trigInfo->delay) {\n            trigInfo->count = trigInfo->preTrig.count; /* 0 unless pre-trig */\n            trigInfo->state = TRIGGER_FIRED;\n            if (trigInfo->preTrig.duration > 0) {\n                trigInfo->preTrig.checkUnderFlow = true;\n            }\n#ifdef VERBOSE\n            printf(\"\\nTrigger fired!\\n\");\n#endif\n        }\n    }\n} /* end UploadCheckTrigger */\n\n\n/* Function ====================================================================\n * Called at the base rate, controls the state of data logging wrt\n *  o incrementing the duration count\n *  o managing the transition to the trigger terminating state\n *\n * NOTES:\n *  o Call this function at the very end of a step.\n *  o Also see UploadCheckTrigger()\n */\nPUBLIC void UploadCheckEndTrigger(int32_T upInfoIdx)\n{\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n    TriggerInfo *trigInfo    = &uploadInfo->trigInfo;\n\n    if (trigInfo->state == TRIGGER_UNARMED) return;\n\n    /*\n     * Increment duration count and terminate the data logging event if\n     * the duration has been met.\n     */\n    if (trigInfo->state == TRIGGER_FIRED) {\n        trigInfo->count++;\n        if (trigInfo->count == trigInfo->duration) {\n            trigInfo->state = TRIGGER_TERMINATING;\n        }\n    }\n\n#ifdef VXWORKS\n    if (trigInfo->state == TRIGGER_TERMINATING) {\n        /* Let upload server run to ensure that term pkt is sent to host. */\n        semGive(uploadSem);\n    }\n#endif\n} /* end UploadCheckEndTrigger */\n\n\n/* Function ===================================================================\n * Search through the upload buffers and fill out the internal copy of the\n * buffer list.  It contains a list of all buffer memory (1 entry per non-empty\n * tid buffer) that needs to be sent to the host.  Fill out the fields of the\n * specified ExtBufMemList (passed in by ext_svr) to provide public, read-only\n * access.\n */\nPRIVATE void SetExtBufListFields(ExtBufMemList *extBufList,\n                                 int32_T       upInfoIdx,\n                                 int_T         numSampTimes)\n{\n    int_T       tid;\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n    BufMemList   *bufList    = &uploadInfo->bufMemList;\n\n    bufList->nActiveBufs = 0;\n\n    for (tid=0; tid<numSampTimes; tid++) {\n        CircularBuf *circBuf = &uploadInfo->circBufs[tid];\n\n        if (!circBuf->empty) {\n            BufMem  *bufMem;\n            char_T  *head;\n            char_T  *tail   = circBuf->tail;\n            int_T   size    = circBuf->bufSize;\n\n            \n#ifdef EXTMODE_PROTECT_CRITICAL_REGIONS\n            /* \n             * disable interrupts around this critical region. We need to \n             * guarantee that reading the head pointer is an atomic \n             * operation.\n             */\n            EXTMODE_DISABLE_INTERRUPTS;\n#endif\n\n            head = circBuf->head;\n\n            \n#ifdef EXTMODE_PROTECT_CRITICAL_REGIONS\n            /* re-enable interrupts */\n            EXTMODE_ENABLE_INTERRUPTS;\n#endif\n\n            /* Validate that head/tail ptrs are within allocated range. */\n            assert((head >= circBuf->buf) && (tail >= circBuf->buf));\n            assert((head < circBuf->buf + circBuf->bufSize) &&\n                   (tail < circBuf->buf + circBuf->bufSize));\n\n            bufMem = &bufList->bufs[bufList->nActiveBufs];\n            bufList->tids[bufList->nActiveBufs] = tid;\n            assert(bufList->nActiveBufs < bufList->maxBufs);\n            bufList->nActiveBufs++;\n\n            bufMem->section1 = tail;\n            circBuf->newTail = head;\n\n            if (head > tail) {\n                /* not wrapped - only one section required */\n                bufMem->nBytes1  = (int_T)(head - tail);\n\n                bufMem->nBytes2  = 0;\n                bufMem->section2 = NULL;\n            } else {\n                /* wrapped - 2 sections required */\n                bufMem->nBytes1 = (int_T)(circBuf->buf + size - tail);\n\n                bufMem->nBytes2  = (int_T)(head - circBuf->buf);\n                bufMem->section2 = circBuf->buf;\n            }\n        }\n    }\n\n    /*\n     * Provide ext_svr with readonly access to the bufMemList.\n     */\n    extBufList->nActiveBufs = bufList->nActiveBufs;\n    extBufList->bufs        = (const BufMem *)bufList->bufs;\n    extBufList->tids        = (const int_T *)bufList->tids;\n} /* end SetExtBufListFields */\n\n\n/* Function ===================================================================\n * Set the internal copy of the buffer list to \"empty\" & fill out the fields\n * of the specified ExtBufMemList (passed in by ext_svr) to provide public,\n * read only access.\n */\nPRIVATE void SetExtBufListFieldsForEmptyList(ExtBufMemList *extBufList,\n                                             int32_T       upInfoIdx)\n{\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n    BufMemList   *bufList    = &uploadInfo->bufMemList;\n\n    bufList->nActiveBufs = 0;\n\n    extBufList->nActiveBufs = bufList->nActiveBufs;\n    extBufList->bufs        = (const BufMem *)NULL;\n} /* end SetExtBufListFieldsForEmptyList */\n\n\n/* Function ====================================================================\n * Called by ext_svr (background task), this function checks all buffers for\n * data and returns a list of buffer memory to be sent to the host.\n */\nPUBLIC void UploadBufGetData(ExtBufMemList *extBufList,\n                             int32_T       upInfoIdx,\n                             int_T         numSampTimes)\n{\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n    TriggerInfo  *trigInfo   = &uploadInfo->trigInfo;\n    TriggerState trigState = trigInfo->state;\n \n    if ((trigState == TRIGGER_FIRED) ||\n        (trigState == TRIGGER_TERMINATING)) {\n\n        /* Make sure we start with an empty list */\n        SetExtBufListFieldsForEmptyList(extBufList, upInfoIdx);\n        SetExtBufListFields(extBufList, upInfoIdx, numSampTimes);\n\n        /*\n         * If all bufs are empty and we are terminating then we're now done!\n         */\n        if ((extBufList->nActiveBufs == 0) &&\n            (trigState == TRIGGER_TERMINATING)) {\n\n            host_upstatus_is_uploading = false;\n\n            if (trigInfo->holdOff == TRIGMODE_ONESHOT) {\n                SendPktToHost(EXT_TERMINATE_LOG_SESSION, sizeof(int32_T),\n                              (char *)&upInfoIdx);\n                UploadEndLoggingSession(upInfoIdx, numSampTimes);\n            } else {\n                SendPktToHost(EXT_TERMINATE_LOG_EVENT, sizeof(int32_T),\n                              (char *)&upInfoIdx);\n                trigInfo->count = 0;\n                trigInfo->state = TRIGGER_HOLDING_OFF;\n            }\n        }\n    } else {\n        SetExtBufListFieldsForEmptyList(extBufList, upInfoIdx);\n    }\n} /* end UploadBufGetData */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n\n/* [EOF] updown.c */\n\n/* LocalWords:  DType pbuf NPARAMS dtype tran Els EXTMODE HDR abc\n * LocalWords:  DISABLEPARAMETERTUNING bufs buf blockio tids sys's nbuf sigs\n * LocalWords:  tid's DISABLESIGNALMONITORING uploadinfo NULL'ed vals oneshot\n * LocalWords:  sem svr TRIGMODE ONESTEP CIRCBUF tmp\n */\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true,"showProtectedV2Report":true}};